<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>阳阳&amp;洋洋</title>
    <link href="/2024/12/10/%E7%BA%AA%E5%BF%B5%E6%97%A5/"/>
    <url>/2024/12/10/%E7%BA%AA%E5%BF%B5%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<!---more--><p><img src="/Assets/1.png"></p>]]></content>
    
    
    <categories>
      
      <category>阳阳</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阳阳</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DeepML40_Implementing a Custom Dense Layer in Python</title>
    <link href="/2024/11/11/DeepML40_Implementing%20a%20Custom%20Dense%20Layer%20in%20Python/"/>
    <url>/2024/11/11/DeepML40_Implementing%20a%20Custom%20Dense%20Layer%20in%20Python/</url>
    
    <content type="html"><![CDATA[<!---more--><p><img src="/Assets/6a56529ac734f0094305df8f18df9582_MD5.png"></p><p><img src="/Assets/c130ce7634bffb8e2ac038f1c1e5e634_MD5.png"></p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>DeepML</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DeepML38_Implement AdaBoost Fit Method</title>
    <link href="/2024/11/11/DeepML38_Implement%20AdaBoost%20Fit%20Method/"/>
    <url>/2024/11/11/DeepML38_Implement%20AdaBoost%20Fit%20Method/</url>
    
    <content type="html"><![CDATA[<!---more--><ul><li><p>后一个模型的训练永远是在前一个模型的基础上完成；顺序，级联的结构</p></li><li><p>对于训练每个weak learner，计算样本困难度</p><ul><li>初始化所有样本难度为$w_i&#x3D;\frac{1}{N}$</li><li>利用当前weak learner的训练结果，更新所有样本的困难度</li><li>$w_i^{\text {new }}&#x3D;\left{\begin{array}{c}\frac{1}{2(1-\varepsilon)} w_i^{\text {old }} \ \frac{1}{2 \varepsilon} w_i^{\text {old }}\end{array}\right.$，如果当前样本被正确分类和错误分类，$\varepsilon$表示通过当前learner所产生的错误率</li><li>给予当前样本困难度，训练下一个learner</li></ul></li><li><p>学习每个weak learner的权重，$\alpha_k &#x3D; \frac{1}{2}log(\frac{1-\varepsilon_k}{\varepsilon_k})$</p></li><li><p>$\alpha_1 f_1+\alpha_2 f_2+\alpha_3 f_3&#x3D;\bar{F}$</p></li><li><p>Pros：模型性能天花板高</p><ul><li>顺序，级联结构+利用权重组合结果，擅长解决困难问题</li></ul></li><li><p>Cons：模型的性能起点低</p><ul><li>容易Overfit</li><li>对于异常点Outlier过于敏感</li><li>速度慢</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>DeepML</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DeepML21_Pegasos Kernel SVM Implementation</title>
    <link href="/2024/11/10/DeepML21_Pegasos%20Kernel%20SVM%20Implementation/"/>
    <url>/2024/11/10/DeepML21_Pegasos%20Kernel%20SVM%20Implementation/</url>
    
    <content type="html"><![CDATA[<!---more--><p><img src="/Assets/1d069c7151b6362ed391fc19ad452307_MD5.png"></p><p><img src="/Assets/8c0ad083d678aa8a6f88c8b1b66404b3_MD5.png"></p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>DeepML</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DeepML19_Principal Component Analysis (PCA)</title>
    <link href="/2024/11/10/DeepML19_Principal%20Component%20Analysis%20(PCA)/"/>
    <url>/2024/11/10/DeepML19_Principal%20Component%20Analysis%20(PCA)/</url>
    
    <content type="html"><![CDATA[<!---more--><ul><li>PCA利用特征值和特征向量来识别数据集的主成分</li><li>对于给定的矩阵$A$，表示PCA中的协方差矩阵，特征值$\lambda$及其对应的特征向量$v$满足：$Av&#x3D;\lambda v$</li><li>矩阵的特征值$A$通过求解特征方程可以得出$det(A-\lambda I)&#x3D;0$，$I$是与$A$维度相同的单位矩阵</li><li>特征值的大小与其对应的特征向量在表示数据集变异性方面的重要性相关，通过选择与最大特征值相对应的特征向量子集，PCA可以实现降维，同时尽可能多地保留数据集的变异性</li><li>实际应用<ul><li>标准化数据集：保证每个特征的平均值是$0$，标准差是$1$</li><li>计算协方差矩阵：反映特征如何一起变化</li><li>寻找特征值和特征向量：求解协方差矩阵的特征方程</li><li>选择主成分：选择具有最高特征值的特征向量（成分）进行降维</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>DeepML</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AI工具总结</title>
    <link href="/2024/10/30/AI%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/"/>
    <url>/2024/10/30/AI%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="Cursor"><a href="#Cursor" class="headerlink" title="Cursor"></a>Cursor</h3><ul><li><a href="https://www.cursor.com/">https://www.cursor.com/</a></li><li>【编程工具】独立IDE</li><li>可以导入vscode的插件设置等</li><li>有划词修改功能-&gt;微调</li><li>开箱即用-&gt;没有网络问题</li></ul><h3 id="Copilot"><a href="#Copilot" class="headerlink" title="Copilot"></a>Copilot</h3><ul><li><a href="https://github.com/features/copilot">https://github.com/features/copilot</a></li><li>【编程工具】IDE插件-&gt;vscode，JetBrains等</li><li>集成Github代码</li><li>#TODO 需要Github学生认证</li></ul><h3 id="Claude"><a href="#Claude" class="headerlink" title="Claude"></a>Claude</h3><ul><li><a href="https://claude.ai/onboarding">https://claude.ai/onboarding</a></li><li>要手机号注册</li></ul><h3 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h3><ul><li><a href="https://chatgpt.com/">https://chatgpt.com/</a></li><li>现最新：GPT4o</li></ul><h3 id="文心一言"><a href="#文心一言" class="headerlink" title="文心一言"></a>文心一言</h3><ul><li><a href="https://yiyan.baidu.com/">https://yiyan.baidu.com/</a></li><li>整体效果和GPT3.5比较接近</li></ul><h3 id="通义千问"><a href="#通义千问" class="headerlink" title="通义千问"></a>通义千问</h3><ul><li><a href="https://tongyi.aliyun.com/">https://tongyi.aliyun.com/</a></li><li>开源模型</li></ul><h3 id="豆包"><a href="#豆包" class="headerlink" title="豆包"></a>豆包</h3><ul><li><a href="https://www.doubao.com/chat/">https://www.doubao.com/chat/</a></li><li>可以语音</li></ul><h3 id="Kimi"><a href="#Kimi" class="headerlink" title="Kimi"></a>Kimi</h3><ul><li><a href="https://kimi.moonshot.cn/">https://kimi.moonshot.cn/</a></li><li>长文本，联网搜索</li></ul>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Neo4j学习</title>
    <link href="/2024/10/30/Neo4j%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/10/30/Neo4j%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><ol><li>需要已经安装好homebrew和JAVA</li><li>终端输入<code>brew install neo4j</code></li><li>进入neo4j官网：选择products-选择deploy-选择deployment center，<a href="https://neo4j.com/deployment-center/">链接</a></li><li>选择对应版本下载得到<code>tar.gz</code>文件，解压</li><li>进入<code>Downloads</code>文件夹，改名：&#96;mv neo4j-community-5.1.0 NEO4J_HOME</li><li>将文件移动到<code>home</code>目录，<code>cp NEO4J_HOME $HOME</code></li><li>启动，终端输入：<code>neo4j start</code></li><li>停止，终端输入：<code>neo4j stop</code></li><li>安装插件：下载对应的文件放入<code>plugins</code>文件夹中</li></ol><p><img src="/../../Assets/a66ebbdc01b86fdbc83daa5f8618a56b_MD5.png"></p><h3 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h3><ol><li>可以下载其他语言的驱动，导入数据<img src="/../../Assets/Pasted%20image%2020241030154631.png"></li><li>数据都是共享的，需要删除数据则：<ul><li>删除所有节点：<ul><li><code>MATCH (n)</code></li><li><code>DETACH DELETE n;</code></li></ul></li><li>删除所有关系：<ul><li><code>MATCH ()-[r]-()</code></li><li><code>DETACH DELETE r;</code></li></ul></li><li>删除所有属性：<ul><li><code>MATCH (n)</code></li><li><code>DETACH DELETE n;</code></li></ul></li><li>删除标签：得一个个删：<ul><li>查看索引：<code>:schema</code></li><li>删除对应的：&#96;DROP CONSTRAINT constraint_4a7831e6</li></ul></li></ul></li></ol><p>&#96;</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Neo4j</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Huggingface学习</title>
    <link href="/2024/10/23/Huggingface%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/10/23/Huggingface%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="1-浏览器网页下载"><a href="#1-浏览器网页下载" class="headerlink" title="1. 浏览器网页下载"></a>1. 浏览器网页下载</h3><p><img src="/Pasted%20image%2020241023160340.png"></p><h3 id="2-huggingface-cli-uh-transfer"><a href="#2-huggingface-cli-uh-transfer" class="headerlink" title="2. huggingface-cli+uh_transfer"></a>2. huggingface-cli+uh_transfer</h3><p><code>huggingface-cli</code> 和 <code>hf_transfer</code> 是 hugging face 官方提供的专门为下载而设计的工具链。前者是一个命令行工具，后者是下载加速模块</p><ul><li><code>huggingface-cli</code><ol><li>安装：<code>pip install -U huggingface_hub</code></li><li>用法<ul><li><code>huggingface-cli download --resume-download bigscience/bloom-560m --local-dir bloom-560m</code></li><li><code>huggingface-cli download --resume-download --repo-type dataset lavita/medical-qa-shared-task-v1-toy</code></li></ul></li><li>可以直接用模型名引用模型；<code>from_pretrain</code>的时候可以接受模型id，也可以接受存储路径；如果用<code>huggingface-cli</code>下载，尽管指定了路径，也可以用模型名字来引用 -&gt; 因为会在<code>.cache/huggingface</code>下维护模型的符号链接；可以用<code>--local-dir-use-symlinks=False</code>来不链接</li></ol></li><li><code>hf_transfer</code><ol><li>安装：<code>pip install -U hf-transfer</code></li><li>设置：<ul><li>linux: <code>export HF_HUB_ENABLE_HF_TRANSFER=1</code></li><li>windows: <code>$env:HF_HUB_ENABLE_HF_TRANSFER = 1</code></li></ul></li><li>和上面一样使用<code>huggingface-cli</code>：<code>huggingface-cli download --resume-download bigscience/bloom-560m --local-dir bloom-560m</code></li><li>没有进度条</li></ol></li></ul><h3 id="3-snapshot-download"><a href="#3-snapshot-download" class="headerlink" title="3. snapshot_download"></a>3. snapshot_download</h3><p>参数众多、比较完善</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> huggingface_hub <span class="hljs-keyword">import</span> snapshot_download<br><br>snapshot_download(<br>  repo_id=<span class="hljs-string">&quot;bigscience/bloom-560m&quot;</span>,<br>  local_dir=<span class="hljs-string">&quot;/data/user/test&quot;</span>,<br>  local_dir_use_symlinks=<span class="hljs-literal">False</span>,<br>  proxies=&#123;<span class="hljs-string">&quot;https&quot;</span>: <span class="hljs-string">&quot;http://localhost:7890&quot;</span>&#125;<br>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 需要登录的模型</span><br><span class="hljs-keyword">import</span> huggingface_hub<br>huggingface_hub.login(<span class="hljs-string">&quot;HF_TOKEN&quot;</span>) <span class="hljs-comment"># token 从 https://huggingface.co/settings/tokens 获取</span><br></code></pre></td></tr></table></figure><h3 id="4-from-pretrained"><a href="#4-from-pretrained" class="headerlink" title="4. from_pretrained"></a>4. from_pretrained</h3><p>常规方法</p><h3 id="5-hf-hub-download"><a href="#5-hf-hub-download" class="headerlink" title="5. hf_hub_download"></a>5. hf_hub_download</h3><p>常规方法</p><h3 id="6-登录下载"><a href="#6-登录下载" class="headerlink" title="6. 登录下载"></a>6. 登录下载</h3><p>Git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://hf_username:hf_token@huggingface.co/meta-llama/Llama-2-7b-chat-hf<br></code></pre></td></tr></table></figure><p>huggingface-cli</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">huggingface-cli download --token hf_*** --resume-download bigscience/bloom-560m --local-dir bloom-560m<br></code></pre></td></tr></table></figure><p>cur, wegt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -L --header <span class="hljs-string">&quot;Authorization: Bearer hf_***&quot;</span> -o model-00001-of-00002.safetensors https://huggingface.co/meta-llama/Llama-2-7b-chat-hf/resolve/main/model-00001-of-00002.safetensors<br><br>wget --header <span class="hljs-string">&quot;Authorization: Bearer hf_***&quot;</span> https://huggingface.co/meta-llama/Llama-2-7b-chat-hf/resolve/main/model-00001-of-00002.safetensors<br></code></pre></td></tr></table></figure><p>snapshot_download</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> huggingface_hub<br>huggingface_hub.login(<span class="hljs-string">&quot;hf_***&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="7-镜像下载"><a href="#7-镜像下载" class="headerlink" title="7. 镜像下载"></a>7. 镜像下载</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 注意在import huggingface_hub前</span><br><span class="hljs-keyword">import</span> os<br>os.environ[<span class="hljs-string">&#x27;HF_ENDPOINT&#x27;</span>] = <span class="hljs-string">&#x27;https://hf-mirror.com&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$env</span>:HF_ENDPOINT = <span class="hljs-string">&quot;https://hf-mirror.com&quot;</span><br><span class="hljs-built_in">export</span> HF_ENDPOINT=<span class="hljs-string">&quot;https://hf-mirror.com&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Huggingface</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode31_下一个排列</title>
    <link href="/2024/08/09/LeetCode31_%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <url>/2024/08/09/LeetCode31_%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<!---more--><h3 id="如何得到"><a href="#如何得到" class="headerlink" title="如何得到"></a>如何得到</h3><ol><li>希望下一个数比当前数大，将后面的【大数】和前面的【小数】交换得到更大的数，比如 <code>123456</code> ，将 <code>5</code> 和 <code>6</code> 交换能得到一个更大的数 <code>123465</code></li><li>希望下一个数增加的幅度尽可能小，这样才满足与当前排列紧邻<ul><li>在尽可能靠右的低位进行交换 -&gt; 需要从后往前查找</li><li>将一个尽可能小的【大数】与前面的【小数】交换</li><li>将【大数】换到前面后，要将【大数】后面的所有数重置为升序</li></ul></li><li>例子，比如 <code>123465</code> ，交换 <code>5</code> 和 <code>4</code> ，得到 <code>123564</code> ；然后将 <code>5</code> 之后的数重置为升序，得到 <code>123546</code></li></ol><h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><ol><li>从后向前查找第一个相邻升序元素对 <code>(i,j)</code> ，满足 <code>A[i] &lt; A[j]</code>，这时 <code>[j,end]</code>必然是降序</li><li>在 <code>[j,end]</code> 从后向前查找第一个满足 <code>A[i] &lt; A[k]</code>的 <code>k</code>，<code>A[i]</code>、<code>A[k]</code>分别是【小数】、【大数】</li><li>将 <code>A[i]</code> 与 <code>A[k]</code> 交换</li><li>这时 <code>[j,end]</code> 必然是降序，逆置 <code>[j,end]</code>，使其升序</li><li>如果在步骤1找不到符合的相邻元素对，说明当前 <code>[begin,end]</code> 为一个将序顺序，则直接跳到步骤4</li></ol>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode2071_你可以安排的最多任务数目</title>
    <link href="/2024/08/05/LeetCode2071_%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%AE%89%E6%8E%92%E7%9A%84%E6%9C%80%E5%A4%9A%E4%BB%BB%E5%8A%A1%E6%95%B0%E7%9B%AE/"/>
    <url>/2024/08/05/LeetCode2071_%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%AE%89%E6%8E%92%E7%9A%84%E6%9C%80%E5%A4%9A%E4%BB%BB%E5%8A%A1%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<!---more--><p>如果完成了$x$个任务，最佳方案是力量最大的$x$个worker完成了要求力量最小的$x$个任务<br>按力量从小到大依次考虑每个worker $W_J$，可以选择的任务是要求力量值不超过$W_J+strength$且尚未完成的任务之一</p><ol><li>如果当前可选任务中要求力量值最小的一个小于等于$W_j$，则这个worker不用吃药就可以完成任务</li><li>如果没有可以直接完成的，则有药情况下选要求力量值最大的任务比较划算，没药则直接失败</li><li>如果吃药也没能完成，则直接失败</li></ol><p>任务按照<strong>从小到大</strong>的顺序添加到可选任务范围中；移除时要么最小要么最大 –&gt; 双端单调队列</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
      <tag>贪心</tag>
      
      <tag>队列</tag>
      
      <tag>排序</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode402_移掉K位数字</title>
    <link href="/2024/08/04/LeetCode402_%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/"/>
    <url>/2024/08/04/LeetCode402_%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<!---more--><p>比如 $num&#x3D;1432219, k&#x3D;3$，需要返回一个长度为4的字符串，怎么才能求出这四个位置<br>前置知识：对于两个数 $123a456$ 和 $123b456$，如果 $a&gt;b$ ，那么数字 $123a456&gt;123b456$；也就是说两个相同位数的数字大小关系取决于第一个不同数的大小；所以需要前面的数尽量小<br>思路：保留$n-k$个元素，对于$D_i$，需要从左往右找到第一个位置$i$，使得$D_{i}&lt;D_{i-1}$，并删去$D_{i-1}$，需要删除不超过$k$次<br>![[&#x2F;Assets&#x2F;LeetCode402_移掉K位数字 2024-08-04 10.07.49.excalidraw|800]]</p><p>不把栈顶元素弹出的条件：</p><ul><li>栈为空</li><li>新的栈顶不大于当前数字</li><li>已经删除了$k$位数字</li></ul><p>额外的处理：</p><ul><li>已经删除了$m$个数字并且$m&lt;k$，则需要从序列尾部额外删除</li><li>最终数字序列存在前导零，要删去前导零</li><li>最终数字序列为空，应该返回$0$</li></ul>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>贪心</tag>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode面试题16.03_交点</title>
    <link href="/2024/06/11/LeetCode%E9%9D%A2%E8%AF%95%E9%A2%9816.03-%E4%BA%A4%E7%82%B9/"/>
    <url>/2024/06/11/LeetCode%E9%9D%A2%E8%AF%95%E9%A2%9816.03-%E4%BA%A4%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<!---more--><p>设一条线段的两个端点分别为$(x1,y1)$以及$(x2,y2)$，另一个线段的两个端点分别为$(x3,y3)$以及$(x4,y4)$<br>如果平面上两条直线不平行，则一定相交并且有唯一的交点</p><h2 id="不平行"><a href="#不平行" class="headerlink" title="不平行"></a>不平行</h2><h3 id="写出这两条线段所在的直线的参数方程"><a href="#写出这两条线段所在的直线的参数方程" class="headerlink" title="写出这两条线段所在的直线的参数方程"></a>写出这两条线段所在的直线的参数方程</h3><p>对于线段$(x1, y1) \sim (x2, y2)$，它的参数方程为：<br>$$\begin{cases} x &#x3D; x_1 + t_1(x_2 - x_1) \ y &#x3D; y_1 + t_1(y_2 - y_1) \end{cases} \quad t_1 \in [0, 1]$$<br>对于线段$(x3, y3) \sim (x4, y4)$，它的参数方程为：<br>$$\begin{cases} x &#x3D; x_3 + t_2(x_4 - x_3) \ y &#x3D; y_3 + t_2(y_4 - y_3) \end{cases} \quad t_2 \in [0, 1]$$</p><h3 id="联立这两个参数方程求出交点"><a href="#联立这两个参数方程求出交点" class="headerlink" title="联立这两个参数方程求出交点"></a>联立这两个参数方程求出交点</h3><p>我们先忽略$t1, t2 \in [0, 1]$的限制，求出它们的值之后再进行判断。联立得到的方程组为：<br>$$\begin{cases} x_1 + t_1(x_2 - x_1) &#x3D; x_3 + t_2(x_4 - x_3) \ y_1 + t_1(y_2 - y_1) &#x3D; y_3 + t_2(y_4 - y_3) \end{cases}$$<br>这是一个普通的二元一次方程组，我们可以得到解为：<br>$$\begin{cases} t_1 &#x3D; \frac{x_3(y_4-y_3)+y_1(x_4-x_3)-y_3(x_4-x_3)-x_1(y_4-y_3)}{(x_2-x_1)(y_4-y_3)-(x_4-x_3)(y_2-y_1)}\ t_2 &#x3D; \frac{x_1(y_2-y_1)+y_3(x_2-x_1)-y_1(x_2-x_1)-x_3(y_2-y_1)}{(x_4-x_3)(y_2-y_1)-(x_2-x_1)(y_4-y_3)} \end{cases}$$</p><h3 id="判断这个交点是否在线段上"><a href="#判断这个交点是否在线段上" class="headerlink" title="判断这个交点是否在线段上"></a>判断这个交点是否在线段上</h3><p>我们只要判断是否有$0 \leq t_1 \leq 1$ 以及 $0 \leq t_2 \leq 1$</p><h2 id="平行"><a href="#平行" class="headerlink" title="平行"></a>平行</h2><p>可以通过检查斜率来判断两条线段是否平行，即当：<br>$$\frac{y_4-y_3}{x_4-x_3} &#x3D; \frac{y_2-y_1}{x_2-x_1}$$<br>满足时，两条线段平行。但这里需要注意的是，可能出现斜率无穷大的情况（即线段与 $y$ 轴平行），此时$x_2 - x_1$以及$x_4 - x_3$的值为$0$，无法作为分母。因此我们需要将除法变为乘法，用：$(y_4-y_3)(x_2-x_1) &#x3D; (y_2-y_1)(x_4-x_3)$进行判断。</p><p>当我们知道了两条线段平行之后，会有两种情况：</p><ul><li>这两条线段不在同一条直线上，那么它们不会有交点；</li><li>这两条线段在同一条直线上，此时如果它们有交点，最优的交点一定是 $(x_1, y_1)$、$(x_2, y_2)$、$(x_3, y_3)$以及$(x_4, y_4)$中的一个。这是因为假设这两条线段有交点 $(x_i, y_i)$，那么我们一定可以不断地将这个交点往更优的方向移动，直到到达某一条线段的端点，这个端点即为上述四个端点中的一个。<br>那么我们如何判断这两条线段是否在同一条直线上呢？由于它们平行，因此我们只需要判断 $(x_3, y_3)$是否在$(x_1, y_1) \sim (x_2, y_2)$所在的直线上。即存在$t \in \mathbb{R}$使得：<br>$$\begin{cases} x_3 &#x3D; x_1 + t(x_2 - x_1)\ y_3 &#x3D; y_1 + t(y_2 - y_1) \end{cases}$$<br>联立这两个等式即可得到</li></ul><p>$$\begin{aligned} &amp; t &#x3D; \frac{x_3 - x_1}{x_2 - x_1} &#x3D; \frac{y_3 - y_1}{y_2 - y_1}\ \Rightarrow &amp; \frac{y_2 - y_1}{x_2 - x_1} &#x3D; \frac{y_3 - y_1}{x_3 - x_1} \end{aligned}$$<br>它的几何意义为：$(x_1, y_1) \sim (x_2, y_2)$的斜率等于$(x_1, y_1) \sim (x_3, y_3)$的斜率，这也是比较直观的。同样地，我们需要将除法变为乘法进行判断: $(y_2 - y_1)(x_3 - x_1) &#x3D; (y_3 - y_1)(x_2 - x_1)$<br>最后一步我们只需要判断：$(x_1, y_1)$是否在线段$(x_3, y_3) \sim (x_4, y_4)$上；$(x_2, y_2)$是否在线段$(x_3, y_3) \sim (x_4, y_4)$上；$(x_3, y_3)$是否在线段$(x_1, y_1) \sim (x_2, y_2)$上；$(x_4, y_4)$是否在线段$(x_1, y_1) \sim (x_2, y_2)$上。<br>并在满足条件的端点中选择一个最优的。我们以判断$(x_3, y_3)$是否在线段 $(x_1, y_1) \sim (x_2, y_2)$上为例，根据上文的推导，需要满足：<br>$$0 \leq \frac{x_3 - x_1}{x_2 - x_1} &#x3D; \frac{y_3 - y_1}{y_2 - y_1} \leq 1$$<br>这里有一些边界情况，我们一种一种来考虑：</p><ul><li>如果线段$(x_1, y_1) \sim (x_2, y_2)$与 $x$ 轴平行，即 $y_1 &#x3D; y_2$ ，那么只需要判断是否有：<br>$$0 \leq \frac{x_3 - x_1}{x_2 - x_1} \leq 1$$<br>它等价于 $\min(x_1, x_2) \leq x_3 \leq \max(x_1, x_2)$。它的几何意义也是很显然的，因为线段与 $x$ 轴平行，所以只要 $x_3$，在$x_1$与 $x_2$之间就行了；</li><li>如果线段 $(x_1, y_1) \sim (x_2, y_2)$与 $y$ 轴平行，即 $x_1 &#x3D; x_2$，那么只需要判断是否有：<br>$$0 \leq \frac{y_3 - y_1}{y_2 - y_1} \leq 1$$它等价于$\min(y_1, y_2) \leq y_3 \leq \max(y_1, y_2)$如果是其余的情况，那么需要判断 $\min(x_1, x_2) \leq x_3 \leq \max(x_1, x_2)$和 $\min(y_1, y_2) \leq y_3 \leq \max(y_1, y_2)$这两者。</li></ul>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>几何</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode面试题10.03_搜索旋转数组</title>
    <link href="/2024/06/11/LeetCode%E9%9D%A2%E8%AF%95%E9%A2%9810.03-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
    <url>/2024/06/11/LeetCode%E9%9D%A2%E8%AF%95%E9%A2%9810.03-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<!---more--><p>根据题解总结旋转数组相关题目，都是二分法</p><h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><p><a href="https://leetcode.cn/problems/rotate-array/description/">https://leetcode.cn/problems/rotate-array/description/</a><br><img src="/Assets/bfdd7661cec500124940d4a7f4a3f470_MD5.png"></p><ol><li>向右移动的位置k可能会大于n，因此对m取余</li><li>先将整个数组反转，再将前k个反转，再将后n-k个反转</li></ol><h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/">https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/</a><br><img src="/Assets/Pasted%20image%2020240611122805.png"></p><ol><li>nums中所有整数都是唯一的</li><li>nums原来是一个升序排列的数组，但在预先未知的某个点上进行了旋转</li><li>二分法<br> 1. <code>nums[mid] &gt; nums[right]</code>，如<code>[3,4,5,1,2]</code>，则左侧是有序上升的，最小值在右侧<br> 2. <code>nums[mid] &lt;= nums[right]</code>，如<code>[6,7,1,2,3,4,5]</code>，则右侧是有序上升的，最小值在左侧</li></ol><h3 id="三"><a href="#三" class="headerlink" title="三"></a>三</h3><p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/description/">https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/description/</a><br><img src="/Assets/7c50bbfcc4beb080ec683d84668cba15_MD5.png"></p><ol><li>和<strong>二</strong>相比，就是数组中有重复值</li><li>二分法<ol><li><code>nums[mid] &gt; nums[right]</code>，如<code>[3,4,5,1,2]</code>，则左侧是有序上升的，最小值在右侧</li><li><code>nums[mid] &lt; nums[right]</code>，如<code>[6,7,1,2,3,4,5]</code>，则右侧是有序上升的，最小值在左侧</li><li><code>nums[mid] == nums[right]</code>，如<code>[2,3,1,1,1]</code>，重复数字可能是最小值，也可能最小值在左侧，所以<code>right</code>左移</li></ol></li></ol><h3 id="四"><a href="#四" class="headerlink" title="四"></a>四</h3><p><a href="https://xleetcode.cn/problems/search-in-rotated-sorted-array/description/">https://xleetcode.cn/problems/search-in-rotated-sorted-array/description/</a><br><img src="/Assets/6a134bc5dde1706d848d250595ea22c8_MD5.png"></p><p>分为左半部分有序和右半部分有序；最终找到目标值</p><h3 id="五"><a href="#五" class="headerlink" title="五"></a>五</h3><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/description/">https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/description/</a><br><img src="/Assets/3f6e241138464c4de1b18008d41336d2_MD5.png"></p><ol><li>和<strong>四</strong>相比是添加了重复值</li><li>重点在于处理重复数字<ol><li>左边有重复，将左边界右移</li><li>右边有重复，将右边界左移</li><li>然后按照左半部分和右半部分有序来分</li></ol></li></ol><h3 id="六"><a href="#六" class="headerlink" title="六"></a>六</h3><p><a href="https://leetcode.cn/problems/search-rotate-array-lcci/description/">https://leetcode.cn/problems/search-rotate-array-lcci/description/</a><br><img src="/Assets/a61ebb119ac75dd5a4a0c8424d1952b0_MD5.png"></p><ol><li>和<strong>五</strong>很像，区别是<strong>五</strong>是只要存在target就返回true，而这道题要返回多个重复target中最靠前的那个</li><li>边界条件很多<ol><li>当<code>left</code>符合条件时直接返回，因为找的是最小的索引</li><li>当中间值等于目标值，将右边界移到中间，因为左边可能还有相等的值</li><li>当中间数字与左边数字相等时，将左边界右移</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode面试题08.14_布尔运算</title>
    <link href="/2024/06/09/LeetCode%E9%9D%A2%E8%AF%95%E9%A2%9808.14-%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97/"/>
    <url>/2024/06/09/LeetCode%E9%9D%A2%E8%AF%95%E9%A2%9808.14-%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p><strong>状态定义</strong>：<code>dp[i][j][result=0/1]</code>表示第<code>i</code>到<code>j</code>个数字计算结果为<code>result</code>的方案数<br><strong>状态转移</strong>：枚举区间分割点，根据分割点情况讨论左右区间计算结果，方案数增量为左右方案<br>数相乘</p><ul><li>分割点为<code>&amp;</code><ul><li>结果为<code>0</code>有三种情况：<ul><li>0 0, 0 1, 1 0</li><li><code>dp[i][j][0] += dp[i][k - 1][0] * dp[k + 1][j][0] + dp[i][k - 1][0] * dp[k + 1][j][1] + dp[i][k - 1][1] * dp[k + 1][j][0]</code></li></ul></li><li>结果为<code>1</code>有一种情况：<ul><li>1 1</li><li><code>dp[i][j][1] += dp[i][k - 1][1] * dp[k + 1][j][1]</code></li></ul></li></ul></li><li>分割点为<code>|</code>:<ul><li>结果为<code>0</code>有一种情况：<ul><li>0 0</li><li><code>dp[i][j][0] += dp[i][k - 1][0] * dp[k + 1][j][0]</code></li></ul></li><li>结果为<code>1</code>有三种情况：<ul><li>0 1, 1 0, 1 1</li><li><code>dp[i][j][1] += dp[i][k - 1][0] * dp[k + 1][j][1] + dp[i][k - 1][1] * dp[k + 1][j][0] + dp[i][k - 1][1] * dp[k + 1][j][1]</code></li></ul></li></ul></li><li>分割点为<code>^</code>:<ul><li>结果为<code>0</code>有两种情况：<ul><li>0 0, 1 1</li><li><code>dp[i][j][0] += dp[i][k - 1][0] * dp[k + 1][j][0] + dp[i][k - 1][1] * dp[k + 1][j][1]</code></li></ul></li><li>结果为<code>1</code>有两种情况： <ul><li>0 1, 1 0</li><li><code>dp[i][j][1] += dp[i][k - 1][1] * dp[k + 1][j][0] + dp[i][k - 1][0] * dp[k + 1][j][1]</code></li></ul></li></ul></li></ul><p><strong>初始条件</strong>：数字位初始化为1，即<code>dp[i][i]][0/1]=1</code></p><p><strong>具体代码</strong>：</p><ul><li>三个循环：<ul><li>枚举区间长度：跳步为2，一个数字一个符号</li><li>枚举区间起点：数字位，跳步为2</li><li>枚举分割点：三种&amp; | ^，跳步为2</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode面试题05.08_绘制直线</title>
    <link href="/2024/06/02/LeetCode%E9%9D%A2%E8%AF%95%E9%A2%9805.08-%E7%BB%98%E5%88%B6%E7%9B%B4%E7%BA%BF/"/>
    <url>/2024/06/02/LeetCode%E9%9D%A2%E8%AF%95%E9%A2%9805.08-%E7%BB%98%E5%88%B6%E7%9B%B4%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<!---more--><p>这道题首先需要理解题目</p><p>以<code>length = 3, w = 96, x1 = 0, x2 = 95, y = 0</code>为例子<br><img src="/Assets/Pasted%20image%2020240602160517.png"></p><p>以<code>length = 9, w = 96, x1 = 61, x2 = 63, y = 2</code>为例子<br><img src="/Assets/7d1b2a6dee5f1ebee79720918dd44c01_MD5.png"></p><ul><li>由于是32位的int，从<code>x1/32</code>个整数开始，到<code>x2/32</code>个整数结束</li><li>每一行的开始和结束坐标是<code>(i+1)*32-1</code>和<code>i+32</code>，看看是不是超出了起始和结束坐标的范围，然后新的坐标对32取余</li><li>由于题目保证1不会分布到两行中，所以可以先得到1的起始和终止位置在第几位之后，进行左移</li></ul>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>数学</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/2024/06/02/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2024/06/02/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<!---more--><ul><li>判断奇偶：<ul><li>奇：<code>(x &amp; 1) == 1</code>  ⟺  <code>(x &amp; 1) != 0</code></li><li>偶：<code>(x &amp; 1) == 0</code>  ⟺ <code>(x &amp; 1) != 1</code></li></ul></li><li>乘（或除）以 2 的幂次：<ul><li><code>x &gt;&gt; n </code> ⟺<code> x / 2^n</code></li><li><code>x &lt;&lt; n</code>  ⟺  <code>x * 2^n</code></li></ul></li><li>去除最后一位 1：<code>x &amp; (x - 1)</code></li><li>得到最后一位 1：<code>x &amp; -x</code></li><li>判断 2 的幂次：<code>x &amp; (x - 1) == 0</code></li><li>交换两个数：<code>a ^= b; b ^= a; a ^= b;</code></li><li>交换符号：<code>~x + 1</code>  ⟺ <code> -x</code></li><li>取绝对值：<code>(x ^ x &gt;&gt; size(x) - 1) - (x &gt;&gt; size(x) - 1)</code>  ⟺  <code>x &lt; 0 ? -x : x</code></li><li>构造 n 个 1：<code>(1 &lt;&lt; n) - 1</code></li><li>将最左边的 n 位清零：<code>x &amp; (~0 &lt;&lt; n)</code></li><li>获取 x 的第 n 位值（0 或 1）：<code>(x &gt;&gt; n) &amp; 1</code></li><li>获取 x 的第 n 位的幂值：<code>x &amp; (1 &lt;&lt; n)</code></li><li>仅将第 n 位置为 1：<code>x | (1 &lt;&lt; n)</code></li><li>仅将第 n 位置为 0：<code>x &amp; (~(1 &lt;&lt; n))</code></li><li>将 x 最高位至第 n 位（含）清零：<code>x &amp; ((1 &lt;&lt; n) - 1)</code></li><li>将第 n 位至第 0 位（含）清零：<code>x &amp; (~((1 &lt;&lt; (n + 1)) - 1))</code></li><li>取反第 n 位：<code>x ^ (1 &lt;&lt; n)</code></li><li>异或满足交换律、结合律：<code>a ^ b ^ a = b ^ (a ^ a) = b ^ 0 = b</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>其他补充</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode面试题04.09_二叉搜索树序列</title>
    <link href="/2024/06/02/LeetCode%E9%9D%A2%E8%AF%95%E9%A2%9804.09-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%BA%8F%E5%88%97/"/>
    <url>/2024/06/02/LeetCode%E9%9D%A2%E8%AF%95%E9%A2%9804.09-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<!---more--><p>就是给定一棵二叉搜索树，给出从左到右遍历 能够生成这棵树的数组；说实话题目意思还是没咋看懂，但是知道怎么解题了<br><img src="/Assets/Pasted%20image%2020240602152105.png"><br>[[&#x2F;Assets&#x2F;LeetCode面试题04.09-二叉搜索树序列 2024-06-02 15.12.46.excalidraw]]<br> 题意即解法大概如上，代码方面是bfs + 回溯</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>树</tag>
      
      <tag>回溯</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode面试题03.05_栈排序</title>
    <link href="/2024/06/02/LeetCode%E9%9D%A2%E8%AF%95%E9%A2%9803.05-%E6%A0%88%E6%8E%92%E5%BA%8F/"/>
    <url>/2024/06/02/LeetCode%E9%9D%A2%E8%AF%95%E9%A2%9803.05-%E6%A0%88%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<!---more--><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>对于每次插入的新元素都用辅助栈保证是适合s1的</p><ol><li>比如s1 &#x3D; {1,5,6,8,9}，插入7</li><li>先把{8,9}插入s2，s2 &#x3D; {8,9}</li><li>再把7插入s1，s1 &#x3D; {1,5,6,7}</li><li>再把s2插入s1，s1 &#x3D; {1,5,6,7,8,9}</li></ol><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>维护两个栈，原栈为降序，辅助栈为升序</p><ol><li><p>s1 &#x3D; {8,7,3} s2 &#x3D; {}</p></li><li><p>插入5，因为比s1.top大，把3插入s2中，5插入s1中</p></li><li><p>s1 &#x3D; {8,7,5} s2 &#x3D; {3}</p></li><li><p>对于当前$val$，把s2中比$val$大的放到s1中，把s1中比$val$小的放到s2中<br><img src="/Assets/3023183ccbebac395d82f52304bcc667_MD5.png"><br>[[&#x2F;Assets&#x2F;LeetCode面试题03.05-栈排序 2024-06-02 14.08.24.excalidraw]]</p></li><li><p>因为所有的元素都是从s1中pop然后push到s2中的，所以s2是降序的</p></li><li><p>这样就没必要在push的时候把s2中元素重新加入到s1中去，只是在pop的时候需要清空s2</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>单调栈</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode面试题02.07_链表相交</title>
    <link href="/2024/06/02/LeetCode%E9%9D%A2%E8%AF%95%E9%A2%9802.07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/"/>
    <url>/2024/06/02/LeetCode%E9%9D%A2%E8%AF%95%E9%A2%9802.07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/</url>
    
    <content type="html"><![CDATA[<!---more--><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><ol><li>遍历链表$headA$ ，并将链表$headA$ 中的每个节点加入哈希集合中</li><li>遍历链表$headB$，对于遍历到的每个节点，判断该节点是否在哈希集合中<ul><li>如果不在，则继续遍历</li><li>如果在，则后面的节点都在，返回该节点</li></ul></li><li>如果所有都不在，则两个链表不相交，返回$null$</li></ol><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>用双指针的方式<br><img src="/Assets/a3abd1ff3893ccc7aacee817a9e3f1a4_MD5.png"><br>[[&#x2F;Assets&#x2F;LeetCode面试题02.07-链表相交 2024-06-02 13.24.47.excalidraw]]</p><ol><li>指针<code>A</code>先遍历链表<code>headA</code>，再遍历链表<code>headB</code>，走到<code>node</code>时共走步数为$a+(b-c)$</li><li>指针<code>B</code>先遍历链表<code>headB</code>，再遍历链表<code>headA</code>，走到<code>node</code>时共走步数为$b+(a-c)$</li><li>那么此时指针<code>A</code>，<code>B</code>重合，如果两个链表有公共尾部，即<code>c&gt;0</code>，则<code>A</code>，<code>B</code>同时指向第一个公共节点<code>node</code>；如果没有公共节点，即<code>c=0</code>，则<code>A</code>，<code>B</code>同时指向$null$</li><li>写代码的话，就是每步都是指针<code>A</code>，<code>B</code>都向前走一步；哪个指针走到$null$了就换到另一个链条的头节点；如果相等则返回$A$</li></ol>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>链表</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode学习</title>
    <link href="/2024/04/19/VSCode%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/04/19/VSCode%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<!---more--><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>⌘K ⌘F 代码整齐<br>⌘- ⌘+ 字体大小</p><h3 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h3><h4 id="venv"><a href="#venv" class="headerlink" title="venv"></a>venv</h4><p>更改了虚拟环境的路径</p><ol><li>找到<code>activate</code>文件夹</li><li>搜索<code>VIRTUAL_ENV</code>，然后更改到对应的</li></ol><h4 id="conda"><a href="#conda" class="headerlink" title="conda"></a>conda</h4><ol><li>如果在<code>linux</code>中不是<code>root</code>，则在<code>python</code>中有很多库不能安装，需要用<code>conda</code></li><li>安装包：<code>wget https://repo.anaconda.com/archive/Anaconda3-2023.07-Linux-x86_64.sh</code></li><li>安装：<code>bash Anaconda3-2023.07-Linux-x86_64.sh</code></li><li>配置环境变量：<code>source ~/.bashrc</code></li><li><code>export PATH=&quot;$HOME/anaconda3/bin:$PATH&quot;</code></li><li>保存之后运行：<code>source ~/.bashrc</code></li><li>验证安装：<code>conda --version</code></li><li>创建虚拟环境：<code>conda create -n myenv python=3.8</code></li><li>激活环境：<code>conda activate myenv</code></li><li>列出环境：<code>conda env list</code></li><li>删除环境：<code>conda remove -n myenv --all</code><br>&#96;</li></ol>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WPS学习</title>
    <link href="/2024/04/19/WPS%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/04/19/WPS%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<!---more--><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>⇧⌘&#x3D; 上标<br>⌘&#x3D; 下标<br>⌘Y 恢复上一步操作<br>⌘鼠标左键 选择不同位置文字<br>⌘⏎ 分页符</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac学习</title>
    <link href="/2024/04/19/Mac%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/04/19/Mac%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ol><li><p>⌃⌘␣ 特殊符号</p></li><li><p>⌘␣ 搜索</p></li><li><p>⌘⌥ese 程序运行</p></li><li><p>⌘⇧. 隐藏的文件夹</p></li><li><p>找到host finder-前往文件夹-&#x2F;etc. &#x2F;⇧⌘G</p></li><li><p>删掉应用程序 终端输入Killall 进程名称</p></li><li><p>显示隐藏的文件夹 终端输入<code>defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder</code></p></li><li><p>虚拟机关机-设置-处理机和内存-硬盘大小</p></li><li><p>装WTG：用固态硬盘</p></li><li><p>管理员：<code>sudo su</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">shift+command+G <span class="hljs-comment">//访达访问页面</span><br>开启Tomcat:<br>sudo chmod <span class="hljs-number">755</span> *.sh <span class="hljs-comment">//开放权限</span><br>sudo sh ./startup.sh <span class="hljs-comment">//开启</span><br>sh ./shutdown.sh <span class="hljs-comment">//关闭</span><br>sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder <span class="hljs-comment">//清除缓存</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Obsidian学习</title>
    <link href="/2024/04/18/Obsidian%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/04/18/Obsidian%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>先开一个坑，陆陆续续搞Obsidian的主题插件，后面有机会再总结一下</p><span id="more"></span><h3 id="后续待做"><a href="#后续待做" class="headerlink" title="后续待做"></a>后续待做</h3><ul><li><input disabled="" type="checkbox"> 感觉其实Notion的财务模板感觉可以迁移过来？主要Notion打开速度太慢了，感觉可以DB Folder，button，Kanban一起联动来完成notion的功能</li><li><input disabled="" type="checkbox"> 代码字体还不是很好看，而且还不能折叠，以后再调成比较方便的形式吧；而且没有不同颜色高亮，不同颜色字体之类的，不过这个不是很紧急，而且也不影响之后的使用</li></ul><h3 id="和Zotero联动"><a href="#和Zotero联动" class="headerlink" title="和Zotero联动"></a>和Zotero联动</h3><p>采用的是<strong>ZotLit</strong>插件，官网介绍得还挺清晰的，<a href="https://zotlit.aidenlx.top/zh-CN">链接</a>，下面是我自己的配置，生成结果如下，主要是能够做一个整合，可以配合<strong>dataview</strong>插件，以及zotero所有的注释也可以进行展示，也可以链接到Zotero中<br>下面是我的Obsidian配置呈现页，tags和collections可以便于管理总结：<br><img src="/Assets/Pasted%20image%2020240418163731.png"></p><p><img src="/Assets/Pasted%20image%2020240418165849.png" alt="|290"></p><p>下面是Zotero注释页面，如果更新可以update到Obsidian中<br><img src="/Assets/Pasted%20image%2020240418164528.png"></p><h3 id="主题和字体配置"><a href="#主题和字体配置" class="headerlink" title="主题和字体配置"></a>主题和字体配置</h3><p>感觉<strong>Blue Topaz主题</strong>很不错，比较多人用，有问题可以问，而且比较多样化。字体用的是’<strong>霞鹜文楷 GB 屏幕阅读版</strong>‘，中英文都很不错，但是代码的话暂时没有特别喜欢的，用文楷又感觉应该要区别一下。需要先下载，解决了之前的中文粗体问题（不知道为啥，有些中文加不了粗）<br><strong>Style Setting</strong>这个插件可以配合Blue Topaz主题一起使用，我用这个改了段落之间的距离（因为感觉宽一点比较好，从别的笔记迁移过来的话），还有设置了选中文本时候颜色之类的<br><strong>Iconize</strong>这个插件主要是提供了图标，因为Notion是能够给文档加上图标的，可能比较美观吧<br><strong>Linter</strong>这个插件也是为了页面更加美观，比如去除空行之类的，暂时也没怎么用到</p><h3 id="Callout设置"><a href="#Callout设置" class="headerlink" title="Callout设置"></a>Callout设置</h3><p>感觉callout就很好看，用的是<strong>admonition</strong>这个插件，主要是用它来做分栏，而且可以折叠感觉不错。下面由于用的是<strong>Blue Topaz主题</strong>，所以如果cssclasses显示是kanban，则可以用无序列表展示出看板的效果（比单纯的看板插件可用性感觉高一点，因为看板插件展示的md文件不能渲染其他东西）<br>下面的页面还采用了插件<strong>HomePage</strong>，就是开机即到达该页面，算是一个主页的作用，便于导航<br><img src="/Assets/Pasted%20image%2020240418170337.png"></p><h3 id="表格数据展示"><a href="#表格数据展示" class="headerlink" title="表格数据展示"></a>表格数据展示</h3><p>notion和飞书的多维表格做的是真的很好，这个obsidian调试估计要调很久还没有效果，普通的表格的话就用了<strong>advanced table</strong>比较方便调节。常用的还是<strong>dataview</strong>进行一个统计的操作，以及<strong>DB Folder</strong>看上去可以比较容易实现联动，可以仿照一下notion，这个后续再研究</p><h3 id="画图工具"><a href="#画图工具" class="headerlink" title="画图工具"></a>画图工具</h3><p>之前还觉得在Obsidian画图的那个<strong>ExcaliDraw</strong>画风太可爱了不适合，但是确实还挺不错的，而且才用到初级的，后面还有很多可以一起加上去<br>以及还有自带的<strong>canva画布</strong>，这个没咋用，但是可以链接文档啥的，Obsidian的双链功能，思维图谱功能都挺出名的，但是目前还没有使用到</p><h3 id="大纲查看"><a href="#大纲查看" class="headerlink" title="大纲查看"></a>大纲查看</h3><p>其实有官方的大纲，但是总是要点一下，所以用了<strong>floating toc</strong>插件，效果如下，右边即是插件的功能，可以一直悬浮看很方便</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ad-flex">title: 左右对比<br>![](/Assets/Pasted%20image%2020240418172204.png)<br>![](/Assets/Pasted%20image%2020240418172212.png)<br></code></pre></td></tr></table></figure><h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><p>官方也有提供单个页面查找和全局查找，但是都不能替换，所以下载了<strong>Regex Find&#x2F;Replace</strong>这个插件，就可以正则表达式替换，其实后面应该不会太用到，主要是前期在搞图片路径<br><img src="/Assets/Pasted%20image%2020240418172555.png"></p><h3 id="菜单展示"><a href="#菜单展示" class="headerlink" title="菜单展示"></a>菜单展示</h3><p>Obsidian是一个纯文本编辑，而且还没有菜单，我有时候就记不住快捷键，而且打字还挺麻烦的，一开始用了<strong>editing-tool-bar</strong>，但是总是不能显示，得呼唤一下才能显示，现在用的<strong>cMenu</strong>，可以自定义操作上去，感觉还挺方便。这个是和增强编辑操作一起做的，增强编辑主要起一个快捷作用<br><img src="/Assets/Pasted%20image%2020240418173217.png"></p><h3 id="日记功能"><a href="#日记功能" class="headerlink" title="日记功能"></a>日记功能</h3><p>让我投奔Obsidian的一大原因就是居然整合了日记功能，感觉日记这个东西放在云端不太方便，本地比较好，但是有想手机和电脑端都可以记录，而Obsidian居然有<strong>日记核心插件</strong>，简直了！！可以和很多其他的联动，比如<strong>thino</strong>，这个我也下载了，但是感觉对我没啥用</p><h3 id="和Hexo联动"><a href="#和Hexo联动" class="headerlink" title="和Hexo联动"></a>和Hexo联动</h3><ol><li><p>用<strong>template</strong>插件，建立如下模板：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">---<br>title: &lt;% tp.file.title %&gt;<br><span class="hljs-built_in">date</span>: &lt;% tp.file.creation_date(<span class="hljs-string">&quot;YYYY-MM-DD HH:mm:ss&quot;</span>) %&gt;<br>updated: <br>tags: <br>categories: <br><br>---<br></code></pre></td></tr></table></figure></li><li><p>采用<strong>quickAdd</strong>插件，用命令即可插入一个新的文件到我写Blog的文件夹中<br><img src="/Assets/Pasted%20image%2020240418162125.png"></p></li></ol><p><img src="/Assets/Pasted%20image%2020240418161940.png"></p><h3 id="网页展示"><a href="#网页展示" class="headerlink" title="网页展示"></a>网页展示</h3><p>采用的是<strong>Auto Card Link</strong>，就是可以变成卡片形式的，之前还尝试过另外一个，但是不太好用，但是有时候连不了网的时候也fetch不到，就是下面代码形式，可以改图标啥的<br><img src="/Assets/Pasted%20image%2020240418174411.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">url: https://feishu.cn<br>title: <span class="hljs-string">&quot;飞书——先进企业协作与管理平台，一站式无缝办公协作，团队上下对齐目标，全面激活组织和个人。先进团队，先用飞书。&quot;</span><br>description: <span class="hljs-string">&quot;飞书——先进企业协作与管理平台，不仅一站式整合及时沟通、智能日历、音视频会议、飞书文档、云盘等办公协作套件，更提供飞书OKR、飞书招聘、飞书绩效等组织管理产品，让目标更清晰，信息流动更顺畅，每一个人工作更高效更愉悦。先进团队，先用飞书。&quot;</span><br>host: feishu.cn<br></code></pre></td></tr></table></figure><h3 id="网页嵌入"><a href="#网页嵌入" class="headerlink" title="网页嵌入"></a>网页嵌入</h3><p>因为还是对notion有需求，任务之类的还没有迁移过来，所以想着怎么委婉地all in one，就用了<strong>Custom Frames</strong>插件可以全屏嵌入网页而且还可以固定图标<br><img src="/Assets/Pasted%20image%2020240418175501.png"></p><h3 id="附件操作"><a href="#附件操作" class="headerlink" title="附件操作"></a>附件操作</h3><p>最开始需要插入图片到特定路径的时候，需要用到比如<code>$filename, $data</code>之类的变量，用到了<strong>custom Attachment location</strong>插件（它会影响Obsidian全局附件位置），<strong>Local Image Plus</strong>则是有快捷键可以把比如网页上的图片全都存储到本地中<br><strong>Clear Unused Images</strong>则是会清除所有没被用到的图片</p><h3 id="笔记迁移"><a href="#笔记迁移" class="headerlink" title="笔记迁移"></a>笔记迁移</h3><p>因为我是需要把Notion和语雀的笔记迁移过来的，所以下载了<strong>importer</strong>这个插件，网上搜一搜教程即可</p><h3 id="图片展示"><a href="#图片展示" class="headerlink" title="图片展示"></a>图片展示</h3><p>有时候图片太大了，所以下载了<strong>Mousewheel Image zoom</strong>这个插件，但是只能在Obsidian中缩放（用Alt+鼠标滚轮即可），其他还是正常的</p><h3 id="最近文件"><a href="#最近文件" class="headerlink" title="最近文件"></a>最近文件</h3><p><strong>Recent Files</strong>能找到最近文件，后续看看能不能迁移到主页上，用来快速定位到上一次打开or学习的地方，但突然感觉其实有挺多能替代的，按下Ctrl+O即可</p><h3 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h3><p>其实官方有查看标签的地方，但是感觉功能有点少，<strong>Tags Overview</strong>就是plus版吧，但是有点花里胡哨，后面看看有没有能再改进</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ad-flex">![](/Assets/Pasted%20image%2020240418203327.png)<br><br>![|291](/Assets/Pasted%20image%2020240418203429.png)<br></code></pre></td></tr></table></figure><h3 id="标题数字"><a href="#标题数字" class="headerlink" title="标题数字"></a>标题数字</h3><p><strong>Number Headings</strong>就是给标题自动加上前缀，比如1，2，3之类的，主要是在建立知识库的时候比较清晰一点</p><h3 id="多端同步"><a href="#多端同步" class="headerlink" title="多端同步"></a>多端同步</h3><p>用的是<strong>Remotely Save</strong>，还是不错的，平台是Onedrive，1GB暂时够用</p><h3 id="标签页管理"><a href="#标签页管理" class="headerlink" title="标签页管理"></a>标签页管理</h3><p>因为每次打开文件都覆盖掉当前的了，所以用了<strong>Open In New Tab</strong>在新的标签页打开文件</p><h3 id="记账管理"><a href="#记账管理" class="headerlink" title="记账管理"></a>记账管理</h3><p>我用的<strong>ledger</strong>，操作基本上懂了，但是还是不太好用，完不成notion的功能，所以还是用Notion吧</p><h3 id="知道功能但没怎么用的"><a href="#知道功能但没怎么用的" class="headerlink" title="知道功能但没怎么用的"></a>知道功能但没怎么用的</h3><p><strong>Button</strong>就是一个按钮，感觉可以仿照<strong>notion</strong>的按钮功能来进行操作，但是还没怎么研究<br><strong>Code Style</strong>感觉和我的主题冲突了还是怎么样，本来想用它来折叠代码的，结果没出现折叠的东西<br><strong>Kanban</strong>的话也是和<strong>notion</strong>很像，但是它不能嵌入到其他页面，所以就不好观看，也许后续能够用到</p><h3 id="笔记软件对比"><a href="#笔记软件对比" class="headerlink" title="笔记软件对比"></a>笔记软件对比</h3><p>先后迁移过好几个笔记软件了，总结一下下</p><h4 id="Notion"><a href="#Notion" class="headerlink" title="Notion"></a>Notion</h4><p>可以多端，比较好的是数据库，按钮操作。而且有很多模板库可以选择，比如旅行模板，任务模板之类的；刚上手的时候还不错，感觉挺新奇的；而且换到iphone之后其实notion手机端挺好用的<br>但是比较慢，而且感觉排版啥的有时候太空了？？而且没有大纲</p><h4 id="语雀"><a href="#语雀" class="headerlink" title="语雀"></a>语雀</h4><p>当时想有一个在线上的，感觉自己搭建的github+hexo太慢了，有时候又想看到自己的笔记（事实是记了就没看过hhh，以后会用到了）<br>所以把hexo的所有笔记都迁移到语雀上了，而且当时用它的小记功能，能记一些琐碎的东西</p><h4 id="Obsidian"><a href="#Obsidian" class="headerlink" title="Obsidian"></a>Obsidian</h4><p>最近在研究，主要是插件市场很强大，而且是本地的，需要多端也是可以同步的，我主力是在电脑，手机ipad啥的就是查看一下，所以还挺不错，移动端没咋研究。<br>个性化好处就是需要满足啥功能可以自己去搜，坏处就是很多东西需要自己实现。现在主力把Blog，日记，学习笔记之类的放到这边，记账我觉得也是可以的，但是应该需要另外花费时间</p><h4 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h4><p>这个软件之前比较喜欢用，但是后来收费了，而且其实主打markdown，用别的编辑器也是一样的，vscode和Obsidian感觉功能更多。当然，平时随便写一些文件还是可以的</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递归问题</title>
    <link href="/2024/04/18/%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98/"/>
    <url>/2024/04/18/%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>递归</p><ol><li>确定递归函数的参数和返回值</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>搜索算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心问题</title>
    <link href="/2024/04/18/%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98/"/>
    <url>/2024/04/18/%E8%B4%AA%E5%BF%83%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>贪心算法一般分为如下四步：</p><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解<br>但是一般找到局部最优解，推出全局最优解即可</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>贪心</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode2542_最大子序列的分数</title>
    <link href="/2024/03/08/LeetCode2542-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%88%86%E6%95%B0/"/>
    <url>/2024/03/08/LeetCode2542-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%88%86%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>LeetCode2542_最大子序列的分数</p><span id="more"></span><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>先按照<code>nums</code>进行降序排列，优先用最大的数字</li><li>优先队列去维持<code>nums1</code>的总和，尽可能取最大的</li><li>则可以保证每次取到的是当前的最大值，然后基于滑动窗口去维持<code>k</code>大小</li></ol><p><img src="/Assets/1708947814891-a6051ae0-09fe-4be1-bb58-2d074874a28c.jpeg" alt="img"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ol><li>可以用一个<code>vector&lt;pair&lt;int, int&gt;&gt; nums</code>来存储<code>num1, num2</code>下标组</li><li>根据<code>num2</code>来对<code>nums</code>进行排序</li><li>然后遍历<code>nums</code>，以及有一个优先队列存储相乘的<code>num1</code>值；因为<code>num2</code>是在逐渐减少的，所以优先队列必须要放入当前值，推出最小的值</li></ol>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>贪心</tag>
      
      <tag>排序</tag>
      
      <tag>堆（优先队列）</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode649_Dota2参议院</title>
    <link href="/2024/03/08/LeetCode649-Dota2%E5%8F%82%E8%AE%AE%E9%99%A2/"/>
    <url>/2024/03/08/LeetCode649-Dota2%E5%8F%82%E8%AE%AE%E9%99%A2/</url>
    
    <content type="html"><![CDATA[<p>LeetCode649_Dota2参议院</p><span id="more"></span><p><code>Radiant</code>和<code>Dire</code>；以<code>Radiant</code>的议员为例，当一名<code>Radiant</code>的议员行使权利时：</p><ul><li>如果目前所有议员都是<code>Radiant</code>方，那么可以直接宣布取得胜利</li><li>如果仍然有<code>Dire</code>方的议员，那么只能行使【禁止一名参议员的权利】，那么应该挑选按照投票顺序的下一名<code>Dire</code>的议员【贪心】</li></ul><p>可以分别用两个队列存储<code>Radiant</code>和<code>Dire</code>的投票时间</p><ul><li><p>如果此时<code>Radiant</code>或者<code>Dire</code>为空，那么就可以宣布另一方获得胜利</p></li><li><p>如果均不为空，可以比较首元素，就可以确定当前行使权利的是哪方；</p></li><li><ul><li>如果<code>Radiant</code>的首元素较小，那说明轮到天辉方的议员行使权利</li><li>其会挑选<code>Dire</code>的首元素对应的那一名议员。因此，我们会将<code>Dire</code>的首元素永久地弹出</li><li>并将<code>Radiant</code>的首元素弹出，增加<code>n</code>【所有议员数量】之后再重新放回队列，即表示该议员会参与下一轮的投票</li></ul></li></ul><p>最后判断哪个不为空即可</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>贪心</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode1004_最大连续1的个数III</title>
    <link href="/2024/03/08/LeetCode1004-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0III/"/>
    <url>/2024/03/08/LeetCode1004-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0III/</url>
    
    <content type="html"><![CDATA[<p>LeetCode1004_最大连续1的个数III</p><span id="more"></span><p>可以转换为以下问题：</p><ol><li>枚举右端点$right$，希望找到最小的左端点$left$，使得$[left, right]$包含不超过$k$个$0$</li><li>只要枚举右端点，找到区间长度的最大值即可</li></ol><p><strong>判断区间</strong>$0$<strong>的个数</strong><br>可以将$0$和$1$互换，对数组$A$求出前缀和，记为数组$P$；<br>那么当且仅当两者的前缀和之差$P[right]-P[left-1]&lt;&#x3D;k$即可</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>$P[right]-P[left-1]&lt;&#x3D;k$等价于$P[left-1]&gt;&#x3D;P[right]-k$<br>因为数组中只包含$0$和$1$，因此$P$前缀和是单调递增的，可以用二分查找找到$left$，目标也就是满足上述条件的最小$left$<br>因为是$left-1$，所以为了避免越界，因此可以得到下面这个式子<br>$$P[0]&#x3D;0 \<br>P[i]&#x3D;P[i-1]+(1-A[i-1])$$<br>代码中的二分查找实际上用了一个内置函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestOnes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">P</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            P[i] = P[i - <span class="hljs-number">1</span>] + (<span class="hljs-number">1</span> - nums[i - <span class="hljs-number">1</span>]);<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right &lt; n; ++right) &#123;<br>            <span class="hljs-type">int</span> left = <span class="hljs-built_in">lower_bound</span>(P.<span class="hljs-built_in">begin</span>(), P.<span class="hljs-built_in">end</span>(), P[right + <span class="hljs-number">1</span>] - k) - P.<span class="hljs-built_in">begin</span>();<br>            ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>因为$P$数组是单调递增的，那么$P[right]-k$也是单调递增的，因此在$right$向右移动的时候，$left$也可以同步移动，就不需要存储前缀数组，只需要保存$left$和$right$当前的前缀变量即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestOnes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, lsum = <span class="hljs-number">0</span>, rsum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right &lt; n; ++right) &#123;<br>            rsum += <span class="hljs-number">1</span> - nums[right];<br>            <span class="hljs-keyword">while</span> (lsum &lt; rsum - k) &#123;<br>                lsum += <span class="hljs-number">1</span> - nums[left];<br>                ++left;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, right - left + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode1372_二叉树中的最长交错路径</title>
    <link href="/2024/03/08/LeetCode1372-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E4%BA%A4%E9%94%99%E8%B7%AF%E5%BE%84/"/>
    <url>/2024/03/08/LeetCode1372-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E4%BA%A4%E9%94%99%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p>LeetCode1372_二叉树中的最长交错路径</p><span id="more"></span><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>记$f(u)$为从根到节点$u$的路径上以$u$结尾并且$u$是它父亲的左儿子的最长交错路径；$g(u)$为从根到节点$u$的路径上以$u$结尾并且$u$是它父亲的右儿子的最长交错路径；记$u$的父节点为$father(u)$，可以这样推得转移方程：<br>$$f[u]&#x3D;g[father(u)]+1 \quad u是左儿子 \<br>g[u]&#x3D;f[father(u)]+1 \quad u是右儿子$$<br>实现的时候需要维护两个数组$f$和$g$。可以用BFS或者DFS，用<code>(node, parent)</code>作为状态，<code>node</code>表示当前待计算<code>f</code>和<code>g</code>的值的节点，<code>parent</code>表示它的父亲；根据当前的点是左子树还是右子树更新<code>f</code>和<code>g</code>，然后再拓展新状态入队<br>然后可以遍历<code>f</code>和<code>g</code>取最大值</p><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>在DP中对于每个节点$u$只使用到了父亲节点信息，所以可以在DFS的时候作为参数传递下来；关于<code>f</code>和<code>g</code>只需要传递【当前】这个点应该走的方向<code>dir</code>，以及这个点结尾的最长交错路径的长度<code>len</code><br>如果<code>dir</code>是左且可以向左，则让它向左走一步，且<code>len+1</code>；如果向左但没有左子树，则向右，<code>len</code>值重置为<code>1</code>；向右同理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> maxAns;<br><br>    <span class="hljs-comment">/* 0 =&gt; left, 1 =&gt; right */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* o, <span class="hljs-type">bool</span> dir, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>        maxAns = <span class="hljs-built_in">max</span>(maxAns, len);<br>        <span class="hljs-keyword">if</span> (!dir) &#123;<br>            <span class="hljs-keyword">if</span> (o-&gt;left) <span class="hljs-built_in">dfs</span>(o-&gt;left, <span class="hljs-number">1</span>, len + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (o-&gt;right) <span class="hljs-built_in">dfs</span>(o-&gt;right, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (o-&gt;right) <span class="hljs-built_in">dfs</span>(o-&gt;right, <span class="hljs-number">0</span>, len + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (o-&gt;left) <span class="hljs-built_in">dfs</span>(o-&gt;left, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125; <br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestZigZag</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        maxAns = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> maxAns;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode1466_重新规划路线</title>
    <link href="/2024/03/08/LeetCode1466-%E9%87%8D%E6%96%B0%E8%A7%84%E5%88%92%E8%B7%AF%E7%BA%BF/"/>
    <url>/2024/03/08/LeetCode1466-%E9%87%8D%E6%96%B0%E8%A7%84%E5%88%92%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p>LeetCode1466_重新规划路线</p><span id="more"></span><p>如果忽略边的方向，将每条有向边以及其反向边加入到图中，那么从任意一点出发都能到达$0$号点，路径上可能会经过反向边，则需要变更与之对应的原边的方向，需要变更的次数即为答案<br>考虑从$0$出发去遍历其他点，原来需要统计反向边的数量，现在需要统计原方向边的数量<br>用$1$标记原方向的边，用$0$标记反向边，然后从$0$号点开始遍历，访问到某个新的点时，所经过的边被$1$标记，则令答案加$1$，统计得到的答案就是需要变更方向的最小路线数</p><p>这道题的难点还有怎么用代码构建树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> parent, vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt;&amp; e)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;edge : e[x]) &#123;<br>            <span class="hljs-keyword">if</span> (edge.first == parent) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            res += edge.second + <span class="hljs-built_in">dfs</span>(edge.first, x, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minReorder</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; connections)</span> </span>&#123;<br>        vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">e</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> edge : connections) &#123;<br>            e[edge[<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(edge[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>));<br>            e[edge[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(edge[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, e);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode1493_删掉一个元素以后全为1的最长子数组</title>
    <link href="/2024/03/08/LeetCode1493-%E5%88%A0%E6%8E%89%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BB%A5%E5%90%8E%E5%85%A8%E4%B8%BA1%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2024/03/08/LeetCode1493-%E5%88%A0%E6%8E%89%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BB%A5%E5%90%8E%E5%85%A8%E4%B8%BA1%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>LeetCode1493_删掉一个元素以后全为1的最长子数组</p><span id="more"></span><p>可以枚举被删除的位置，假设下标为$i$，希望知道【以第$i-1$位结尾的最长连续全$1$子数组】和【以第$i+1$位开头的最长连续全$1$子数组】的长度分别是多少，相加即可<br>可以分别记为$pre(i)$为【以第$i$位结尾的最长连续全$1$子数组】和$suf(i)$为【以第$i$位结尾的最长连续全$1$子数组】；正向遍历+反向遍历即可<br>然后从头遍历$0-n$，得到$pre(i)+suf(i)$的最大值</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode201_数字范围按位与</title>
    <link href="/2024/03/08/LeetCode201-%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/"/>
    <url>/2024/03/08/LeetCode201-%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E/</url>
    
    <content type="html"><![CDATA[<p>LeetCode201_数字范围按位与</p><span id="more"></span><p>发现规律：对所有数字执行按位与运算的结果是所有对应二进制字符串的公共前缀再用零补上后面的剩余位；其实所有数字的公共前缀 &#x3D; 起始末尾两个数的公共前缀<br>下面求 9 和 12 的公共前缀即可</p><p><img src="/Assets/image-20240404181549769.png"></p><p>因此，题目可以转换为：给定两个整数，找到它们对应的二进制字符串的公共前缀</p><h3 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h3><ol><li>右移，将两个数字压缩为它们的公共前缀；在迭代过程中，我们计算执行的右移操作数</li><li>将得到的公共前缀左移相同的操作数得到结果</li></ol><p><img src="/Assets/14461d16f23cc31be76cc8f639ca61d7_MD5.jpeg"></p><h3 id="Brian-Kernighan-算法"><a href="#Brian-Kernighan-算法" class="headerlink" title="Brian Kernighan 算法"></a>Brian Kernighan 算法</h3><p>技巧：$n&amp;(n-1)$会消去$n$最后一位的$1$<br>对于$[m,n]$，可以对$n$逐步使用该技巧，直到其$&lt;&#x3D;m$；这时非公共前缀的$1$被消去，直接返回$n$即可</p><p><img src="/Assets/image-20240404181832927.png"></p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode236_二叉树的最近公共祖先</title>
    <link href="/2024/03/08/LeetCode236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2024/03/08/LeetCode236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<p>LeetCode236_二叉树的最近公共祖先</p><span id="more"></span><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>若$root$是$p,q$的 最近公共祖先 ，则只可能为以下情况之一：</p><ol><li>$p$和 $q$在 $root$的子树中，且分列 $root$的 异侧（即分别在左、右子树中）；</li><li>$p&#x3D;root$ ，且 $q$在 $root$的左或右子树中；</li><li>$q&#x3D;root$，且 $p$在 $root$的左或右子树中；</li></ol><p>可以这样定义递归函数功能：</p><ol><li><p>$p,q$都能找到 返回最近公共祖先 </p></li><li><p>$p,q$找到一个，返回$p,q$ </p></li><li><p>都没找到，返回$null$</p></li><li><p>参数：$root$代表当前遍历到的结点；</p></li><li><p>终止条件：</p><ol><li>当越过叶节点，则直接返回$null$</li><li>当$root &#x3D; q || p$，则直接返回$root$</li></ol></li><li><p>递推工作：</p><ol><li>递归左结点：返回值记做$left$</li><li>递归右结点：返回值记做$right$</li></ol></li><li><p>返回值：当前$root$的子树中有没有$q || p$</p><ol><li>$left$和$right$同时为空：说明左右子树都不包含$p,q$，返回$null$</li><li>$left$和$right$同时不为空：说明$p,q$在$root$异侧，$root$则是最近公共祖先，返回$root$</li><li>$left$为空，$right$不为空：说明$p,q$都不在左子树中，直接返回$right$<ol><li>$p,q$其中一个在$root$的右子树中，则$right$就是$p||q$</li><li>$p,q$两个节点都在右子树中，则$right$是公共祖先</li><li>PS：上面这有点难理解，但是如果看图解是可以总结出来的</li></ol></li><li>$right$为空，$left$不为空：和3同理</li></ol></li></ol><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="/Assets/073753a317a9c170f8d7e0ddb606d22a_MD5.jpg"></p><p><img src="/Assets/059ab27097720531cc583af73ea42203_MD5.jpg"></p><p><img src="/Assets/1970b9b325b0a18323a3b3910a9b08ce_MD5.jpg"></p><p><img src="/Assets/38e548ecd0f605a3911da1b8dfa3fdeb_MD5.jpg"></p><p><img src="/Assets/dfffd4e5fdedc245c28dfdf8dfe6bf9b_MD5.jpg"></p><p><img src="/Assets/3496b9a78a368413bc0137cde5569f6a_MD5.jpg"></p><p><img src="/Assets/226e3f1f487c76e3d6fd0540bf092452_MD5.jpg"></p><p><img src="/Assets/1d56beff719db69ca30a19e7e28d10f7_MD5.jpg"></p><p><img src="/Assets/e80d5a7a58459fbdbd6d74e250315366_MD5.jpg"></p><p><img src="/Assets/f34b551c8b3ebf719d41af4e819932ee_MD5.jpg"></p><p><img src="/Assets/c899b4401dd3fb453c2b0350c12f6151_MD5.jpg"></p><p><img src="/Assets/015385717ee62ec7a66c260ab6192690_MD5.jpg"></p><p><img src="/Assets/c14b3af16034754ed8abea576eb2016d_MD5.jpg"></p><p><img src="/Assets/a8d65058631a88d2da9e075ed0e13b67_MD5.jpg"></p><p><img src="/Assets/fa09b35b40b9c9fc469010d9f93a8896_MD5.jpg"></p><p><img src="/Assets/a7b66f30d6e44c46b5dc18a36e7e3210_MD5.jpg"></p><p><img src="/Assets/e6ba6cb9f71f347e5d65f35d505033b1_MD5.jpg"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span> || root == p || root == q) <span class="hljs-keyword">return</span> root;<br>        TreeNode *left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode *right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">nullptr</span> &amp;&amp; right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 1.</span><br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> right; <span class="hljs-comment">// 3.</span><br>        <span class="hljs-keyword">if</span>(right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> left; <span class="hljs-comment">// 4.</span><br>        <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 2. if(left != null and right != null)</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode399_除法求值</title>
    <link href="/2024/03/08/LeetCode399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/"/>
    <url>/2024/03/08/LeetCode399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>LeetCode399_除法求值</p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p><strong>分析示例</strong></p><ul><li><code>a / b = 2.0</code> 说明 <strong>$a &#x3D; 2b$</strong> ， <strong><code>a</code></strong> 和 **<code>b</code>在同一个集合中</li><li><code>b / c = 3.0</code>说明 <strong>$b &#x3D; 3c$</strong> ，**<code>b</code>** 和 <strong><code>c</code></strong> 在同一个集合中</li><li>求$\frac{a}{c}$，可以把$a&#x3D;2b$，$b&#x3D;3c$依次代入，得到$\frac{a}{c}&#x3D;\frac{2b}{c}&#x3D;\frac{2 \cdot 3c}{c}&#x3D;6.0$</li><li>求$\frac{b}{a}$，可以根据$a&#x3D;2b$，知道$\frac{b}{a}&#x3D;0.5$，也可以把$b$和$a$都转换成$c$的倍数，得到$\frac{b}{a}&#x3D;\frac{b}{2b}&#x3D;\frac{3c}{6c}&#x3D;\frac{1}{2}&#x3D;0.5$</li></ul><p><strong>分析发现</strong><br>根据 <code>equation</code> 中两个变量进行合并，在同一个集合的变量就有比值<br>题目中如果两个变量不在同一个集合中， 返回$-1.0$<br>如果两个变量中 至少有一个 变量没有出现在所有 <code>equations</code> 出现的字符集合中，也返回 $-1.0$</p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/png/25958751/1706261556879-d0ee3ba0-5178-4f59-b7b0-528c481adc26.png#averageHue=%23f4f4f4&clientId=u8c805d40-a8c8-4&from=paste&height=353&id=uaf2cefdd&originHeight=706&originWidth=990&originalType=binary&ratio=2&rotation=0&showTitle=false&size=75822&status=done&style=none&taskId=uef5d3880-5fe7-4d78-ad6e-97bc47d358c&title=&width=495" alt="image.png"></p><p><strong>「路径压缩」</strong><br>在查询一个结点 <code>a</code> 的根结点同时，把结点 <code>a</code> 到根结点的沿途所有结点的父亲结点都指向根结点<br>也是两个结点都指向根节点，他们的权值之比才有效；在查询的时候做路径压缩操作<br><img src="https://cdn.nlark.com/yuque/0/2024/png/25958751/1706261616908-08207b5b-d1c7-4ca6-b981-1ce7a4a97841.png#averageHue=%23fefdfd&clientId=u8c805d40-a8c8-4&from=paste&height=275&id=ud5fed148&originHeight=550&originWidth=1136&originalType=binary&ratio=2&rotation=0&showTitle=false&size=79556&status=done&style=none&taskId=ud421a035-bf8d-4ce1-83eb-32dac31324c&title=&width=568" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2024/png/25958751/1706261684085-81ad23f3-5999-4889-ad64-3c64f7c0675a.png#averageHue=%23faf9f8&clientId=u8c805d40-a8c8-4&from=paste&height=328&id=u1b7d7515&originHeight=656&originWidth=1840&originalType=binary&ratio=2&rotation=0&showTitle=false&size=181814&status=done&style=none&taskId=u09049fdd-64ce-4408-ba6a-3e08d4431ba&title=&width=920" alt="image.png"><br><strong>「合并」</strong><br>例如已知$\frac{a}{b}&#x3D;3.0$，$\frac{d}{c}&#x3D;4.0$，又知$\frac{a}{d}&#x3D;6.0$，$a$，$d$所属集合不一样，则需要进行合并操作<br><img src="https://cdn.nlark.com/yuque/0/2024/png/25958751/1706261856959-494c443c-ee66-4334-bd5b-af78a1908cba.png#averageHue=%23fbfbfb&clientId=u8c805d40-a8c8-4&from=paste&height=197&id=u2f1e107a&originHeight=394&originWidth=944&originalType=binary&ratio=2&rotation=0&showTitle=false&size=45750&status=done&style=none&taskId=uf8b16822-a145-42fb-ad79-62be874783f&title=&width=472" alt="image.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent; <span class="hljs-comment">// 存放父节点</span><br>    vector&lt;<span class="hljs-type">double</span>&gt; weight; <span class="hljs-comment">// 指向父节点的权值</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            weight.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1.0</span>); <span class="hljs-comment">// 权重初始化为1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 路径压缩。返回根节点id</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归寻找根节点，更新该点到根的权重为该点父节点到根的权重</span><br>        <span class="hljs-keyword">if</span> (x != parent[x]) &#123;<br>            <span class="hljs-type">int</span> origin = parent[x];<br>            parent[x] = <span class="hljs-built_in">find</span>(parent[x]);<br>            weight[x] *= weight[origin];<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br>    <span class="hljs-comment">// 返回除法结果。如果两个值不存在则-1</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">isConected</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rootX = <span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-type">int</span> rootY = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-comment">// 如果两个值有共同的根也就是可以计算，则算结果。否则不在同一个并查集，-1</span><br>        <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>            <span class="hljs-keyword">return</span> weight[x] / weight[y];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1.00000</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 合并操作，在find步会进行路径压缩</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myunion</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">double</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// 分别找到二者的根节点</span><br>        <span class="hljs-type">int</span> rootX = <span class="hljs-built_in">find</span>(x), rootY = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 二者已经指向同一个根节点</span><br>        &#125;<br>        <span class="hljs-comment">// 令分子指向分母的根节点，权重为分母到根的权重*分母除分子的值/分子到根的权重。一开始都是1</span><br>        parent[rootX] = rootY;<br>        weight[rootX] = weight[y] * value / weight[x];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">calcEquation</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;<span class="hljs-type">double</span>&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries)</span> </span>&#123;<br>        <span class="hljs-comment">// 初始化并查集</span><br>        <span class="hljs-type">int</span> equationsSize = equations.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">UnionFind <span class="hljs-title">unionFind</span><span class="hljs-params">(<span class="hljs-number">2</span> * equationsSize)</span></span>;<br>        <span class="hljs-comment">// 第 1 步：预处理，将变量的值与 id 进行映射</span><br>        map&lt;string, <span class="hljs-type">int</span>&gt; hashMap;<br>        <span class="hljs-type">int</span> id = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; equationsSize; ++i) &#123;<br>            <span class="hljs-comment">// 存分子，分母，值为id</span><br>            vector&lt;string&gt; equation = equations[i];<br>            string var1 = equation[<span class="hljs-number">0</span>];<br>            string var2 = equation[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (!hashMap.<span class="hljs-built_in">count</span>(var1)) &#123;<br>                hashMap[var1] = id;<br>                ++id;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!hashMap.<span class="hljs-built_in">count</span>(var2)) &#123;<br>                hashMap[var2] = id;<br>                ++id;<br>            &#125;<br>            <span class="hljs-comment">// 把分子分母用有向边连起来</span><br>            unionFind.<span class="hljs-built_in">myunion</span>(hashMap[var1], hashMap[var2], values[i]);<br>        &#125;<br>        <span class="hljs-comment">// 第 2 步：做查询</span><br>        <span class="hljs-type">int</span> queriesSize = queries.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(queriesSize, <span class="hljs-number">-1.00000</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; queriesSize; ++i) &#123;<br>            string var1 = queries[i][<span class="hljs-number">0</span>];<br>            string var2 = queries[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> id1, id2;<br>            <span class="hljs-comment">// 如果两个值有至少一个不在equations中，结果为-1，否则做除法</span><br>            <span class="hljs-keyword">if</span> (hashMap.<span class="hljs-built_in">count</span>(var1) &amp;&amp; hashMap.<span class="hljs-built_in">count</span>(var2)) &#123;<br>                id1 = hashMap[var1];<br>                id2 = hashMap[var2];<br>                res[i] = unionFind.<span class="hljs-built_in">isConected</span>(id1, id2);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode399_除法求值</title>
    <link href="/2024/03/08/LeetCode399_%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/"/>
    <url>/2024/03/08/LeetCode399_%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>LeetCode399_除法求值</p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p><strong>分析示例</strong></p><ul><li><code>a / b = 2.0</code> 说明 <strong>$a &#x3D; 2b$</strong> ， <strong><code>a</code></strong> 和 **<code>b</code>在同一个集合中</li><li><code>b / c = 3.0</code>说明 <strong>$b &#x3D; 3c$</strong> ，**<code>b</code>** 和 <strong><code>c</code></strong> 在同一个集合中</li><li>求$\frac{a}{c}$，可以把$a&#x3D;2b$，$b&#x3D;3c$依次代入，得到$\frac{a}{c}&#x3D;\frac{2b}{c}&#x3D;\frac{2 \cdot 3c}{c}&#x3D;6.0$</li><li>求$\frac{b}{a}$，可以根据$a&#x3D;2b$，知道$\frac{b}{a}&#x3D;0.5$，也可以把$b$和$a$都转换成$c$的倍数，得到$\frac{b}{a}&#x3D;\frac{b}{2b}&#x3D;\frac{3c}{6c}&#x3D;\frac{1}{2}&#x3D;0.5$</li></ul><p><strong>分析发现</strong><br>根据 <code>equation</code> 中两个变量进行合并，在同一个集合的变量就有比值<br>题目中如果两个变量不在同一个集合中， 返回$-1.0$<br>如果两个变量中 至少有一个 变量没有出现在所有 <code>equations</code> 出现的字符集合中，也返回 $-1.0$</p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p><img src="/Assets/ae5efbe3418f879f582799a4c3192267_MD5.png" alt="image.png"></p><p><strong>「路径压缩」</strong><br>在查询一个结点 <code>a</code> 的根结点同时，把结点 <code>a</code> 到根结点的沿途所有结点的父亲结点都指向根结点<br>也是两个结点都指向根节点，他们的权值之比才有效；在查询的时候做路径压缩操作<br><img src="/Assets/42898d74e9a81f1d4a98751b043d4639_MD5.png" alt="image.png"><br><img src="/Assets/f2efeda1b3b14e63839e7a3bac8ffded_MD5.png" alt="image.png"><br><strong>「合并」</strong><br>例如已知$\frac{a}{b}&#x3D;3.0$，$\frac{d}{c}&#x3D;4.0$，又知$\frac{a}{d}&#x3D;6.0$，$a$，$d$所属集合不一样，则需要进行合并操作<br><img src="/Assets/f9bbe7776d7c5b88ab38ec7a6bbb1212_MD5.png" alt="image.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnionFind</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; parent; <span class="hljs-comment">// 存放父节点</span><br>    vector&lt;<span class="hljs-type">double</span>&gt; weight; <span class="hljs-comment">// 指向父节点的权值</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            parent.<span class="hljs-built_in">push_back</span>(i);<br>            weight.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1.0</span>); <span class="hljs-comment">// 权重初始化为1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 路径压缩。返回根节点id</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// 递归寻找根节点，更新该点到根的权重为该点父节点到根的权重</span><br>        <span class="hljs-keyword">if</span> (x != parent[x]) &#123;<br>            <span class="hljs-type">int</span> origin = parent[x];<br>            parent[x] = <span class="hljs-built_in">find</span>(parent[x]);<br>            weight[x] *= weight[origin];<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[x];<br>    &#125;<br>    <span class="hljs-comment">// 返回除法结果。如果两个值不存在则-1</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">isConected</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rootX = <span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-type">int</span> rootY = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-comment">// 如果两个值有共同的根也就是可以计算，则算结果。否则不在同一个并查集，-1</span><br>        <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>            <span class="hljs-keyword">return</span> weight[x] / weight[y];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1.00000</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">// 合并操作，在find步会进行路径压缩</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myunion</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">double</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">// 分别找到二者的根节点</span><br>        <span class="hljs-type">int</span> rootX = <span class="hljs-built_in">find</span>(x), rootY = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (rootX == rootY) &#123;<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 二者已经指向同一个根节点</span><br>        &#125;<br>        <span class="hljs-comment">// 令分子指向分母的根节点，权重为分母到根的权重*分母除分子的值/分子到根的权重。一开始都是1</span><br>        parent[rootX] = rootY;<br>        weight[rootX] = weight[y] * value / weight[x];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">calcEquation</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;<span class="hljs-type">double</span>&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries)</span> </span>&#123;<br>        <span class="hljs-comment">// 初始化并查集</span><br>        <span class="hljs-type">int</span> equationsSize = equations.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">UnionFind <span class="hljs-title">unionFind</span><span class="hljs-params">(<span class="hljs-number">2</span> * equationsSize)</span></span>;<br>        <span class="hljs-comment">// 第 1 步：预处理，将变量的值与 id 进行映射</span><br>        map&lt;string, <span class="hljs-type">int</span>&gt; hashMap;<br>        <span class="hljs-type">int</span> id = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; equationsSize; ++i) &#123;<br>            <span class="hljs-comment">// 存分子，分母，值为id</span><br>            vector&lt;string&gt; equation = equations[i];<br>            string var1 = equation[<span class="hljs-number">0</span>];<br>            string var2 = equation[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (!hashMap.<span class="hljs-built_in">count</span>(var1)) &#123;<br>                hashMap[var1] = id;<br>                ++id;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!hashMap.<span class="hljs-built_in">count</span>(var2)) &#123;<br>                hashMap[var2] = id;<br>                ++id;<br>            &#125;<br>            <span class="hljs-comment">// 把分子分母用有向边连起来</span><br>            unionFind.<span class="hljs-built_in">myunion</span>(hashMap[var1], hashMap[var2], values[i]);<br>        &#125;<br>        <span class="hljs-comment">// 第 2 步：做查询</span><br>        <span class="hljs-type">int</span> queriesSize = queries.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(queriesSize, <span class="hljs-number">-1.00000</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; queriesSize; ++i) &#123;<br>            string var1 = queries[i][<span class="hljs-number">0</span>];<br>            string var2 = queries[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-type">int</span> id1, id2;<br>            <span class="hljs-comment">// 如果两个值有至少一个不在equations中，结果为-1，否则做除法</span><br>            <span class="hljs-keyword">if</span> (hashMap.<span class="hljs-built_in">count</span>(var1) &amp;&amp; hashMap.<span class="hljs-built_in">count</span>(var2)) &#123;<br>                id1 = hashMap[var1];<br>                id2 = hashMap[var2];<br>                res[i] = unionFind.<span class="hljs-built_in">isConected</span>(id1, id2);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode875_爱吃香蕉的珂珂</title>
    <link href="/2024/03/08/LeetCode875-%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/"/>
    <url>/2024/03/08/LeetCode875-%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/</url>
    
    <content type="html"><![CDATA[<p>LeetCode875_爱吃香蕉的珂珂</p><span id="more"></span><p>这道题感觉就是在对题目进行推导计算公式</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果在$h$小时内吃掉所有香蕉的最小速度是每小时$k$个香蕉，则当吃香蕉的速度大于每小时$k$个香蕉时一定可以在$h$小时内吃掉所有香蕉，当吃香蕉的速度小于每小时$k$个香蕉时一定不能在$h$小时内吃掉所有香蕉<br>因此可以用二分查找的方法得到最小速度$k$；由于每小时都要吃香蕉，即每小时至少吃$1$个香蕉，下界是$1$；由于每小时最多吃一堆香蕉，即每小时吃的香蕉数目不会超过最多的一堆中的香蕉数目，因此上界是最多的一堆中的香蕉数目<br>假设吃香蕉的速度是$speed$，则当一堆香蕉的个数是$pile$时，吃掉这堆香蕉需要$\lceil \frac{pile}{speed} \rceil$小时；如果在速度$speed$下可以在$h$小时内吃掉所有香蕉，则最小速度一定小于或等于$speed$，上界调整为$speed$；否则最小速度一定大于$speed$，因此将下界调整为$speed+1$</p><p>二分查找结束之后，即可得到在$h$小时内吃掉所有香蕉的最小速度$k$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在计算吃掉每一堆香蕉的时间时，由于$pile$和$speed$都大于$0$，因此$\lceil \frac{pile}{speed} \rceil$等价于$\lfloor \frac{pile+speed-1}{speed} \rfloor$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minEatingSpeed</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles, <span class="hljs-type">int</span> h)</span> </span>&#123;<br>        <span class="hljs-type">int</span> low = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> high = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pile : piles) &#123;<br>            high = <span class="hljs-built_in">max</span>(high, pile);<br>        &#125;<br>        <span class="hljs-type">int</span> k = high;<br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>            <span class="hljs-type">int</span> speed = (high - low) / <span class="hljs-number">2</span> + low;<br>            <span class="hljs-type">long</span> time = <span class="hljs-built_in">getTime</span>(piles, speed);<br>            <span class="hljs-keyword">if</span> (time &lt;= h) &#123;<br>                k = speed;<br>                high = speed;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                low = speed + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">getTime</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; piles, <span class="hljs-type">int</span> speed)</span> </span>&#123;<br>        <span class="hljs-type">long</span> time = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pile : piles) &#123;<br>            <span class="hljs-type">int</span> curTime = (pile + speed - <span class="hljs-number">1</span>) / speed;<br>            time += curTime;<br>        &#125;<br>        <span class="hljs-keyword">return</span> time;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode968_监控二叉树</title>
    <link href="/2024/03/08/LeetCode968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2024/03/08/LeetCode968-%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>LeetCode968_监控二叉树</p><span id="more"></span><p><strong>【遍历方式】</strong><br>因为需要尽量让叶子结点的父结点安装摄像头，所以需要从底往上推导，也就是后序遍历</p><p><strong>【转移方程】</strong><br>每个节点有3种状态；父结点就可以根据每个节点的</p><ul><li>0：该节点无覆盖</li><li>1：本节点有摄像头</li><li>2：本节点有覆盖</li></ul><p><strong>【空节点状态】</strong><br>不能是无覆盖状态：因为叶子结点就可以放摄像头了<br>不能是有摄像头状态：因为叶子结点就没必要放摄像头了<br>所以应该是 有覆盖 状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 空节点，该节点有覆盖</span><br><span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p><strong>【递推关系】</strong><br>有4种情况</p><ol><li><p>情况1：左右节点都有覆盖，则中间结点是无覆盖状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 左右节点都有覆盖</span><br><span class="hljs-keyword">if</span> (left == <span class="hljs-number">2</span> &amp;&amp; right == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li><li><p>情况2：左右节点至少有一个无覆盖的情况，则中间结点应该放摄像头</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) &#123;<br>    result++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>情况3：左右节点至少有一个有摄像头，则中间结点应该是有覆盖状态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (left == <span class="hljs-number">1</span> || right == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure></li><li><p>情况4：头结点没有覆盖，递归结束之后，可能头结点 还有一个无覆盖的情况，所以还需要判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(root) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// root 无覆盖</span><br>        result++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode437_路径总和III</title>
    <link href="/2024/03/08/LeetCode437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII/"/>
    <url>/2024/03/08/LeetCode437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII/</url>
    
    <content type="html"><![CDATA[<p>LeetCode437_路径总和III</p><span id="more"></span><p>前缀和：由根结点到当前结点的路径上所有节点的和<br>可以利用先序遍历二叉树，记录根节点$root$到当前节点$p$的路径上除当前节点以外所有节点的前缀和，在已保存的路径前缀和中查找是否存在前缀和刚好等于当前节点到根节点的前缀和$curr$减去$targetSum$</p><p>比如下面遍历到3的时候，得到10-5这部分前缀和；则存在前缀和为10-15的；当前节点到根节点的前缀和$curr$为18；<br>存在18-10&#x3D;8；说明5-3这部分刚好等于$targetSum$(即蓝色部分)<br><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/25958751/1708949979908-1ec5f2c5-688b-45e0-94f5-6e9a29bab82a.jpeg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>unordered_map&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; prefix; <span class="hljs-comment">// 前缀和 和 其个数（遍历到当前节点时）</span><br><span class="hljs-comment">// 当前遍历节点；到当前节点的前缀和；目标值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(TreeNode437 *root, <span class="hljs-type">long</span> <span class="hljs-type">long</span> curr, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    curr += root-&gt;val;<br>    count += prefix[curr - targetSum];<br>    prefix[curr]++;<br>    <span class="hljs-built_in">helper</span>(root-&gt;left, curr, targetSum);<br>    <span class="hljs-built_in">helper</span>(root-&gt;right, curr, targetSum);<br>    prefix[curr]--;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode212_单词搜索II</title>
    <link href="/2024/03/08/LeetCode212-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2II/"/>
    <url>/2024/03/08/LeetCode212-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2II/</url>
    
    <content type="html"><![CDATA[<p>LeetCode212_单词搜索II</p><span id="more"></span><p>这道题是回溯 + 字典树的结合</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>将<code>words</code>中所有单词都放到前缀树中</li><li>遍历二维网格中所有单元格</li><li>深度优先搜索从当前单元格出发的路径；每经过一个单元格，就将其临时修改为<code>#</code></li><li>如果是<code>words</code>中的单词，就添加到结果集中；如果是<code>words</code>中任意一个单词的前缀，则继续搜索；反之，则剪枝</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ol><li>因为一个单词可能在多个路径中出现，所以需要使用哈希集对结果集进行去重</li><li>回溯过程中，不需要对每一个路径都判断是不是前缀，可以保留上一个前缀结点</li></ol>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>数组</tag>
      
      <tag>字典树</tag>
      
      <tag>回溯</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode153_寻找旋转排序数组中的最小值</title>
    <link href="/2024/03/08/LeetCode153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <url>/2024/03/08/LeetCode153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>LeetCode153_寻找旋转排序数组中的最小值</p><span id="more"></span><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>假设数组最后一个值是<code>x</code>，那么最小值左边的都是<code>&gt;x</code>的，右边的都是<code>&lt;x</code>的</p><p>那么左中右三个指针相比较有下面几种情况：</p><ol><li>左值 &lt; 中值, 中值 &gt; 右值 ：有旋转，最小值在右半边，可以收缩左边界</li></ol><p><img src="/Assets/1706172298100-68eb1f13-d22b-4902-902e-938f7ca1408b.jpeg" alt="img"></p><ol><li>左值 &lt; 中值, 中值 &lt; 右值 ：没有旋转，最小值在最左边，可以收缩右边界</li></ol><p><img src="/Assets/1706172439538-f8b1d926-4002-4c90-a9f3-fbdb7e8b1f3b.jpeg" alt="img"></p><ol><li>左值 &gt; 中值, 中值 &lt; 右值 ：有旋转，最小值在左半边，可以收缩右边界</li></ol><p><img src="/Assets/1706172535057-c2a505b0-b7fc-4231-be2a-3432b04dfafc.jpeg" alt="img"></p><ul><li>情况2、3是一类，情况1是另一类</li><li>如果中值 &lt; 右值，则最小值在左半边，可以收缩右边界。</li><li>如果中值 &gt; 右值，则最小值在右半边，可以收缩左边界。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[right]) &#123;      <span class="hljs-comment">// 因为 中值&gt;右值，所以中值肯定不是最小值</span><br>                left = mid + <span class="hljs-number">1</span>; <br>            &#125; <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-comment">// 因为 中值&lt;右值，所以中值有可能是最小值</span><br>                right = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[left];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>是用二分查找，只不过是 中间值 和 右边界 在比较；下面是代码分析</p><ol><li>是左闭右闭</li><li>中间位置<code>mid</code>更靠近<code>left</code></li><li>如果左右数组重合，即<code>left=right</code>，即只有一个数</li><li>如果仅剩两个数</li></ol><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>为什么左右不对称？</p><p>这是循环前升序排列的数，左边的数小，右边的数大，而且我们要找的是最小值，肯定是偏向左找，所以左右不对称了。</p><p>为什么比较mid与right而不比较mid与left？</p><p>单讲就是因为我们找最小值，要偏向左找，目标值右边的情况会比较简单，容易区分，所以比较mid与right而不比较mid与left。</p><p>那么能不能通过比较mid与left来解决问题?</p><p>转换思路，不直接找最小值，而是先找最大值，最大值偏右，可以通过比较mid与left来找到最大值，最大值向右移动一位就是最小值了（需要考虑最大值在最右边的情况，右移一位后对数组长度取余）。</p><p>这题和154题：找到上下界可以用相同思路来理解判断</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode148_排序链表</title>
    <link href="/2024/03/08/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/03/08/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>LeetCode148_排序链表</p><span id="more"></span><h3 id="思路部分"><a href="#思路部分" class="headerlink" title="思路部分"></a>思路部分</h3><p>可以自顶向下，也可以自底向上，都是采用归并排序，下面介绍自顶向下的</p><p><img src="/Assets/1706170679001-9be93a26-e09a-4a48-a57d-c96cd68cf0a2.png" alt="img"></p><p>分割环节：</p><ul><li>找到链表的中点，以中点为分界，将链表拆分成两个子链表（可以用快慢指针）</li><li>递归两个分链表；递归终止条件-只有一个节点了（<code>next=None</code>）</li></ul><p>合并环节：</p><ul><li>将两个排序链表进行合并（可用双指针）</li><li>返回排序好的链表头结点</li></ul><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><ol><li>分割：<code>ListNode* sortList(ListNode* head, ListNode* tail)</code></li><li>合并：<code>ListNode* merge(ListNode* head1, ListNode* head2)</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode33_搜索旋转排序数组</title>
    <link href="/2024/03/08/LeetCode33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2024/03/08/LeetCode33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>LeetCode33_搜索旋转排序数组</p><span id="more"></span><h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><ol><li>先找到 「153. 寻找旋转排序数组中的最小值」的索引，由此可以将数组分为升序的两段。</li><li>根据 <code>nums[0]</code> 与 <code>target</code> 的关系判断 <code>target</code> 在左段还是右段，再对升序数组进行二分查找即可。</li></ol><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>直接在有序数组中查找</p><ol><li>将数组从中间分成左右两边的时候，总有一边是有序的，因此判断哪边是有序的</li><li>有序的判断：最左边值&lt;最右边值</li><li>根据有序的一边可以确定上下界，因此可以确定$target$在哪一边，再用二分法循环</li></ol>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode4_寻找两个正序数组的中位数</title>
    <link href="/2024/03/08/LeetCode4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2024/03/08/LeetCode4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>LeetCode4_寻找两个正序数组的中位数</p><span id="more"></span><p>这道题思路有点多，且方法有点多，下面理解二分的；且有时间复杂度的要求是$O(logn)$</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于两个数组，采用划分的方式解决<br><img src="/Assets/9eb4beeb10076b560de835ef3b428b33_MD5.jpg"></p><ol><li>如果是两个数组之和是偶数：$size_{left}&#x3D;size_{right}$</li></ol><p>如果是两个数组之和是奇数：$size_{left}&#x3D;size_{right}+1$<br>假设两个数组长度分别是$m,n$，可以统一成$size_{left}&#x3D;\frac{m+n+1}{2}$</p><ol start="2"><li>需要满足分割线左边所有数 &lt; 分割线右边所有数；所以左上 &lt; 右下，左下 &lt; 右上</li><li>中位数 &#x3D; $max$(左边两个值) + $min$(右边两个值)</li><li>所以只需要确定分割线的位置，这就采用二分查找<ol><li>分割线右边的数太小，就将分割线在数组1中右移动</li><li>分割线左边的数太大，就将分割线在数组1中左移动</li></ol></li><li>特殊情况讨论：可能会产生下标越界</li></ol><p>两个数组长度不一样<br><img src="/Assets/21c0f27875cd519eeb82876a2b16018c_MD5.jpg"><br>两个数组长度一样<br><img src="/Assets/562beeb0229ffb033cf92ad9063463ed_MD5.jpg"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>二分查找：查找数组1中分割线的位置<br><img src="/Assets/fcc06fd1ea290232a00dd7bd3ea15a5d_MD5.jpg"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> m = nums<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> n = nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = m;<br><br><span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-comment">// 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1]</span><br>    <span class="hljs-comment">// 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1]</span><br>    <span class="hljs-type">int</span> i = (left + right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> j = (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - i;<br><br>    <span class="hljs-comment">// 注意数组越界问题 &amp; 取分割线两边的值</span><br>    <span class="hljs-comment">// nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j]</span><br>    <span class="hljs-type">int</span> nums_im1 = (i == <span class="hljs-number">0</span> ? INT_MIN : nums1[i - <span class="hljs-number">1</span>]);<br>    <span class="hljs-type">int</span> nums_i = (i == m ? INT_MAX : nums1[i]);<br>    <span class="hljs-type">int</span> nums_jm1 = (j == <span class="hljs-number">0</span> ? INT_MIN : nums2[j - <span class="hljs-number">1</span>]);<br>    <span class="hljs-type">int</span> nums_j = (j == n ? INT_MAX : nums2[j]);<br><br>    <span class="hljs-comment">// 移动分割线的查找区间</span><br>    <span class="hljs-keyword">if</span> (nums_im1 &lt;= nums_j) &#123;<br>        median1 = <span class="hljs-built_in">max</span>(nums_im1, nums_jm1);<br>        median2 = <span class="hljs-built_in">min</span>(nums_i, nums_j);<br>        left = i + <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        right = i - <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode1071_字符串的最大公因子</title>
    <link href="/2024/03/08/LeetCode1071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/"/>
    <url>/2024/03/08/LeetCode1071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p>LeetCode1071_字符串的最大公因子</p><span id="more"></span><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>答案是某个字符串的前缀，因此可以枚举所有的前缀来判断<br>设前缀长度为$lenz$，$str1$的长度为$len1$，$str2$的长度为$len2$，则前缀串的长度需要是两个字符串长度的约数才能满足条件。<br>即$len1 \mod lenz &#x3D;&#x3D;0$，$len2 \mod lenz &#x3D;&#x3D;0$<br>所以可以从大到小枚举字符串前缀，代码如下。先判断满足是约数，再判断是否是重复前缀</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(string t,string s)</span></span>&#123;<br>        <span class="hljs-type">int</span> lenx = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>() / (<span class="hljs-type">int</span>)t.<span class="hljs-built_in">length</span>();<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= lenx; ++i)&#123;<br>            ans = ans + t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == s;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">gcdOfStrings</span><span class="hljs-params">(string str1, string str2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len1 = (<span class="hljs-type">int</span>)str<span class="hljs-number">1.l</span>ength(), len2 = (<span class="hljs-type">int</span>)str<span class="hljs-number">2.l</span>ength();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">min</span>(len1, len2); i &gt;= <span class="hljs-number">1</span>; --i)&#123; <span class="hljs-comment">// 从长度大的开始枚举</span><br>            <span class="hljs-keyword">if</span> (len1 % i == <span class="hljs-number">0</span> &amp;&amp; len2 % i == <span class="hljs-number">0</span>)&#123;<br>                string X = str<span class="hljs-number">1.</span><span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(X, str1) &amp;&amp; <span class="hljs-built_in">check</span>(X, str2)) <span class="hljs-keyword">return</span> X;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>下面则是需要进行数学公式推导了，如果存在一个符合要求的字符串<code>X</code>，那么一定存在一个符合要求的字符串<code>X&#39;</code>，长度是<code>str1</code>和<code>str2</code>的最大公约数<br>因为$X$经过$\frac{len1}{lenz}$次拼接后得到了<code>str1</code>，$X$又能经过$\frac{gcd(len1,len2)}{lenz}$次拼接后得到长度为$gcd(len1,len2)$的前缀串$X’$，所以可以替换，最终<code>str1</code>会被替换成$\frac{len1}{gcd(len1,len2)}$个$X’$，<code>str2</code>同理<br>所以只需要判断长度为$gcd(len1,len2)$的前缀串是否满足要求即可<br>代码如下，先求出最大公约数的长度，然后检测最小前缀子串能不能构成最大公约数子串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(string t,string s)</span></span>&#123;<br>        <span class="hljs-type">int</span> lenx = (<span class="hljs-type">int</span>)s.<span class="hljs-built_in">length</span>() / (<span class="hljs-type">int</span>)t.<span class="hljs-built_in">length</span>();<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= lenx; ++i)&#123;<br>            ans = ans + t;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == s;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">gcdOfStrings</span><span class="hljs-params">(string str1, string str2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len1 = (<span class="hljs-type">int</span>)str<span class="hljs-number">1.l</span>ength(), len2 = (<span class="hljs-type">int</span>)str<span class="hljs-number">2.l</span>ength();<br>        string T = str<span class="hljs-number">1.</span><span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, __gcd(len1,len2)); <span class="hljs-comment">// __gcd() 为c++自带的求最大公约数的函数</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(T, str1) &amp;&amp; <span class="hljs-built_in">check</span>(T, str2)) <span class="hljs-keyword">return</span> T;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>结论：如果<code>str1</code>和<code>str2</code>拼接后等于<code>str2</code>和<code>str1</code>拼接起来的字符串，那么一定存在符合条件的字符串<code>X</code><br>下面省略证明</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>数字</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode790_多米诺和托米诺平铺</title>
    <link href="/2024/03/08/LeetCode790-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/"/>
    <url>/2024/03/08/LeetCode790-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/</url>
    
    <content type="html"><![CDATA[<p>LeetCode790_多米诺和托米诺平铺</p><span id="more"></span><p>在第$i$列前面的正方形都被瓷砖覆盖，在第$i$列后面的正方形都没有被瓷砖覆盖（$i$从$1$开始计数）。那么第$i$列的正方形有四种被覆盖的情况：</p><ul><li>一个正方形都没有被覆盖，记为状态 $0$；</li><li>只有上方的正方形被覆盖，记为状态 $1$；</li><li>只有下方的正方形被覆盖，记为状态 $2$；</li><li>上下两个正方形都被覆盖，记为状态 $3$。</li></ul><p>使用 $dp[i][s]$ 表示平铺到第 $i$ 列时，各个状态 $s$ 对应的平铺方法数量。考虑第$i-1$ 列和第$i$列正方形，它们之间的状态转移如下图（红色条表示新铺的瓷砖）：<br>![[&#x2F;Assets&#x2F;6ba5da8ab9c35e50460ab797e64505da_MD5.png]]</p><p>初始时 $dp[0][0]&#x3D;0,dp[0][1]&#x3D;0,dp[0][2]&#x3D;0,dp[0][3]&#x3D;1$，对应的状态转移方程（$i&gt;0$）为：<br>$dp[i][0]&#x3D;dp[i−1][3]  \ dp[i][1]&#x3D;dp[i−1][0]+dp[i−1][2] \dp[i][2]&#x3D;dp[i−1][0]+dp[i−1][1] \dp[i][3]&#x3D;dp[i−1][0]+dp[i−1][1]+dp[i−1][2]+dp[i−1][3]$<br>最后平铺到第 $n$ 列时，上下两个正方形都被覆盖的状态 $dp[n][3]$ 对应的平铺方法数量就是总平铺方法数量。</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode918_环形子数组的最大和</title>
    <link href="/2024/03/08/LeetCode918-%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <url>/2024/03/08/LeetCode918-%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>LeetCode918_环形子数组的最大和</p><span id="more"></span><h3 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p>包括两种情况</p><ol><li>子数组在中间</li><li>子数组在两边</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2024/png/25958751/1706325396395-6a5a116a-3bee-4319-b80c-6189b5cb2610.png#averageHue=%23fbfaf8&clientId=u4170f382-8194-4&from=paste&height=216&id=u2u6y&originHeight=431&originWidth=659&originalType=binary&ratio=2&rotation=0&showTitle=false&size=21264&status=done&style=none&taskId=uf290c637-ffb3-4339-8ad8-dde7e74e62a&title=&width=329.5" alt="image.png"><br>情况1：做法和最大子数组和相同，动态规划，$max(now,pre+now)$<br>情况2：固定$j$的位置，找到$0 \sim j-1$前缀和最大的</p><p>代码可以分成两个部分</p><ol><li>从左往右遍历：求最大前缀和数组 + 情况1更新 <code>res</code></li><li>从右往左遍历：求出后缀 + 根据最大前缀和数组更新 <code>res</code></li></ol><h3 id="方法二：取反"><a href="#方法二：取反" class="headerlink" title="方法二：取反"></a>方法二：取反</h3><ol><li>情况1和上面一样</li><li>情况2：实际上就是求出中间的$min$，求出最小的之后，用$sum-min$即可</li></ol>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode149_直线上最多的点数</title>
    <link href="/2024/01/19/LeetCode149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/"/>
    <url>/2024/01/19/LeetCode149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>LeetCode149_直线上最多的点数</p><span id="more"></span><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>怎么记录斜率：$slope &#x3D; \frac{\Delta y}{\Delta x}$，如果$i, j$之间的$slope$ &#x3D; $j, k$之间的$slope$，则这3个点在一条线</li><li>最简化斜率，如$\frac{2}{4} &#x3D; \frac{1}{2}$，除去最大公约数即可，即$mx&#x3D;\frac{\Delta x}{gcd(|\Delta x|, |\Delta y|)}$, $my&#x3D;\frac{\Delta y}{gcd(|\Delta x|, |\Delta y|)}$</li><li>可能出现负数，如$\frac{-1}{2} &#x3D; \frac{1}{-2}$，则规定分子$my$为非负整数</li><li>$mx, my$可能出现0，则$mx&#x3D;0, my&#x3D;1$,$my&#x3D;0, mx&#x3D;1$</li><li>最终得到二元组$(mx, my)$，$x,y$取值$[-10^4, 10^4]$，所以$mx$取值$[-2<em>10^4, 2</em>10^4]$，$my$取值$[0, 2*10^4]$</li><li>即用$val &#x3D; my + (2*10^4+1)*mx$可以表示一个斜率；因为浮点数类型可能精度不够</li></ol><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol><li>点总数量$&lt;&#x3D;2$时，可用一条线串起全部，直接返回点数量</li><li>当枚举到$i$时，只需考虑编号$&gt;i$的点，因为$&lt;i$的已经枚举过了</li><li>找到一条直线连起了超过半数的点时，即可认为该直线是经过点最多的直线</li><li>枚举到$i$，最多只能找到$n-i$个点共线的，则如果最大$k&gt;&#x3D;n-i$，可以直接返回$k$了</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ol><li>$i$枚举循环所有点，$j$枚举循环$i$之后的点，然后对于每一个$(i, j)$计算$val$存到$map$中</li><li>得到每个$i$的$map$中值最大的斜率（也就是经过最多点的线）</li></ol>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode188_买卖股票的最佳时机IV</title>
    <link href="/2024/01/19/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/"/>
    <url>/2024/01/19/LeetCode188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV/</url>
    
    <content type="html"><![CDATA[<p>LeetCode188_买卖股票的最佳时机IV</p><span id="more"></span><p>这道题看了一个状态机DP的题解</p><h3 id="不限交易次数"><a href="#不限交易次数" class="headerlink" title="不限交易次数"></a>不限交易次数</h3><h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h4><p>关键是：第<code>i</code>天，持有&#x2F; 未持有股票的最大利润<br>子问题：第<code>i-1</code>天，持有&#x2F; 未持有股票的最大利润</p><p>定义<code>dfs(i,0)</code>表示第<code>i</code>天结束时，未持有股票的最大利润<br>定义<code>dfs(i,1)</code>表示第<code>i</code>天结束时，持有股票的最大利润<br>![[&#x2F;Assets&#x2F;adf3b8dd1ad85968a2fd7110ec7ff099_MD5.png]]</p><ol><li>递归式子</li></ol><p>$$dfs(i,0)&#x3D;max(dfs(i-1,0),dfs(i-1,1)+prices[i]) \<br>dfs(i,1)&#x3D;max(dfs(i-1,1),dfs(i-1,0)-prices[i])$$</p><ol start="2"><li>递归边界</li></ol><p>第$0$天开始未持有股票，利润为$0$ $dfs(-1,0)&#x3D;0$<br>第$0$天开始不可能持有股票  $dfs(-1,1)&#x3D;-\infty$</p><ol start="3"><li>递归入口</li></ol><p>$dfs(n-1, 0)$：因为持有股票$&lt;$不持有股票</p><blockquote><p>递推可以由递归得到 <code>f[i][0]</code>和<code>f[i][1]</code></p></blockquote><h4 id="309-买卖股票的最佳时机含冷冻期"><a href="#309-买卖股票的最佳时机含冷冻期" class="headerlink" title="309. 买卖股票的最佳时机含冷冻期"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 买卖股票的最佳时机含冷冻期</a></h4><p>因为买入的时候不能从前一天获得，所以直接改成<code>i-2</code>即可<br>![[&#x2F;Assets&#x2F;31149733ba10e074964e1cf950142ca6_MD5.png]]</p><h3 id="限制交易次数"><a href="#限制交易次数" class="headerlink" title="限制交易次数"></a>限制交易次数</h3><p>【至多&#x2F; 正好&#x2F; 至少】交易<code>k</code>次<br>多了一个<code>j</code>来记录交易次数</p><h4 id="至多-123-买卖股票的最佳时机-III"><a href="#至多-123-买卖股票的最佳时机-III" class="headerlink" title="至多 123. 买卖股票的最佳时机 III"></a>至多 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h4><p>![[&#x2F;Assets&#x2F;71e2035fd712ac2ed031c7e3626b3213_MD5.png]]</p><ol><li>递归式子</li></ol><p>$$dfs(i,j,0)&#x3D;max(dfs(i-1,j,0),dfs(i-1,j,1)+prices[i]) \<br>dfs(i,j,1)&#x3D;max(dfs(i-1,j,1),dfs(i-1,j-1,0)-prices[i])$$</p><ol start="2"><li>递归边界</li></ol><p>任何情况下，$j$都不能为负 $dfs(.,-1,.)&#x3D;- \infty$<br>第$0$天开始未持有股票，利润为$0$ $dfs(-1,j,0)&#x3D;0$<br>第$0$天开始不可能持有股票  $dfs(-1,j,1)&#x3D;-\infty$</p><ol start="3"><li>递归入口</li></ol><p>$dfs(n-1,k,0)$：因为持有股票$&lt;$不持有股票<br>:::info<br>递推可以由递归得到 <code>f[i][j][0]</code>和<code>f[i][j][1]</code><br>:::</p><h4 id="恰好"><a href="#恰好" class="headerlink" title="恰好"></a>恰好</h4><p>$f[0][1][0]&#x3D;0$，其余$&#x3D; - \infty$；只有$f[0][1]$才是恰好完成$0$次的状态</p><h4 id="至少"><a href="#至少" class="headerlink" title="至少"></a>至少</h4><p>$f[i][-1][.]$等价于$f[i][0][.]$，所以每个$f[i]$最前面不需要插入状态<br>至少$0$次 &#x3D; 可以无限次交易，所以$f[i][0][.]$就是无限次交易下的最大利润，如下<br>$f[0][0][0]&#x3D;0$，其余$&#x3D;-\infty$<br>$f[i+1][0][0]&#x3D;max(f[i][0][0],f[i][0][1]+prices[i])$<br>$f[i+1][0][1]&#x3D;max(f[i][0][1],f[i][0][0]-prices[i])$</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode127_单词接龙</title>
    <link href="/2024/01/17/LeetCode127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
    <url>/2024/01/17/LeetCode127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</url>
    
    <content type="html"><![CDATA[<p>LeetCode127_单词接龙</p><span id="more"></span><h3 id="思路理解"><a href="#思路理解" class="headerlink" title="思路理解"></a>思路理解</h3><ul><li>因为是求<strong>最短</strong>序列的长度 -&gt; 广度优先搜索 -&gt; 图</li><li>把每个单词都抽象成一个点；如果两个单词只需要改变一个字母即可转换，则有双向边</li></ul><p><img src="/Assets/1705465503305-d75a019b-b7ee-4c22-b154-043d76c9557d.png" alt="img"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ol><li><p><code>queue</code>记录广度优先搜索到的点 <code>queue&lt;string&gt;</code></p></li><li><p><code>map</code>记录起点到该点的路径长度 <code>map&lt;string, int&gt;</code></p></li><li><p>对于每个出来的点，例如<code>Hot</code>字符串</p></li><li><ol><li>双重遍历（遍历每个字符+每个字符遍历<code>a-z</code>）</li><li>查找字典列表中是否存在且未被访问过</li></ol></li><li><ol><li><ol><li>未被访问过则加入队列中</li><li>正好等于终点则返回结果</li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>字符串</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode124_二叉树中的最大路径和</title>
    <link href="/2024/01/16/LeetCode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2024/01/16/LeetCode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>LeetCode124_二叉树中的最大路径和</p><span id="more"></span><ol><li>对于一个节点，<strong>最大路径</strong> &#x3D; left + right + 自己本身val</li><li>left 和 right代表<strong>最大贡献值</strong>；则一个节点的最大贡献值 &#x3D; max(left, right) + 自己本身val</li><li>所以从下到上求出每个节点的最大贡献值；从而求出每个节点最大路径；从而更新全局最大路径</li></ol><p>下面是求最大贡献值的图解：</p><p><img src="/Assets/1705368582101-e447091a-e9c1-4235-8093-642727d3bd7b.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode48_旋转图像</title>
    <link href="/2024/01/09/LeetCode48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <url>/2024/01/09/LeetCode48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<p>LeetCode48_旋转图像</p><span id="more"></span><p>这题主要是用数学推导，然后遍历即可</p><p>每一次遍历，即是一次位置转换；</p><p>遍历的范围也是左上角，行是<code>n/2</code>，列是<code>(n+1)/2</code></p><p><img src="/Assets/1704777118507-441e7d23-5aaa-480d-9bfd-75e36c936a14.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>数学</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode30_串联所有单词的子串</title>
    <link href="/2024/01/08/LeetCode30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
    <url>/2024/01/08/LeetCode30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p>LeetCode30_串联所有单词的子串</p><span id="more"></span><p>这道题有两重循环；</p><p>第一重循环是起始划分单词位置 <code>i</code>循环</p><p>第二重循环是确定<code>i</code>后，滑动窗口遍历的<code>start</code>循环</p><p>下图是一个例子：</p><p><img src="/Assets/1704697660138-4609c75c-22c6-4e77-b8db-ff5001a1acdf.png" alt="img"></p><ol><li>对于<code>i</code>的循环，注意根据<code>words</code>中每个单词的长度<code>n</code>判断 和 是否超过边界的判断</li><li>对于<code>start</code>的循环，可以采用<code>hash</code>的方式</li></ol>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>字符串</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode105_从前序与中序遍历序列构造二叉树</title>
    <link href="/2023/12/11/LeetCode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/12/11/LeetCode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>LeetCode105_从前序与中序遍历序列构造二叉树</p><span id="more"></span><p>前序遍历：【根节点 | 左子树 | 右子树】</p><p>中序遍历：【左子树 | 根节点 | 右子树】</p><p>可按照以下步骤：</p><ol><li>前序遍历的首元素 为 树的根节点 node 的值</li><li>在中序遍历中搜索根节点 node 的索引 ，可将 中序遍历 划分为 [ 左子树 | 根节点 | 右子树 ] </li><li>根据中序遍历中的左（右）子树的节点数量，可将 前序遍历 划分为 [ 根节点 | 左子树 | 右子树 ]</li></ol><p><img src="/$%7Bfilename%7D/Picture1.png" alt="Picture1.png"></p><p>可确定 <strong>三个节点</strong> ：1.树的根节点、2.左子树根节点、3.右子树根节点</p><p>然后继续分治；对左右子树继续确定根节点 &amp; 左子树根节点 &amp; 右子树根节点</p><p>这个只适用于树中每个值都互相不相等，因为是依靠值-值下标来确定的；由于中间是按照中序遍历根节点的位置，确定左右子树的数量，进而根据前序遍历确定左右子树根节点，进而递归</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode240_搜索二维矩阵II</title>
    <link href="/2023/11/29/LeetCode240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II/"/>
    <url>/2023/11/29/LeetCode240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II/</url>
    
    <content type="html"><![CDATA[<p>LeetCode240_搜索二维矩阵II</p><span id="more"></span><p>这道题是从上到下，从左到右数值增加，如果把数组旋转的话，可以看成是二叉搜索树，如下图所示，以7（右上角）或者3（左下角）作为根节点来进行搜索都是可以的：</p><p><img src="/Assets/image-1.png" alt="image">如果以3作为根节点来进行搜索的话，有以下步骤：</p><ol><li>target值比当前大，则向左，行数减小</li><li>target值比当前小，则向右，列数增加</li><li>target值等于当前，则找到，返回true</li><li>如果行数 or 列数超过限制，则返回false</li></ol>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode41_缺失的第一个正数</title>
    <link href="/2023/11/29/LeetCode41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
    <url>/2023/11/29/LeetCode41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>LeetCode41_缺失的第一个正数</p><span id="more"></span><p>这道题难点在时间复杂度是O(n)，空间复杂度是O(1)，因此可以用原地Hash。</p><p>原地Hash的意思就是当前数组充当Hash数组，当前数组下标0则对应数字1，1对应2，类推，下面是题解：</p><p><img src="/Assets/image.png" alt="image">因此第一遍遍历就是调整交换，尽可能将该数组所有位置上的数放在其应有的位置上</p><p>第二遍遍历就是从前往后遍历，第一个出现不是在该位置上的，九四缺失的第一个正数</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode42_接雨水</title>
    <link href="/2023/11/26/LeetCode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <url>/2023/11/26/LeetCode42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<p>LeetCode42_接雨水</p><span id="more"></span><h3 id="双指针优化解法"><a href="#双指针优化解法" class="headerlink" title="双指针优化解法"></a>双指针优化解法</h3><p>首先搞清楚是横向求还是纵向求：</p><p><img src="/Assets/20210402091208445.png" alt="纵向求"></p><p>如果纵向求，则只需要遍历每一列，并且第一个柱子和最后一个不接雨水： 对于每一列，<code>min(lHeight, rHeight) - height</code></p><p>然而超时，所以用双指针优化，对于这一组数据，左边和右边最高高度用数组来记录：<code>maxLeft[i] = max(height[i], maxLeft[i - 1]); maxRight[i] = max(height[i], maxRight[i + 1]);</code> 最后只需要遍历一遍计算即可</p><h3 id="单调栈解法"><a href="#单调栈解法" class="headerlink" title="单调栈解法"></a>单调栈解法</h3><p><img src="/Assets/20210402091118927.png" alt="横向求"></p><p>单调栈作用就是求左边 or 右边 最大 or 最小元素；单调栈则是采用的用行来计算雨水，添加元素 &gt; 栈顶元素，则代表出现凹槽，则代表要积累雨水了</p><p>这个单调栈从栈头到栈底应该是从小到大的；栈头第一个代表凹槽底部元素；第二个代表凹槽左边柱子；添加元素代表凹槽右边柱子</p><p>栈内保存柱子下标即可，因为要算宽度，高度根据数组获取即可</p><p>从左到右遍历，分成三种情况：</p><ul><li>情况一：当前遍历的元素（柱子）高度小于栈顶元素的高度 <code>height[i] &lt; height[st.top()]</code>，直接入栈</li><li>情况二：当前遍历的元素（柱子）高度等于栈顶元素的高度 <code>height[i] == height[st.top()]</code>，需要弹出顶部再入栈（因为左边需要计算最右边的宽度） - 但是可以忽略这个情况，遍历来看是对的</li><li>情况三：当前遍历的元素（柱子）高度大于栈顶元素的高度 <code>height[i] &gt; height[st.top()]</code>，则需要计算积水面积了，</li></ul><p>单调栈的思路比较难理解，但是如果遍历来看，其实是对的</p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode15_三数之和</title>
    <link href="/2023/11/26/LeetCode15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2023/11/26/LeetCode15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<p>LeetCode15_三数之和</p><span id="more"></span><p>这题是用排序+双指针</p><p>双指针思路大概如下：</p><ol><li>固定一个指针 <code>i</code></li><li>左指针 <code>j</code> 为 <code>i+1</code></li><li>右指针 <code>k</code> 为 数组结尾</li><li><code>nums[i] + nums[j] + nums[k]</code>，逐步移动 <code>j</code> 和 <code>k</code> 即可</li></ol><p>但是题目要求不能去重，所以应该有 <code>nums[i] != nums[i - 1]</code>；以及 j 和 k 指针所指向的也不能重复，所以有</p><ol><li><code>nums[i] != nums[i - 1]</code></li><li><code>nums[right] != nums[right - 1]</code></li><li><code>nums[left] != nums[left + 1]</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2023/11/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2023/11/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>动态规划</p><span id="more"></span><p>动态规划5步曲：</p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><p>问题分类：</p><ol><li>背包问题</li><li>劫舍系列</li><li>股票系列</li><li>子序列问题</li><li>编辑距离问题</li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode376_摆动序列</title>
    <link href="/2023/11/14/LeetCode376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/"/>
    <url>/2023/11/14/LeetCode376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>LeetCode376_摆动序列</p><span id="more"></span><p>本题可以用贪心或者动态规划，甚至动态规划看上去好做一点（线段树），但是这里用贪心做法</p><p><img src="/Assets/20201124174327597.png" alt="376.摆动序列"></p><p>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。</p><p>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。</p><p>实际上：需要求出峰值的数量即可，让峰值尽量保持峰值，删除单一坡上的结点；用代码表示即计算<code>prediff（nums[i] - nums[i-1]）</code> 和 <code>curdiff（nums[i+1] - nums[i]）</code>；如果<code>prediff&gt;0&amp;&amp;curdiff&lt;0</code>或者<code>prediff&lt;0&amp;&amp;curdiff&gt;0</code>，则需要统计</p><p>但是还需要考虑3种情况：</p><ol><li><p>上下坡中有平坡，则条件应该改为<code>(preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0)</code></p><p><img src="/Assets/20230106170449-20231114103006955.png" alt="img"></p></li><li><p>数组首尾两端，如果序列中只有两个数，则就需要考虑数组最左边和最右边的情况了，比如下面这种，因此<code>prediff = 0 ，curdiff &lt; 0</code> 或者 <code>&gt;0</code> 也记为波谷</p><p><img src="/Assets/20201124174357612.png" alt="376.摆动序列1"></p></li><li><p>单调坡中有平坡，如图是<code>prediff</code>更新时间的问题</p><p><img src="/Assets/20230108171505.png" alt="img"></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2023/11/13/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2023/11/13/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>二叉树</p><span id="more"></span><p>![[&#x2F;Assets&#x2F;image-20240401150543097.png]]</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>树图算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法</title>
    <link href="/2023/11/12/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2023/11/12/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>回溯算法</p><span id="more"></span><h3 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h3><p>所有的回溯法都可以变成树结构</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>一般来说，组合和排列是取叶子结点，子集问题是取全部结点</p><p>子集问题分析：</p><ul><li>时间复杂度：$O(2^n)$，因为每一个元素的状态无外乎取与不取，所以时间复杂度为$O(2^n)$</li><li>空间复杂度：$O(n)$，递归深度为n，所以系统栈所用空间为$O(n)$，每一层递归所用的空间都是常数级别，注意代码里的<code>result</code>和<code>path</code>都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为$O(n)$</li></ul><p>排列问题分析：</p><ul><li>时间复杂度：$O(n!)$，这个可以从排列的树形图中很明显发现，每一层节点为$n$，第二层每一个分支都延伸了$n-1$个分支，再往下又是$n-2$个分支，所以一直到叶子节点一共就是 $n * n-1 * n-2 * ….. 1 &#x3D; n!$</li><li>空间复杂度：$O(n)$，和子集问题同理。</li></ul><p>组合问题分析：</p><ul><li>时间复杂度：$O(2^n)$，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。</li><li>空间复杂度：$O(n)$，和子集问题同理。</li></ul><p>N皇后问题分析：</p><ul><li>时间复杂度：O(n!) ，其实如果看树形图的话，直觉上是$O(n^n)$，但皇后之间不能见面所以在搜索的过程中是有剪枝的，最差也就是$O（n!）$，$n!$表示$n * (n-1) * …. * 1。$</li><li>空间复杂度：O(n)，和子集问题同理。</li></ul><p>解数独问题分析：</p><ul><li>时间复杂度：O(9^m) , m是’.’的数目。</li><li>空间复杂度：O(n^2)，递归的深度是n^2</li></ul><h3 id="回溯方法"><a href="#回溯方法" class="headerlink" title="回溯方法"></a>回溯方法</h3><ol><li>回溯函数模板返回值以及参数</li><li>回溯函数终止条件</li><li>回溯搜索的遍历过程</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(参数)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        存放结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h3><blockquote><p>LeetCode77. 组合</p></blockquote><p><img src="/Assets/20201123195223940.png" alt="77.组合"></p><p><img src="/Assets/20201123195242899.png" alt="77.组合1"></p><p>直接可以代入上面的代码模版；横向遍历就是遍历index，纵向遍历就是调用自己，遇到叶子结点就是一个结果</p><p><img src="/Assets/20210130194335207-20230310134409532.png" alt="77.组合4"></p><p>上图是剪枝优化的问题，如果n&#x3D;4, k&#x3D;4的话，那么被叉掉的代表凑不够4个数了，所以可以不用递归遍历了</p><blockquote><p>LeetCode216. 组合总和 III</p></blockquote><p><img src="/Assets/20201123195717975.png" alt="216.组合总和III"></p><p>这道题就是9为宽度，k为深度，约束自己条件是n</p><blockquote><p>LeetCode17. 电话号码的字母组合</p></blockquote><p>这道题尝试自己画一下图</p><p><img src="/Assets/image-20231112132238565.png" alt="17. 电话号码的字母组合"></p><p>大概深度是数字个数；每个数字对应的字母是宽度</p><blockquote><p>LeetCode39. 组合总和</p></blockquote><p><img src="/Assets/20201223170730367.png" alt="39.组合总和"></p><p>这道题其实和17组合一样，但是是无限取，所以递归没有层数的要求，只要target满足，就直接返回（相当于纵向遍历可以改变）</p><blockquote><p>LeetCode40. 组合总和II</p></blockquote><p><img src="/Assets/20221021163812.png" alt="40. 组合总和II"></p><p>这道题难点在于去重；这里表示的是同一层的去重，而不是同一个树枝的去重；</p><ol><li>这里需要说明一下，为什么 used[i - 1] &#x3D;&#x3D; false 就是同一树层呢：因为同一树层，used[i - 1] &#x3D;&#x3D; false 才能表示，当前取的 candidates[i] 是从 candidates[i - 1] 回溯而来的。</li><li>而 used[i - 1] &#x3D;&#x3D; true，说明是进入下一层递归，去下一个数，所以是树枝上</li></ol><blockquote><p>LeetCode131.分割回文串</p></blockquote><p><img src="/Assets/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg" alt="131.分割回文串"></p><p>其实很难把切割回文串和组合问题放在一起；但是可以以切割的位置作为递归的条件；</p><ol><li>纵向就是剩余切割的位置，横向就是最开始切割的位置；</li><li>当切割的位置在最后的时候，则可以输出一个结果</li><li>中间切割的过程中，出现任何一个不是回文串都可以放弃这条分支</li><li>之类还有一个判断回文的算法（用双指针法）</li></ol><blockquote><p>LeetCode93. 复原 IP 地址</p></blockquote><p><img src="/Assets/20201123203735933.png" alt="93.复原IP地址"></p><ol><li>本题和上一题分割字符串的题目很像，只是结束条件不一样。本题的结束条件是分割的份数（需要有3个分割线，分割成4份）+ 分割结束的结果是符合条件的</li><li>还有一个判断段位是否合法的函数；有以下几点<ul><li>段位以0为开头的数字不合法</li><li>段位里有非正整数字符不合法</li><li>段位如果大于255了不合法</li></ul></li></ol><blockquote><p>LeetCode78.子集</p></blockquote><p><img src="/Assets/78.%E5%AD%90%E9%9B%86.png" alt="78.子集"></p><p>子集问题和之前不一样在于：之前都是找叶子结点，该问题是找全部结点；该问题也不需要任何剪枝，因为就是遍历整棵树</p><blockquote><p>LeetCode90. 子集 II</p></blockquote><p>这题和上一题的区别在于，给定的集合中是有重复元素的。但是选出来的子集又不能有重复的；所以就是树枝去重和树层去重需要弄懂，这个即LeetCode40. 组合总和II题思路一样</p><p><img src="/Assets/20201124195411977.png" alt="90.子集II"></p><p>在LeetCode78.子集这题的思路上加上了去重的工作</p><blockquote><p>LeetCode491.递增子序列</p></blockquote><p><img src="/Assets/20201124200229824-20230310131640070.png" alt="491. 递增子序列1"></p><p>这道题一开始思路很容易想成上一题的子集，因为有去重然后有子集，只不过是需要递增而已；但是不能这样，因为原数组的顺序不能改变，所以不能先排序</p><ol><li>单层不重复的逻辑：当前元素和startIndex后前面的元素有没有重复的</li><li>以及因为子集必须是&gt;2的，所以需要在path进入result的时候判断一下</li></ol><h3 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h3><blockquote><p>LeetCode46. 全排列</p></blockquote><p><img src="/Assets/20201209174225145.png" alt="46.全排列"></p><ol><li>递归需要一个used数组来判断是否使用过；不需要startIndex了(因为元素还是要重复使用的)</li><li>递归终止条件还是到达了叶子结点</li></ol><blockquote><p>LeetCode47. 全排列 II</p></blockquote><p>和46题的区别在于给的集合是重复的，所以取出子集的时候也会有重复的，这时候就需要去重；去重还是先排序，才能通过相邻结点看是否重复了，和之前去重的思路一样</p><p><img src="/Assets/20201124201406192.png" alt="47.全排列II2"></p><p>另外很奇妙的是这道题树枝去重和树层去重都是可以的，但是树层上去重效率更高</p><p>树层上去重(used[i - 1] &#x3D;&#x3D; false)，的树形结构如下：</p><p><img src="/Assets/20201112172230434-20230310133211392.png" alt="47.全排列II2.png"></p><p>树枝上去重（used[i - 1] &#x3D;&#x3D; true）的树型结构如下：</p><p><img src="/Assets/20201112172327967-20230310133216389.png" alt="47.全排列II3"></p><h3 id="图论问题"><a href="#图论问题" class="headerlink" title="图论问题"></a>图论问题</h3><blockquote><p>LeetCode332. 重新安排行程</p></blockquote><p>这道题是一道hard题，感觉是用图论的深度优先搜索，但是也可以用回溯法来做；</p><ol><li>只需要找到一个行程，树形结构中唯一通向叶子结点的路线，所以函数返回值是bool</li><li>递归终止条件就是遇到的机场数量&#x3D;航班数量+1</li><li>在单层搜索的时候，因为要遍历一个机场所对应的所有机场，还要容易删除增删元素（因为需要避免重复），所以用<code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code>来做映射，直接用<code>int</code>字段来判断这个集合中机场是否使用过</li></ol><p><img src="/Assets/2020111518065555-20230310121240991.png" alt="332.重新安排行程1"></p><h3 id="棋盘问题"><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h3><blockquote><p>LeetCode51. N 皇后</p></blockquote><ol><li>深度就是当前棋盘遍历的行数</li><li>终止条件就是遍历到最底下一行了</li><li>单层搜索逻辑就是一列列试，直到找到符合条件的<ol><li>不能同行</li><li>不能同列</li><li>不能同斜线 （45度和135度角）</li></ol></li></ol><p><img src="/Assets/20210130182532303.jpg" alt="51.N皇后"></p><blockquote><p>LeetCode37. 解数独</p></blockquote><ol><li>解数独仅有一个解，所以用bool来返回</li><li>这是一个二维的递归，遍历行和列</li><li>判断棋盘是否合法<ol><li>同行是否重复</li><li>同列是否重复</li><li>9宫格里是否重复</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>搜索算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode142_环形链表II</title>
    <link href="/2023/10/31/LeetCode142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/"/>
    <url>/2023/10/31/LeetCode142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/</url>
    
    <content type="html"><![CDATA[<p> LeetCode142_环形链表II</p><span id="more"></span><ol><li>怎么看是否有环：采用快慢指针，总会相遇</li><li>怎么看环形入口：采用数学公式计算<ol><li>在相遇点时，slow指针走过$x+y$；fast指针走过$x+y+n(y+z)$</li><li>fast指针是slow指针走的两倍：$(x + y) * 2 &#x3D; x + y + n (y + z)$，得到$x &#x3D; (n - 1) (y + z) + z$</li><li>当$n&#x3D;1$时，即fast指针在环内走了一圈后遇到了slow指针；即fast指针在相遇点出发和slow指针在起点出发，都走一步，能在入口点相遇；$n$为其他也是一样，只不过fast多走了几圈</li></ol></li></ol><p><img src="/Assets/image-20231031142843652.png" alt="示例"></p>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing845_八数码</title>
    <link href="/2023/10/17/AcWing845-%E5%85%AB%E6%95%B0%E7%A0%81/"/>
    <url>/2023/10/17/AcWing845-%E5%85%AB%E6%95%B0%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>AcWing845_八数码</p><span id="more"></span><p>理解题意，假如处于下面这个状态，则3种可能转移方案，就是向上下左右转移</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>X <span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">X</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span><span class="hljs-number">4</span> X <span class="hljs-number">6</span><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span><span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">7</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span><span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span><span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span>X <span class="hljs-number">5</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>BFS求的时候需要定义两个数据结构</p><ol><li>队列 queue</li><li>记录每个状态的距离 dist</li></ol><p>难点</p><ol><li><p>状态怎么表示-用字符串来表示：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">6</span>可表示为 <span class="hljs-string">&quot;1234567X8&quot;</span><br><span class="hljs-symbol">7 </span>X <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure></li><li><p>如果记录每个状态的距离</p><ol><li>恢复成 3 * 3的矩阵</li><li>转移，可以上下左右移动</li><li>将矩阵恢复成字符串</li></ol></li><li><p>当当前状态 &#x3D;&#x3D; “12345678X”时，则代表转移完成</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>AcWing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing843_n皇后问题</title>
    <link href="/2023/10/17/AcWing843-n-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <url>/2023/10/17/AcWing843-n-%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>AcWing843_n-皇后问题</p><span id="more"></span><ol><li>该问题可以用排列数来做，但是需要进行剪枝操作</li><li>或者用子集树来做，对于每一个格子进行枚举，可以选择放&#x2F;不放</li></ol><p><img src="/Assets/image-20230918202610470.png" alt="n皇后示例"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// s代表当前层数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (y == n) y = <span class="hljs-number">0</span>, x++;<br>    <span class="hljs-keyword">if</span> (x = n)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (s == n)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">puts</span>(g[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//不放皇后</span><br>    <span class="hljs-built_in">dfs</span>(x, y + <span class="hljs-number">1</span>, s);<br>    <span class="hljs-comment">//放皇后</span><br>    <span class="hljs-keyword">if</span> (!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n])<br>    &#123;<br>        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(x, y + <span class="hljs-number">1</span>, s + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 恢复现场</span><br>        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>AcWing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing842_排列数字</title>
    <link href="/2023/10/17/AcWing842-%E6%8E%92%E5%88%97%E6%95%B0%E5%AD%97/"/>
    <url>/2023/10/17/AcWing842-%E6%8E%92%E5%88%97%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>AcWing842_排列数字</p><span id="more"></span><p><img src="/Assets/image-20230918143244650.png" alt="排列数字示例"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// u代表当前层数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (u == n)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cout &lt;&lt; path[i];<br>    &#125;<br>    <span class="hljs-comment">// 对于每个数进行遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-comment">// 该数没有被用过</span><br>        <span class="hljs-keyword">if</span> (!st[i])<br>        &#123;<br>            path[u] = i;<br>            st[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 一般会做剪枝操作，进入dfs需要条件</span><br>            <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 恢复现场</span><br>            st[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>AcWing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AcWing240_食物链</title>
    <link href="/2023/10/16/AcWing240-%E9%A3%9F%E7%89%A9%E9%93%BE/"/>
    <url>/2023/10/16/AcWing240-%E9%A3%9F%E7%89%A9%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>AcWing240_食物链</p><span id="more"></span><p><img src="/Assets/image-20231016120958035.png" alt="示例"></p><p>到根结点的距离有3种情况：</p><ol><li>余1：可以吃根结点</li><li>余2：可以被根结点吃</li><li>余0：与根结点是同类</li></ol><p><img src="/Assets/image-20231016121028187.png" alt="示例"></p><p>每个结点存储的是到他父节点的距离，因此需要遍历更新成到根结点的距离（路径压缩）：<code>d[i]</code>的意义是第<code>i</code>个结点到其父结点的距离；在<code>find[]</code>函数的过程中，则会更新为到父节点的距离</p><p><img src="/Assets/image-20231016121632957.png" alt="合并"></p><p>合并操作(<code>dx!=dy</code>)时，将<code>x</code>的父节点指向<code>y</code>的父节点：</p><ol><li>$x$和$y$同一类，则有$(d[x]+?)% 3&#x3D;d[y]%3$，有$?&#x3D;d[y]-d[x]$</li><li>$x$是吃$y$，则有$(d[x]+?)% 3&#x3D;d[y]%3+1$，有$?&#x3D;d[y]-d[x]+1$</li></ol><p>判断操作(<code>dx==dy</code>)时，则</p><ol><li>$x$和$y$同一类，则有$d[x]% 3&#x3D;d[y]%3$</li><li>$x$是吃$y$，则有$d[x]% 3&#x3D;d[y]%3+1$</li></ol>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>AcWing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jetbrains全家桶</title>
    <link href="/2023/10/12/Jetbrains%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    <url>/2023/10/12/Jetbrains%E5%85%A8%E5%AE%B6%E6%A1%B6/</url>
    
    <content type="html"><![CDATA[<p>JetBrains全家桶</p><span id="more"></span><h3 id="Clion"><a href="#Clion" class="headerlink" title="Clion"></a>Clion</h3><ol><li>监视数组全部元素：<code>*(int(\*)[10])(q)</code></li><li>Clion的windows不支持文件夹有中文，需全部改成英文；mac可以</li><li>Clion找不到<code>&lt;bits/stdc++.h&gt;</code>，应该是更新版本了，<code>/Library/Developer/CommandLineTools/SDKs</code>，直接不断点入，然后在<code>include</code>文件夹下添加即可</li></ol><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span>+D           复制<br>option+<span class="hljs-built_in">command</span>+L    代码规格<br>option+回车          代码错误<br><span class="hljs-built_in">shift</span> +符号，        查找字符<br>control+R           运行<br><span class="hljs-built_in">shift</span>+F6            批量修改<br><span class="hljs-built_in">shift</span>+回车           在下一行插入<br>option+<span class="hljs-built_in">command</span>+回车  在上一行插入<br><span class="hljs-built_in">command</span>+option+T 环绕，try catch等<br><span class="hljs-built_in">command</span>+7 视图结构<br><span class="hljs-built_in">command</span>+option+<span class="hljs-built_in">shift</span>+U    生成类图<br><span class="hljs-built_in">command</span>+B                 直接到方法跳转<br>按Ctrl+Shift+/            以 /* */ 形式注释代码<br>按ctrl+/                  以  //形式注释代码<br>control + option + o  整理不用的包<br><br></code></pre></td></tr></table></figure><h3 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源"></a>镜像源</h3><p>清华: <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>豆瓣: <a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a><br>阿里: <a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a><br>原始：<a href="https://pypi.python.org/simple/">https://pypi.Python.org/simple/</a></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Jetbrains</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Latex学习</title>
    <link href="/2023/10/11/Latex%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/10/11/Latex%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>下面主要是记录一下Latex常用写法</p><span id="more"></span><h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><table><thead><tr><th>代码</th><th>效果</th><th>长度</th></tr></thead><tbody><tr><td>a \quad b</td><td>$a \quad b$</td><td>1 em</td></tr><tr><td>a \qquad b</td><td>$a \qquad b$</td><td>2 em</td></tr><tr><td>a \enspace b</td><td>$a \enspace b$</td><td>0.5 em</td></tr><tr><td>a ; b</td><td>$a ; b$</td><td>5&#x2F;18 em</td></tr><tr><td>a : b</td><td>$a : b$</td><td>4&#x2F;18 em</td></tr><tr><td>a , b 或 a \thinspace b</td><td>$a , b $</td><td>3&#x2F;18 em</td></tr><tr><td>a ! b 或 a \negthinspace b</td><td>$a ! b $</td><td>- 3&#x2F;18 em</td></tr></tbody></table><h4 id="字母"><a href="#字母" class="headerlink" title="字母"></a>字母</h4><table><thead><tr><th align="left">特征</th><th align="left">语法</th><th align="left">效果</th></tr></thead><tbody><tr><td align="left">大写字母</td><td align="left">\Alpha \Beta \Gamma \Delta \Epsilon \Zeta \Eta\Theta</td><td align="left">$\Alpha \Beta \Gamma \Delta \Epsilon \Zeta \Eta \Theta$</td></tr><tr><td align="left"></td><td align="left">\Iota \Kappa \Lambda \Mu \Nu \Xi \Omicron \Pi</td><td align="left">$\Iota \Kappa \Lambda \Mu \Nu \Xi \Omicron \Pi$</td></tr><tr><td align="left"></td><td align="left">\Rho \Sigma \Tau \Upsilon \Phi \Chi \Psi\Omega</td><td align="left">$\Rho \Sigma \Tau \Upsilon \Phi \Chi \Psi\Omega$</td></tr><tr><td align="left">小写字母</td><td align="left">\alpha \beta \gamma \delta \epsilon \zeta \eta\theta</td><td align="left">$\alpha \beta \gamma \delta \epsilon \zeta \eta\theta$</td></tr><tr><td align="left"></td><td align="left">\iota \kappa\varkappa \lambda \mu \nu \xi \omicron\pi</td><td align="left">$\iota \kappa\varkappa \lambda \mu \nu \xi \omicron\pi$</td></tr><tr><td align="left"></td><td align="left">\rho \sigma \tau \upsilon \phi \chi \psi\omega</td><td align="left">$\rho \sigma \tau \upsilon \phi \chi \psi\omega$</td></tr><tr><td align="left">异体字母</td><td align="left">\Epsilon\epsilon\varepsilon</td><td align="left">$\Epsilon\epsilon\varepsilon$</td></tr><tr><td align="left"></td><td align="left">\Theta\theta\vartheta</td><td align="left">$\Theta\theta\vartheta$</td></tr><tr><td align="left"></td><td align="left">\Kappa\kappa\varkappa</td><td align="left">$\Kappa\kappa\varkappa$</td></tr><tr><td align="left"></td><td align="left">\Pi\pi\varpi</td><td align="left">$\Pi\pi\varpi$</td></tr><tr><td align="left"></td><td align="left">\Rho\rho\varrho</td><td align="left">$\Rho\rho\varrho$</td></tr><tr><td align="left"></td><td align="left">\Sigma\sigma\varsigma</td><td align="left">$\Sigma\sigma\varsigma$</td></tr><tr><td align="left"></td><td align="left">\Phi\phi\varphi</td><td align="left">$\Phi\phi\varphi$</td></tr><tr><td align="left">已停用字母</td><td align="left">\digamma</td><td align="left">$\digamma$</td></tr></tbody></table><table><thead><tr><th>名称</th><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>粗体</td><td>\boldsymbol{\Alpha  \Beta}</td><td>$\boldsymbol{\Alpha  \Beta}$</td></tr><tr><td>黑板粗体</td><td>\mathbb{ABC}</td><td>$\mathbb{ABC}$</td></tr><tr><td>正粗体</td><td>\mathbf{ABC}</td><td>$\mathbf{ABC}$</td></tr><tr><td>斜体数字</td><td>\mathit{ABC}</td><td>$\mathit{ABC}$</td></tr><tr><td>罗马体</td><td>\mathrm{ABC}</td><td>$\mathrm{ABC}$</td></tr><tr><td>哥特体</td><td>\mathfrak{ABC}</td><td>$\mathfrak{ABC}$</td></tr><tr><td>手写体</td><td>\mathcal{ABC}</td><td>$\mathcal{ABC}$</td></tr><tr><td>希伯来字母</td><td>\aleph\beth\gimel\daleth</td><td>$\aleph\beth\gimel\daleth$</td></tr></tbody></table><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><ul><li>字体颜色︰<code>&#123;\color&#123;色调&#125;表达式&#125;</code></li><li>背景颜色︰<code>&#123;\pagecolor&#123;色调&#125;表达式&#125;</code></li></ul><table><thead><tr><th>名称</th><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>字体颜色</td><td>\color{Red}x^2</td><td>$\color{Red}x^2$</td></tr></tbody></table><h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h4><table><thead><tr><th>名称</th><th>语法</th><th>效果</th></tr></thead><tbody><tr><td>取整</td><td>\lfloor x \rfloor</td><td>$\lfloor x \rfloor$</td></tr><tr><td></td><td>\lceil x \rceil</td><td>$\lceil x \rceil$</td></tr><tr><td>指数</td><td>\exp_a b &#x3D; a^b, \exp b &#x3D; e^b, 10^m</td><td>$\exp_a b &#x3D; a^b, \exp b &#x3D; e^b, 10^m$</td></tr><tr><td>对数</td><td>\ln c, \lg d &#x3D; \log e, \log_{10} f</td><td>$\ln c, \lg d &#x3D; \log e, \log_{10} f$</td></tr><tr><td>三角函数</td><td>\sin a, \cos b, \tan c, \cot d, \sec e, \csc f</td><td>$\sin a, \cos b, \tan c, \cot d, \sec e, \csc f$</td></tr><tr><td>界限</td><td>\lim_{x \to \infty} \frac{1}{n(n+1)}</td><td>$\lim_{x \to \infty} \frac{1}{n(n+1)}$</td></tr><tr><td>微分及导数</td><td>dt, \mathrm{d}t, \partial t, \nabla\psi</td><td>$dt, \mathrm{d}t, \partial t, \nabla\psi$</td></tr><tr><td></td><td>\prime, \backprime, f^\prime, f’, f’’, f^{(3)}, \dot y, \ddot y</td><td>$\prime, \backprime, f^\prime, f’, f’’, f^{(3)}, \dot y, \ddot y$</td></tr><tr><td>模运算</td><td>s_k \equiv 0 \pmod{m}</td><td>$s_k \equiv 0 \pmod{m}$</td></tr><tr><td>根号</td><td>\surd, \sqrt{2}, \sqrt[n]{}</td><td>$\surd, \sqrt{2}, \sqrt[n]{}$</td></tr><tr><td>运算符</td><td>\pm, \mp, \dotplus</td><td>$\pm, \mp, \dotplus$</td></tr><tr><td></td><td>\times, \div, \divideontimes, &#x2F;, \backslash</td><td>$\times, \div, \divideontimes, &#x2F;, \backslash$</td></tr><tr><td></td><td>\cdot, * \ast, \star, \circ, \bullet</td><td>$\cdot, * \ast, \star, \circ, \bullet$</td></tr><tr><td>集合</td><td>\O, \empty, \emptyset, \varnothing</td><td>$\O, \empty, \emptyset, \varnothing$</td></tr><tr><td></td><td>\in, \notin \not\in, \ni, \not\ni</td><td>$\in, \notin \not\in, \ni, \not\ni$</td></tr><tr><td></td><td>\cap, \Cap, \sqcap, \bigcap</td><td>$\cap, \Cap, \sqcap, \bigcap$</td></tr><tr><td></td><td>\cup, \Cup, \sqcup, \bigcup, \bigsqcup, \uplus, \biguplus</td><td>$\cup, \Cup, \sqcup, \bigcup, \bigsqcup, \uplus, \biguplus$</td></tr><tr><td></td><td>\subset, \Subset, \sqsubset</td><td>$\subset, \Subset, \sqsubset$</td></tr><tr><td></td><td>\supset, \Supset, \sqsupset</td><td>$\supset, \Supset, \sqsupset$</td></tr><tr><td>关系符号</td><td>&#x3D;, \ne, \neq, \equiv, \not\equiv,\geq,\leq</td><td>$&#x3D;, \ne, \neq, \equiv, \not\equiv,\geq,\leq$</td></tr><tr><td>逻辑运算</td><td>\urcorner,\lor,\land,\rightarrow,\leftrightarrow</td><td>$\urcorner,\lor,\land,\rightarrow,\leftrightarrow$</td></tr><tr><td>向量</td><td>\vec {n}</td><td>$\vec {n}$</td></tr><tr><td>括号</td><td>f(x)&#x3D;\begin{cases}0&amp; \text{x&#x3D;0}\1&amp; \text{x!&#x3D;0}\end{cases} \</td><td>$f(x)&#x3D;\begin{cases}0&amp; \text{x&#x3D;0}\1&amp; \text{x!&#x3D;0}\end{cases} \$</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Latex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学问题</title>
    <link href="/2023/10/11/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/"/>
    <url>/2023/10/11/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>质数；约数；欧拉函数；快速幂；中国剩余定理；高斯消元；组合数；容斥原理；博弈论</p><span id="more"></span><h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><p>求$N$内质数个数</p><h3 id="试除法"><a href="#试除法" class="headerlink" title="试除法"></a>试除法</h3><ol><li>$O(sqrt(n))$质数的判定；只需要枚举$i&lt;&#x3D;n&#x2F;i$</li><li>$O(sqrt(n))$分解质因数；$n$当中只包含一个大于$sqrt(n)$的质因数</li></ol><h3 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h3><p>适合求多个$N$的</p><ol><li><p>$1-n$中有$n&#x2F;lnn$个质数</p></li><li><p>埃氏筛法：从头枚举数(只用质数即可)，将他的倍数全部筛除</p><ol><li>如求100以内的素数；只要去到$sqrt(100)$即可；因为$10$的$2$倍已经被$2$去掉了，$3$倍已经被$3$去掉了，只剩下$10$倍以上的还存在</li><li>下面的例子：$2$筛掉$4,6,8,10$；$3$筛掉$9$</li><li>可以发现：只需要筛掉当前$p$值的$k$倍（其中$k$是质数）</li><li><img src="/Assets/image-20231026131901901.png" alt="筛法例子"></li></ol></li><li><p>线性筛法：让其只会被最小的质因子筛一次</p><ol><li>任何一个合数只有一个最小的质因子</li><li>因此任何一个合数只会被筛一次；且仅会被最小质因子筛</li><li>有两种情况<ol><li>$i % pj &#x3D;&#x3D;0$ ；$pj$一定是$i$的最小质因子，$pj$一定是$pj*i$的最小质因子</li><li>$i % pj !&#x3D;0$ ；$pj$一定小于$i$的所有质因子，$pj$一定是pj*i的最小质因子</li></ol></li></ol></li></ol><h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><ol><li><p>求一个数所有的约数</p></li><li><p>约数个数；分解之后个数就是对于每个$p_i^{\alpha_i}$，可以$0-\alpha_i$次<br>$$<br>N&#x3D;p_1^{\alpha_1}<em>p_2^{\alpha_2}…p_k^{\alpha_k} \(\alpha_1+1)</em>(\alpha_2+1)…(\alpha_k+1)<br>$$</p></li><li><p>约数之和；$d$代表其中一个约数，$\beta_i$是在$0-\alpha_i$之间的<br>$$<br>N&#x3D;p_1^{\alpha_1}<em>p_2^{\alpha_2}…p_k^{\alpha_k} \(\alpha_1+1)</em>(\alpha_2+1)…(\alpha_k+1) \<br>d&#x3D;p_1^{\beta_1}<em>p_2^{\beta_2}…p_k^{\beta_k} \<br>d_1+d_2+…+d_i&#x3D;(p_1^0+p_1^1+…p_1^{\alpha_1})</em>(p_2^0+p_2^1+…p_2^{\alpha_2})…*(p_k^0+p_k^1+…p_k^{\alpha_k})<br>$$</p></li><li><p>辗转相除法（欧几里得算法）$a$和$b$的最大公约数&#x3D;$b$和$a, mod,  b$的最大公约数<br>$$<br>(a,b) &#x3D; (b,a \bmod b)<br>$$</p></li><li><p>扩展欧几里德</p><ol><li>裴蜀定理：给定方程，判断是否有解<ol><li>$a,b$互质 ⇔ $gcd(a,b)&#x3D;1$ ⇔ 存在整数$x,y$,使得$ax+by&#x3D;1$；</li><li>可用来判断$ax+by&#x3D;c$是否有解，需要看$c$是否是$gcd(a,b)$的倍数</li></ol></li><li>扩展欧几里德算法：给定方程，求出解【 欧几里德+裴蜀】<ol><li>给定$a,b$可以求$x,y$；下面的做法是讲如何从下一层递归的$x,y$值得到当前层递归的$x,y$值</li><li>$ax+by&#x3D;gcd(a,b)$，$a \bmod b$和$b$的最大公约数也是$d$</li><li>$ax+by&#x3D;gcd(b,a % b)&#x3D;bx_0+(a % b)y_0$</li><li>$a % b&#x3D;a-\lfloor \frac{a}{b} \rfloor * b$，代入到上式</li><li>$ax+by&#x3D;bx_0+(a-\lfloor \frac{a}{b} \rfloor * b)y_0&#x3D;ay_0+b(x_0-\lfloor \frac{a}{b} \rfloor y_0)$</li><li>$x&#x3D;y_0,y&#x3D;x_0-\lfloor \frac{a}{b} \rfloor y_0$</li></ol></li><li>线性同余方程：给定同余方程，求出解 【 扩展欧几里德应用】<ol><li>$ax≡ b(\bmod m)$，给出$a,b,m$，求$x$； ⇔ $ax&#x3D;my+b$，$y$是整数⇔ $ax-my&#x3D;b$</li><li>即$ax≡ b(\bmod m)$有解的充要条件是$b$是$gcd(a,m)$的倍数</li></ol></li></ol></li></ol><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>$\varphi(n)$是$1-n-1$中和$n$互质的个数；例如$varphi(8)&#x3D;4$，因为$1,3,5,7$均和8互质</p><h3 id="公式求"><a href="#公式求" class="headerlink" title="公式求"></a>公式求</h3><p>$$<br>N&#x3D;p_1^{\alpha_1}*p_2^{\alpha_2}…p_k^{\alpha_k}\<br>\varphi(N)&#x3D;N(1-\frac{1}{p_1})(1-\frac{1}{p_2})…(1-\frac{1}{p_k})<br>$$</p><ol><li>从$1-N$中去掉$p1,p2…pk$的所有倍数</li><li>加上所有$pi*pj$的倍数</li><li>减去所有$pi<em>pj</em>pk$的倍数</li><li>加上所有$pi<em>pj</em>pk*pl$的倍数</li><li>$N-\frac{N}{p1}-\frac{N}{p2}-…+\frac{N}{p1p2}+\frac{N}{p2p3}+…-\frac{N}{p1p2p3}-\frac{N}{p2p3p4}+…$</li><li>上面即容斥原理，和欧拉函数展开公式一样</li></ol><h3 id="小小总结"><a href="#小小总结" class="headerlink" title="小小总结"></a>小小总结</h3><ol><li><p>约数个数：只与幂次相关，与质因子无关<br>$180&#x3D;2^2∗3^2∗5$<br>约数个数$&#x3D;(1+2)∗(1+2)∗(1+1)&#x3D;18$</p></li><li><p>约数和：与质数因子和幂次都相关<br>$360&#x3D;2∗2∗2∗3∗3∗5&#x3D;2^3∗3^2∗5^1$<br>约数和$&#x3D;(2^0+2^1+2^2+2^3)∗(3^0+3^1+3^2)∗(5^0+5^1)&#x3D;(1+2+4+8)∗(1+3+9)∗(1+5)&#x3D;15∗13∗6&#x3D;1170$</p></li><li><p>欧拉函数公式，只与因子相关，与指数无关</p><p>$8&#x3D;2^3$</p><p>$\varphi(8)&#x3D;8∗(1−\frac{1}{2})&#x3D;4$</p></li></ol><h3 id="筛法求"><a href="#筛法求" class="headerlink" title="筛法求"></a>筛法求</h3><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><ol><li>若$a$与$n$互质，则$a^{\phi(n)}\equiv1\ (mod \ n)$</li><li>例子：$a&#x3D;5,n&#x3D;6$，则$5^{\varphi(6) }\bmod 6&#x3D;5^2 \bmod 6&#x3D;25 \bmod 6 \equiv 1$</li></ol><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>$a^k \bmod p$，时间复杂度是$O(logk)$</p><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol><li>$k$可以被拆成$logk$个数，即$k&#x3D;2^{x_1}+2^{x_2}+…+2^{x_t}$</li><li>可以先算出来拆出来的$logk$数字$\bmod p$的值</li></ol><p>$$<br>logk\begin{cases}<br>a^{2^0} \bmod p &amp; 2\<br>a^{2^1} \bmod p &amp; (a^{2^0})^2\<br>a^{2^2} \bmod p &amp; (a^{2^1})^2\<br>…\<br>a^{2^{logk}} \bmod p &amp;(a^{2^{logk-1}})^2<br>\end{cases}<br>$$</p><ol start="3"><li>$a^k&#x3D;a^{2^{x_1}+2^{x_2}+…+2^{x_t}}$&#x3D;$a^{2^{x_1}}<em>a^{2^{x_2}}</em>…*a^{2^{x_t}}$</li><li>将每个$a^{2^{x_i}} \bmod p$取出来之后相乘，再$\bmod p$即可得到值</li></ol><h3 id="求逆元"><a href="#求逆元" class="headerlink" title="求逆元"></a>求逆元</h3><p>逆元定义</p><blockquote><p>若整数$b,m$互质，并且$\frac{b}{a}$，则存在一个整数$x$，使得$\frac{a}{b}\equiv a*x(\bmod m)$，则称$x$为$b$的模$m$乘法逆元，记为$b^{-1}(\bmod m)$</p><p>$b$存在乘法逆元的充要条件是$b$与模数$m$互质，当模数$m$为质数时，$b^{m-2}$即为$b$的乘法逆元</p></blockquote><ol><li>给定$b$，找到$x$，使得$b*x \equiv1 (\bmod p)$，其中$p$是质数</li><li>费马定理：如果$b,p$互质，则$b^{p-1} \equiv1 (\bmod p)$，则$b*b^{p-2} \equiv1 (\bmod p)$，则$b^{p-2}$就是$b$的模$m$乘法逆元</li></ol><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>$m1,m2,…,mk$两两互质，则<br>$$<br>\begin{cases}<br>x \equiv a_1 (\bmod m_1) \<br>x \equiv a_2 (\bmod m_2) \<br>… \<br>x \equiv a_k (\bmod m_k)<br>\end{cases}<br>$$<br>$M&#x3D;m_1m_2…m_k$，$M_i&#x3D;\frac{M}{m_i}$，$M^{-1}$表示$M_i$模$m_i$的逆</p><p>$x&#x3D;a_1M_iM_i^{-1}+a_2M_2M_2^{-1}+…+a_kM_kM_k^{-1}$</p><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><p>复杂度是$O(n^3)$<br>$$<br>\begin{cases}<br>a_{11}x_1+a_{12}x_2+…+a_{1n}x_n&#x3D;b_1 \<br>a_{21}x_1+a_{22}x_2+…+a_{2n}x_n&#x3D;b_2 \<br>…\<br>a_{n1}x_1+a_{n2}x_2+…+a_{nn}x_n&#x3D;b_n<br>\end{cases}<br>$$<br>形成一个$n*(n+1)$的矩阵，可以用初等行列变换，变成一个上三角形式</p><ol><li>把某一行乘一个非零的数</li><li>交换某2行</li><li>把某行的若干倍加到另一行上</li></ol><p>$$<br>\begin{cases}<br>a_{11}x_1+a_{12}x_2+ \qquad …\qquad +a_{1n}x_n&#x3D;b_1 \<br>\qquad \quad \enspace a_{12}x_2+ \qquad … \qquad +a_{1n}x_n&#x3D;b_1 \<br>\qquad \quad \enspace \qquad \quad \qquad…\<br>\qquad \quad \enspace \qquad \quad \enspace a_{1n-1}x_{n-1}+a_{1n}x_n&#x3D;b_1 \<br>\qquad \quad \enspace \qquad \quad \enspace \qquad \quad \enspace \qquad  a_{1n}x_n&#x3D;b_1<br>\end{cases}<br>$$</p><p>即从后往前算可得到所有的$x_i$值</p><ol><li>完美阶梯形(有$n$个方程)——唯一解</li><li>左边没有未知数，右边非0——无解</li><li>左边没有未知数，右边0——无穷多解</li></ol><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><ol><li><p>做法1-递推</p><p>公式$C^b_a&#x3D;\frac{a!}{b!(a-b)!}$，$C^b_a&#x3D;C^b_{a-1}+C^{b-1}_{a-1}$，实际意义是在前$a-1$个中选$b$的情况和不选$b$的情况</p></li><li><p>做法2-预处理</p><p>$fact[i]&#x3D;i! \bmod 10^9 +7$</p><p>$infact[i]&#x3D;(i!)^{-1} \bmod 10^9 +7$ 逆元</p><p>$C^b_a&#x3D;fact[a]*infact[b-a]*infact[b]$</p></li><li><p>做法3-卢卡斯定理</p><p>$C_a^b \equiv C_{a \bmod p}^{b \bmod p}*C_{a &#x2F; p}^{b &#x2F; p} (\bmod p)$</p></li><li><p>做法4-分解质因数</p><ol><li>值$&#x3D;p_1^{\alpha_1}*p_2^{\alpha_2}…p_k^{\alpha_k}$，然后用大数乘法</li><li>$C^b_a&#x3D;\frac{a!}{b!(a-b)!}$可以求上下分别有多少个$p_1,p_2…p_k$</li><li>如$a!&#x3D;\lfloor \frac{a}{p} \rfloor + \lfloor \frac{a}{p^2} \rfloor + \lfloor \frac{a}{p^3} \rfloor + …$</li></ol></li></ol><h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p>韦恩图</p><ol><li>如果是4个，则公式为$S_1+S_2+S_3+S_4-S_1 \bigcap S_2 - S_1 \bigcap S_3 - S_1 \bigcap S_4-S_2 \bigcap S_3-S_2 \bigcap S_4- S_3 \bigcap S_4 + S_1 \bigcap S_2 \bigcap S_3 + S_1 \bigcap S_2 \bigcap S_4 +S_2 \bigcap S_3 \bigcap S_4 - S_1 \bigcap S_2 \bigcap S_3 \bigcap S_4$</li><li>性质：<ol><li>总共有$C_n^1+C_n^2+C_n^3+…+C_n^n$项</li><li>$C_n^0+C_n^1+C_n^2+C_n^3+…+C_n^n$代表从$n$当中选择任意个数的方案数，所以$&#x3D;2^n$</li><li>则共有$2^n-C_n^0&#x3D;2^n-1$项；时间复杂度是$2^n$</li></ol></li></ol><h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2><ol><li>先手必胜状态：可以走到某一个必胜状态$a_1 \land a_2 \land … \land a_n \ne 0$</li><li>先手必败状态：走不到任何一个必胜状态 $a_1 \land a_2 \land … \land a_n&#x3D;0$</li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数学问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>其他补充</title>
    <link href="/2023/09/19/%E5%85%B6%E4%BB%96/"/>
    <url>/2023/09/19/%E5%85%B6%E4%BB%96/</url>
    
    <content type="html"><![CDATA[<p>算法其他补充</p><span id="more"></span><ol><li><p>加快读取速度：<code>ios::sync _with_stdio(false):</code></p></li><li><p><code>lower_bound( begin,end,num)</code>：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p><code>upper_bound( begin,end,num)</code>：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p><code>lower_bound( begin,end,num,greater&lt;type&gt;())</code>:从数组的begin位置到end-1位置二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p><code>upper_bound( begin,end,num,greater&lt;type&gt;())</code>:从数组的begin位置到end-1位置二分查找第一个小于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>其他补充</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树图算法</title>
    <link href="/2023/09/18/%E6%A0%91%E5%92%8C%E5%9B%BE/"/>
    <url>/2023/09/18/%E6%A0%91%E5%92%8C%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>树和图的遍历；拓扑排序；Dijkstra；Bellman-Ford；spfa；floyd；prim；Kruskal；染色法；匈牙利</p><span id="more"></span><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ol><li><p>树是一种特殊的图，与图的存储方式相同。</p></li><li><p>对于无向图中的边$ab$，存储两条有向边$a-&gt;b, b-&gt;a$；因此我们可以只考虑有向图的存储。</p></li><li><p>存储方式（因此一般考虑有向图即可）</p><ol><li><p>邻接矩阵：$g[a][b]$ 存储边$a-&gt;b$</p></li><li><p>邻接表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点</span><br><span class="hljs-comment">// h[k]存储这个单链表的头结点指向的值</span><br><span class="hljs-comment">// e[]存储的是所有结点值</span><br><span class="hljs-comment">// ne[]存储是所有结点的next值</span><br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><br><span class="hljs-comment">// 添加一条边a-&gt;b</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 初始化</span><br>idx = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br></code></pre></td></tr></table></figure></li></ol></li></ol><p><img src="/Assets/image-20231017162524854.png" alt="邻接表创建"></p><h3 id="树与图的遍历"><a href="#树与图的遍历" class="headerlink" title="树与图的遍历"></a>树与图的遍历</h3><p>时间复杂度 $O(n+m)$, $n$表示点数，$m$表示边数</p><ol><li><p>深度优先遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// st[u] 表示点u已经被遍历过</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!st[j]) <span class="hljs-built_in">dfs</span>(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>宽度优先遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;<span class="hljs-type">int</span>&gt; q;<br>st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示1号点已经被遍历过</span><br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>&#123;<br>    <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>    q.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span> (!s[j])<br>        &#123;<br>            st[j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示点j已经被遍历过</span><br>            q.<span class="hljs-built_in">push</span>(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ol><li>是BFS的应用</li><li>时间复杂度 $O(n+m)$, $n$表示点数，$m$表示边数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">// d[i] 存储点i的入度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">if</span> (!d[i])<br>          <span class="hljs-comment">// 存储所有入度为0的点</span><br>            q[ ++ tt] = i;<br><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt)<br>    &#123;<br>        <span class="hljs-type">int</span> t = q[hh ++ ];<br><span class="hljs-comment">// 枚举所有出边</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (-- d[j] == <span class="hljs-number">0</span>)<br>              <span class="hljs-comment">// 加入入度为0的点</span><br>                q[ ++ tt] = j;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span><br>    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 出队的顺序即使拓扑序列</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>$n$代表点，$m$代表边，只是有向图（包含无向图）</p><p>重边；自环</p><p><img src="/Assets/image-20231010160846694.png" alt="最短路径"></p><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><h4 id="朴素dijkstra"><a href="#朴素dijkstra" class="headerlink" title="朴素dijkstra"></a>朴素dijkstra</h4><p>时间复杂度 $O(n^2+m)$, $n$表示点数，$m$表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> g[N][N];  <span class="hljs-comment">// 存储每条边</span><br><span class="hljs-type">int</span> dist[N];  <span class="hljs-comment">// 存储1号点到每个点的最短距离</span><br><span class="hljs-type">bool</span> st[N];   <span class="hljs-comment">// 存储每个点的最短路是否已经确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 每次循环可以确定一个点的最短距离</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;     <span class="hljs-comment">// 在还未确定最短路的点中，寻找距离最小的点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br><br>        <span class="hljs-comment">// 用t更新其他点的距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]);<br><br>        st[t] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="堆优化版dijkstra"><a href="#堆优化版dijkstra" class="headerlink" title="堆优化版dijkstra"></a>堆优化版dijkstra</h4><p>稀疏，改成邻接表形式</p><p>时间复杂度 $O(mlogn)$, $n$表示点数，$m$表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 点的数量</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储所有点到1号点的距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点的最短距离是否已确定</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);      <span class="hljs-comment">// first存储距离，second存储节点编号</span><br><br>    <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-type">int</span> ver = t.second, distance = t.first;<br><br>        <span class="hljs-keyword">if</span> (st[ver]) <span class="hljs-keyword">continue</span>;<br>        st[ver] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; distance + w[i])<br>            &#123;<br>                dist[j] = distance + w[i];<br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><p>有负权回路，最短路径不一定存在；可以求是不是有负权回路</p><p>时间复杂度 $O(mn)$, $n$表示点数，$m$表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;       <span class="hljs-comment">// n表示点数，m表示边数</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// dist[x]存储1到x的最短路距离</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>     <span class="hljs-comment">// 边，a表示出点，b表示入点，w表示边的权重</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br>&#125;edges[M];<br><br><span class="hljs-comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span><br>  <br>    <span class="hljs-comment">// 迭代k次代表每个点到源点的最短距离经过的边数不超过k</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-comment">// 需要进行备份，只能用上一次的结果</span><br>        <span class="hljs-built_in">memcpy</span>(backup, dist, <span class="hljs-keyword">sizeof</span> dist);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;<br>            <span class="hljs-keyword">if</span> (dist[b] &gt; dist[a] + w)<br>                dist[b] = dist[a] + w;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 不能直接是==0x3f3f3f3f，可能会直接更新</span><br>    <span class="hljs-keyword">if</span> (dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="spfa-算法"><a href="#spfa-算法" class="headerlink" title="spfa 算法"></a>spfa 算法</h3><p>只要图当中没有负环即可</p><h4 id="算法模版"><a href="#算法模版" class="headerlink" title="算法模版"></a>算法模版</h4><ol><li>队列优化的Bellman-Ford算法</li><li>时间复杂度平均情况 $O(m)$,最坏情况$O(mn)$ $n$表示点数，$m$表示边数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储每个点到1号点的最短距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-comment">// q存储的是待更新的点</span><br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 遍历和t关联的所有点，判断是否可以更新</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                <span class="hljs-keyword">if</span> (!st[j])     <span class="hljs-comment">// 如果队列中已存在j，则不需要将j重复插入</span><br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="判断图中是否存在负环"><a href="#判断图中是否存在负环" class="headerlink" title="判断图中是否存在负环"></a>判断图中是否存在负环</h4><p>时间复杂度 $O(nm)$，  $n$表示点数，$m$表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// 总点数</span><br><span class="hljs-type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="hljs-comment">// 邻接表存储所有边</span><br><span class="hljs-type">int</span> dist[N], cnt[N];        <span class="hljs-comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否在队列中</span><br><br><span class="hljs-comment">// 如果存在负环，则返回true，否则返回false。</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 不需要初始化dist数组</span><br>    <span class="hljs-comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span><br><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-comment">// 对于所有的点都需要遍历到</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        st[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br><br>        st[t] = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span> (dist[j] &gt; dist[t] + w[i])<br>            &#123;<br>                dist[j] = dist[t] + w[i];<br>                cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;       <span class="hljs-comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span><br>                <span class="hljs-keyword">if</span> (!st[j])<br>                &#123;<br>                    q.<span class="hljs-built_in">push</span>(j);<br>                    st[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="floyd算法"><a href="#floyd算法" class="headerlink" title="floyd算法"></a>floyd算法</h3><p>时间复杂度 $O(n^3)$，  $n$表示点数，$m$表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化：</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (i == j) d[i][j] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> d[i][j] = INF;<br><br><span class="hljs-comment">// 算法结束后，d[a][b]表示a到b的最短距离</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-comment">// k是阶段</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>               <span class="hljs-comment">// 代表只经过1-k个点，从i到j的最短距离</span><br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p><img src="/Assets/image-20231010172722595.png" alt="最小生成树"></p><h3 id="朴素版prim算法"><a href="#朴素版prim算法" class="headerlink" title="朴素版prim算法"></a>朴素版prim算法</h3><p>时间复杂度 $O(n^2+m)$，  $n$表示点数，$m$表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n;      <span class="hljs-comment">// n表示点数</span><br><span class="hljs-type">int</span> g[N][N];        <span class="hljs-comment">// 邻接矩阵，存储所有边</span><br><span class="hljs-type">int</span> dist[N];        <span class="hljs-comment">// 存储其他点到当前最小生成树的距离</span><br><span class="hljs-type">bool</span> st[N];     <span class="hljs-comment">// 存储每个点是否已经在生成树中</span><br><br><br><span class="hljs-comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>          <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )<br>            <span class="hljs-keyword">if</span> (!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br><br>        <span class="hljs-keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="hljs-keyword">return</span> INF;<br><br>        <span class="hljs-keyword">if</span> (i) res += dist[t];<br>        st[t] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="hljs-built_in">min</span>(dist[j], g[t][j]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>时间复杂度 $O(mlogm)$，  $n$表示点数，$m$表示边数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m;       <span class="hljs-comment">// n是点数，m是边数</span><br><span class="hljs-type">int</span> p[N];       <span class="hljs-comment">// 并查集的父节点数组</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>     <span class="hljs-comment">// 存储边</span><br>&#123;<br>    <span class="hljs-type">int</span> a, b, w;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-type">const</span> Edge &amp;W)<span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> w &lt; W.w;<br>    &#125;<br>&#125;edges[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>     <span class="hljs-comment">// 并查集核心操作</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(edges, edges + m);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="hljs-comment">// 初始化并查集</span><br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;<br><br>        a = <span class="hljs-built_in">find</span>(a), b = <span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span> (a != b)     <span class="hljs-comment">// 如果两个连通块不连通，则将这两个连通块合并</span><br>        &#123;<br>            p[a] = b;<br>            res += w;<br>            cnt ++ ;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (cnt &lt; n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> INF;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="染色法判别二分图"><a href="#染色法判别二分图" class="headerlink" title="染色法判别二分图"></a>染色法判别二分图</h3><p>二分图的几个性质：</p><ol><li>二分图不一定是连通图</li><li>一定不含有奇数环；可以包含长度为偶数的环</li><li>任何无回路的图均是二分图</li></ol><p>$O(n+m)$</p><h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>$O(mn)$</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>树图算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>图</tag>
      
      <tag>拓扑排序</tag>
      
      <tag>Dijkstra</tag>
      
      <tag>Bellman-Ford</tag>
      
      <tag>spfa</tag>
      
      <tag>floyd</tag>
      
      <tag>prim</tag>
      
      <tag>Kruskal</tag>
      
      <tag>染色法</tag>
      
      <tag>匈牙利</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索算法</title>
    <link href="/2023/09/18/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"/>
    <url>/2023/09/18/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>深度优先搜索；广度优先搜索；</p><span id="more"></span><table><thead><tr><th></th><th>数据结构</th><th>空间</th><th>其他</th></tr></thead><tbody><tr><td>DFS</td><td>Stack</td><td>$O(h)$</td><td>回溯；剪枝；每个dfs对应一个搜索树</td></tr><tr><td>BFS</td><td>Queue</td><td>$O(2^h)$</td><td>有最短路径性质</td></tr></tbody></table><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><ol><li>回溯一定要注意恢复现场</li><li>子集树：通常有$2^n$个叶子结点，遍历子集树时间为$Ω(2^n)$</li><li>排列树：通常有$n!$个叶子结点，遍历子集树时间为$Ω(n!)$</li></ol><blockquote><p>AcWing 842. 排列数字 &amp; 排列数</p></blockquote><p><img src="/Assets/image-20230918143244650%201.png" alt="排列数字示例"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// u代表当前层数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (u == n)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cout &lt;&lt; path[i];<br>    &#125;<br>    <span class="hljs-comment">// 对于每个数进行遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        <span class="hljs-comment">// 该数没有被用过</span><br>        <span class="hljs-keyword">if</span> (!st[i])<br>        &#123;<br>            path[u] = i;<br>            st[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">// 一般会做剪枝操作，进入dfs需要条件</span><br>            <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 恢复现场</span><br>            st[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>AcWing 843. n-皇后问题 &amp; 子集树</p></blockquote><ol><li>该问题可以用排列数来做，但是需要进行剪枝操作</li><li>或者用子集树来做，对于每一个格子进行枚举，可以选择放&#x2F;不放</li></ol><p><img src="/Assets/image-20230918202610470%201.png" alt="n皇后示例"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// s代表当前层数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (y == n) y = <span class="hljs-number">0</span>, x++;<br>    <span class="hljs-keyword">if</span> (x = n)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (s == n)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) <span class="hljs-built_in">puts</span>(g[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//不放皇后</span><br>    <span class="hljs-built_in">dfs</span>(x, y + <span class="hljs-number">1</span>, s);<br>    <span class="hljs-comment">//放皇后</span><br>    <span class="hljs-keyword">if</span> (!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n])<br>    &#123;<br>        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(x, y + <span class="hljs-number">1</span>, s + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 恢复现场</span><br>        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>一般模版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始queue</span><br><span class="hljs-keyword">while</span>(!queue.<span class="hljs-built_in">empty</span>())<br>&#123;<br>  t=queue.队头;<br>  扩展t，进入队列中<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>搜索算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL</title>
    <link href="/2023/09/17/STL/"/>
    <url>/2023/09/17/STL/</url>
    
    <content type="html"><![CDATA[<p>整理STL的数据类型及相关操作</p><span id="more"></span><h2 id="STL标准模版库"><a href="#STL标准模版库" class="headerlink" title="STL标准模版库"></a>STL标准模版库</h2><p>C++标准模板库（STL）提供了一组通用的模板类和函数，这些类和函数可以实现各种数据结构和算法。以下是一些类似<code>std::vector</code>和<code>std::string</code>的常用STL容器：</p><ol><li><code>std::array</code>：一个固定大小的数组，支持随机访问和迭代器。</li><li><code>std::deque</code>：双端队列，支持在队列两端进行元素的插入和删除。</li><li><code>std::forward_list</code>：单向链表，支持在链表头部进行元素的插入和删除。</li><li><code>std::list</code>：双向链表，支持在链表两端进行元素的插入和删除。</li><li><code>std::map</code>：关联容器，用于存储键值对。支持按照键进行查询和插入，底层实现为红黑树。</li><li><code>std::multimap</code>：和<code>std::map</code>类似，但可以存储多个具有相同键的键值对。</li><li><code>std::set</code>：关联容器，用于存储唯一的键。支持按照键进行查询和插入，底层实现为红黑树。</li><li><code>std::multiset</code>：和<code>std::set</code>类似，但可以存储多个相同的键。</li><li><code>std::stack</code>：堆栈，支持在栈顶进行元素的插入和删除。</li><li><code>std::queue</code>：队列，支持在队尾进行元素的插入，在队头进行元素的删除。</li><li><code>std::priority_queue</code>：优先队列，支持按照元素的优先级进行插入和删除，底层实现为堆。</li></ol><p>除了上述容器之外，STL还提供了一些辅助类和函数，如迭代器、算法、函数对象等。这些类和函数可以与容器一起使用，实现各种常用的操作和算法。</p><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><h3 id="1-构造函数："><a href="#1-构造函数：" class="headerlink" title="1. 构造函数："></a>1. 构造函数：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span>(); <span class="hljs-comment">// 创建一个空字符串</span><br><span class="hljs-built_in">string</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span>* s); <span class="hljs-comment">// 从C字符串创建一个字符串</span><br><span class="hljs-built_in">string</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str); <span class="hljs-comment">// 从另一个字符串创建一个字符串</span><br><span class="hljs-built_in">string</span>(size_t n, <span class="hljs-built_in">char</span> c); <span class="hljs-comment">// 从字符c创建一个由n个字符c组成的字符串</span><br></code></pre></td></tr></table></figure><h3 id="2-赋值和赋值运算符："><a href="#2-赋值和赋值运算符：" class="headerlink" title="2. 赋值和赋值运算符："></a>2. 赋值和赋值运算符：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span>&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str); <span class="hljs-comment">// 从另一个字符串赋值</span><br><span class="hljs-built_in">string</span>&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span>* s); <span class="hljs-comment">// 从C字符串赋值</span><br><span class="hljs-built_in">string</span>&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-built_in">char</span> c); <span class="hljs-comment">// 从一个字符赋值</span><br><span class="hljs-built_in">string</span>&amp; assign(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str); <span class="hljs-comment">// 从另一个字符串赋值</span><br><span class="hljs-built_in">string</span>&amp; assign(<span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span>* s); <span class="hljs-comment">// 从C字符串赋值</span><br><span class="hljs-built_in">string</span>&amp; assign(<span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span>* s, size_t n); <span class="hljs-comment">// 从C字符串的前n个字符赋值</span><br><span class="hljs-built_in">string</span>&amp; assign(size_t n, <span class="hljs-built_in">char</span> c); <span class="hljs-comment">// 从字符c创建一个由n个字符c组成的字符串</span><br></code></pre></td></tr></table></figure><h3 id="3-访问和修改字符串的字符："><a href="#3-访问和修改字符串的字符：" class="headerlink" title="3. 访问和修改字符串的字符："></a>3. 访问和修改字符串的字符：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> pos); <span class="hljs-comment">// 访问字符串的第pos个字符</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> pos) <span class="hljs-type">const</span>; <span class="hljs-comment">// 访问字符串的第pos个字符（常量版本）</span><br><span class="hljs-function"><span class="hljs-type">char</span>&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos)</span></span>; <span class="hljs-comment">// 访问字符串的第pos个字符，并检查边界</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-title">at</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 访问字符串的第pos个字符，并检查边界（常量版本）</span><br><span class="hljs-function"><span class="hljs-type">char</span>&amp; <span class="hljs-title">front</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 访问字符串的第一个字符</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 访问字符串的第一个字符（常量版本）</span><br><span class="hljs-function"><span class="hljs-type">char</span>&amp; <span class="hljs-title">back</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 访问字符串的最后一个字符</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 访问字符串的最后一个字符（常量版本）</span><br>string&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> string&amp; str); <span class="hljs-comment">// 将另一个字符串附加到当前字符串的末尾</span><br>string&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s); <span class="hljs-comment">// 将C字符串附加到当前字符串的末尾</span><br>string&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">char</span> c); <span class="hljs-comment">// 将一个字符附加到当前字符串的末尾</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str)</span></span>; <span class="hljs-comment">// 将另一个字符串附加到当前字符串的末尾</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span></span>; <span class="hljs-comment">// 将C字符串附加到当前字符串的末尾</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">size_t</span> n)</span></span>; <span class="hljs-comment">// 将C字符串的前n个字符附加到当前字符串的末尾</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, <span class="hljs-type">char</span> c)</span></span>; <span class="hljs-comment">// 将字符c创建的由n个字符c组成的字符串附加到当前字符串的末尾</span><br></code></pre></td></tr></table></figure><h3 id="4-字符串的比较："><a href="#4-字符串的比较：" class="headerlink" title="4. 字符串的比较："></a>4. 字符串的比较：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 比较当前字符串和另一个字符串</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 比较当前字符串和C字符串</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">size_t</span> len, <span class="hljs-type">const</span> string&amp; str)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 从pos位置开始比较当前字符串的前len个字符和另一个字符串</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">size_t</span> len, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 从pos位置开始比较当前字符串的前len个字符和C字符串</span><br></code></pre></td></tr></table></figure><h3 id="5-字符串的查找和替换："><a href="#5-字符串的查找和替换：" class="headerlink" title="5. 字符串的查找和替换："></a>5. 字符串的查找和替换：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 在当前字符串中查找另一个字符串，并返回它的位置</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 在当前字符串中查找C字符串，并返回它的位置</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">char</span> c, <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 在当前字符串中查找字符c，并返回它的位置</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span> pos = npos)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 在当前字符串中倒序查找另一个字符串，并返回它的位置</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">size_t</span> pos = npos)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 在当前字符串中倒序查找C字符串，并返回它的位置</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-type">char</span> c, <span class="hljs-type">size_t</span> pos = npos)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 在当前字符串中倒序查找字符c，并返回它的位置</span><br><span class="hljs-function">string&amp; <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">size_t</span> len, <span class="hljs-type">const</span> string&amp; str)</span></span>; <span class="hljs-comment">// 替换当前字符串中从pos位置开始的len个字符为另一个字符串</span><br><span class="hljs-function">string&amp; <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">size_t</span> len, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span></span>; <span class="hljs-comment">// 替换当前字符串中从pos位置开始的len个字符为C字符串</span><br><span class="hljs-function">string&amp; <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">size_t</span> len, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">size_t</span> n)</span></span>; <span class="hljs-comment">// 替换当前字符串中从pos位置开始的len个字符为C字符串的前n个字符</span><br><span class="hljs-function">string&amp; <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">size_t</span> len, <span class="hljs-type">size_t</span> n, <span class="hljs-type">char</span> c)</span></span>; <span class="hljs-comment">// 替换当前字符串中从pos位置开始的len个字符为n个字符c</span><br></code></pre></td></tr></table></figure><h3 id="6-字符串的子串："><a href="#6-字符串的子串：" class="headerlink" title="6. 字符串的子串："></a>6. 字符串的子串：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">substr</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>, <span class="hljs-type">size_t</span> len = npos)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 返回当前字符串中从pos位置开始的len个字符组成的子串</span><br></code></pre></td></tr></table></figure><h3 id="7-字符串的长度和容量："><a href="#7-字符串的长度和容量：" class="headerlink" title="7. 字符串的长度和容量："></a>7. 字符串的长度和容量：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">size_t <span class="hljs-title">size</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回当前字符串的长度</span><br><span class="hljs-function">size_t <span class="hljs-title">length</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回当前字符串的长度</span><br><span class="hljs-function">size_t <span class="hljs-title">capacity</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回当前字符串的容量</span><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">empty</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 判断当前字符串是否为空</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reserve</span>(<span class="hljs-params">size_t n</span>)</span>; <span class="hljs-comment">// 分配至少可以容纳n个字符的内部存储空间</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shrink_to_fit</span>()</span>; <span class="hljs-comment">// 收缩当前字符串的内部存储空间，使其能够容纳实际的字符数</span><br></code></pre></td></tr></table></figure><h3 id="8-字符串的输入输出："><a href="#8-字符串的输入输出：" class="headerlink" title="8. 字符串的输入输出："></a>8. 字符串的输入输出：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">istream&amp; getline(istream&amp; <span class="hljs-keyword">is</span>, <span class="hljs-built_in">string</span>&amp; str, <span class="hljs-built_in">char</span> delim); <span class="hljs-comment">// 从输入流中读取一行到字符串中，以delim为分隔符</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str); <span class="hljs-comment">// 将字符串输出到输出流中</span><br>istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; <span class="hljs-keyword">is</span>, <span class="hljs-built_in">string</span>&amp; str); <span class="hljs-comment">// 从输入流中读取字符串</span><br></code></pre></td></tr></table></figure><h3 id="9-字符串的判断和分类："><a href="#9-字符串的判断和分类：" class="headerlink" title="9. 字符串的判断和分类："></a>9. 字符串的判断和分类：</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">bool</span> operator==(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; rhs); <span class="hljs-comment">// 判断两个字符串是否相等</span><br><span class="hljs-built_in">bool</span> operator!=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; rhs); <span class="hljs-comment">// 判断两个字符串是否不相等</span><br><span class="hljs-built_in">bool</span> operator&lt;(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; rhs); <span class="hljs-comment">// 判断一个字符串是否小于另一个字符串</span><br><span class="hljs-built_in">bool</span> operator&lt;=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; rhs); <span class="hljs-comment">// 判断一个字符串是否小于或等于另一个字符串</span><br><span class="hljs-built_in">bool</span> operator&gt;(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; rhs); <span class="hljs-comment">// 判断一个字符串是否大于另一个字符串</span><br><span class="hljs-built_in">bool</span> operator&gt;=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; rhs); <span class="hljs-comment">// 判断一个字符串是否大于或等于另一个字符串</span><br><span class="hljs-built_in">bool</span> starts_with(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; prefix); <span class="hljs-comment">// 判断一个字符串是否以另一个字符串开头</span><br><span class="hljs-built_in">bool</span> ends_with(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; suffix); <span class="hljs-comment">// 判断一个字符串是否以另一个字符串结尾</span><br><span class="hljs-built_in">bool</span> isalnum(<span class="hljs-built_in">int</span> c); <span class="hljs-comment">// 判断一个字符是否是字母或数字</span><br><span class="hljs-built_in">bool</span> isalpha(<span class="hljs-built_in">int</span> c); <span class="hljs-comment">// 判断一个字符是否是字母</span><br><span class="hljs-built_in">bool</span> isdigit(<span class="hljs-built_in">int</span> c); <span class="hljs-comment">// 判断一个字符是否是数字</span><br><span class="hljs-built_in">bool</span> islower(<span class="hljs-built_in">int</span> c); <span class="hljs-comment">// 判断一个字符是否是小写字母</span><br><span class="hljs-built_in">bool</span> isupper(<span class="hljs-built_in">int</span> c); <span class="hljs-comment">// 判断一个字符是否是大写字母</span><br><span class="hljs-built_in">bool</span> isspace(<span class="hljs-built_in">int</span> c); <span class="hljs-comment">// 判断一个字符是否是空白字符，包括空格、制表符、换行符等</span><br></code></pre></td></tr></table></figure><h3 id="10-字符串的转换："><a href="#10-字符串的转换：" class="headerlink" title="10. 字符串的转换："></a>10. 字符串的转换：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>; <span class="hljs-comment">// 将整数转换为字符串</span><br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">long</span> value)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> value)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> value)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> value)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> value)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">float</span> value)</span></span>; <span class="hljs-comment">// 将浮点数转换为字符串</span><br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">double</span> value)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stoi</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span>* pos = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> base = <span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 将字符串转换为整数</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">stol</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span>* pos = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> base = <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">stoll</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span>* pos = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> base = <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">stoul</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span>* pos = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> base = <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">stoul</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span>* pos = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> base = <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">stoull</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span>* pos = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> base = <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">stof</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span>* pos = <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 将字符串转换为浮点数</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">stod</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span>* pos = <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-title">stold</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span>* pos = <span class="hljs-number">0</span>)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="11-字符串的处理："><a href="#11-字符串的处理：" class="headerlink" title="11. 字符串的处理："></a>11. 字符串的处理：</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">void</span> transform(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str, <span class="hljs-built_in">string</span>&amp; result, UnaryOperation op); <span class="hljs-comment">// 将字符串中的每个字符应用一个一元操作，并将结果存储到另一个字符串中</span><br><span class="hljs-built_in">void</span> transform(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str1, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str2, <span class="hljs-built_in">string</span>&amp; result, BinaryOperation op); <span class="hljs-comment">// 将两个字符串中的每个字符一一对应地应用一个二元操作，并将结果存储到另一个字符串中</span><br><span class="hljs-built_in">void</span> replace_all(<span class="hljs-built_in">string</span>&amp; str, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; <span class="hljs-keyword">from</span>, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; to); <span class="hljs-comment">// 替换字符串中的所有出现的一个子串为另一个子串</span><br><span class="hljs-built_in">void</span> replace_all(<span class="hljs-built_in">string</span>&amp; str, char <span class="hljs-keyword">from</span>, char to); <span class="hljs-comment">// 替换字符串中的所有出现的一个字符为另一个字符</span><br><span class="hljs-built_in">void</span> replace_all(<span class="hljs-built_in">string</span>&amp; str, <span class="hljs-keyword">const</span> vector&lt;pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;&gt;&amp; replacements); <span class="hljs-comment">// 替换字符串中的所有出现的多个子串为另一个子串</span><br><span class="hljs-built_in">void</span> erase(<span class="hljs-built_in">string</span>&amp; str, size_t pos, size_t len); <span class="hljs-comment">// 删除字符串中从pos位置开始的len个字符</span><br><span class="hljs-built_in">void</span> remove(<span class="hljs-built_in">string</span>&amp; str, char); <span class="hljs-comment">// 删除字符串中所有出现的指定字符</span><br><span class="hljs-built_in">void</span> remove_if(<span class="hljs-built_in">string</span>&amp; str, UnaryPredicate pred); <span class="hljs-comment">// 删除字符串中满足指定条件的所有字符</span><br><span class="hljs-built_in">void</span> reverse(<span class="hljs-built_in">string</span>&amp; str); <span class="hljs-comment">// 反转字符串中的字符顺序</span><br><span class="hljs-built_in">void</span> shuffle(<span class="hljs-built_in">string</span>&amp; str); <span class="hljs-comment">// 将字符串中的字符随机打乱顺序</span><br><span class="hljs-built_in">void</span> sort(<span class="hljs-built_in">string</span>&amp; str); <span class="hljs-comment">// 将字符串中的字符按字典顺序排序</span><br><span class="hljs-built_in">void</span> unique(<span class="hljs-built_in">string</span>&amp; str); <span class="hljs-comment">// 删除字符串中连续出现的重复字符，只保留一个</span><br></code></pre></td></tr></table></figure><h3 id="12-字符串的查找和定位："><a href="#12-字符串的查找和定位：" class="headerlink" title="12. 字符串的查找和定位："></a>12. 字符串的查找和定位：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">const</span> string&amp; substr, <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 在字符串中查找指定子串的第一个出现位置，从pos位置开始查找</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">char</span> ch, <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 在字符串中查找指定字符的第一个出现位置，从pos位置开始查找</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">const</span> string&amp; substr, <span class="hljs-type">size_t</span> pos = string::npos)</span></span>; <span class="hljs-comment">// 在字符串中查找指定子串的最后一个出现位置，从pos位置开始查找</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">rfind</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">char</span> ch, <span class="hljs-type">size_t</span> pos = string::npos)</span></span>; <span class="hljs-comment">// 在字符串中查找指定字符的最后一个出现位置，从pos位置开始查找</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find_first_of</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">const</span> string&amp; chars, <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 在字符串中查找第一个与指定字符集中任意一个字符匹配的字符的位置，从pos位置开始查找</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find_first_not_of</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">const</span> string&amp; chars, <span class="hljs-type">size_t</span> pos = <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 在字符串中查找第一个不与指定字符集中任何一个字符匹配的字符的位置，从pos位置开始查找</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find_last_of</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">const</span> string&amp; chars, <span class="hljs-type">size_t</span> pos = string::npos)</span></span>; <span class="hljs-comment">// 在字符串中查找最后一个与指定字符集中任意一个字符匹配的字符的位置，从pos位置开始查找</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">find_last_not_of</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">const</span> string&amp; chars, <span class="hljs-type">size_t</span> pos = string::npos)</span></span>; <span class="hljs-comment">// 在字符串中查找最后一个不与指定字符集中任何一个字符匹配的字符的位置，从pos位置开始查找</span><br></code></pre></td></tr></table></figure><p>这些函数可以用于查找和定位字符串中的子串或字符。<code>find</code>和<code>rfind</code>函数可以分别在字符串中从前往后或从后往前查找子串或字符的位置，<code>find_first_of</code>和<code>find_last_of</code>函数可以查找与指定字符集中任意一个字符匹配的字符的位置，<code>find_first_not_of</code>和<code>find_last_not_of</code>函数可以查找不与指定字符集中任何一个字符匹配的字符的位置。</p><h3 id="13-字符串的分割和拼接："><a href="#13-字符串的分割和拼接：" class="headerlink" title="13. 字符串的分割和拼接："></a>13. 字符串的分割和拼接：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">vector&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">split</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; str, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; delimiter</span>)</span>; <span class="hljs-comment">// 将字符串按指定分隔符分割成多个子串，并存储到一个字符串向量中</span><br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">join</span>(<span class="hljs-params"><span class="hljs-keyword">const</span> vector&lt;<span class="hljs-built_in">string</span>&gt;&amp; strs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; delimiter</span>)</span>; <span class="hljs-comment">// 将多个子串拼接成一个字符串，中间用指定分隔符隔开</span><br></code></pre></td></tr></table></figure><p><code>split</code>函数可以将一个字符串按照指定的分隔符分割成多个子串，并将这些子串存储到一个字符串向量中返回。<code>join</code>函数则可以将多个子串拼接成一个字符串，并使用指定的分隔符隔开。</p><h3 id="14-字符串的大小写转换："><a href="#14-字符串的大小写转换：" class="headerlink" title="14. 字符串的大小写转换："></a>14. 字符串的大小写转换：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">to_lower</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>&amp; str</span>)</span>; <span class="hljs-comment">// 将字符串中的所有字符转换为小写</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">to_upper</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>&amp; str</span>)</span>; <span class="hljs-comment">// 将字符串中的所有字符转换为大写</span><br></code></pre></td></tr></table></figure><p>这两个函数可以将字符串中的所有字符分别转换为小写或大写字母。</p><h3 id="15-字符串的格式化输出："><a href="#15-字符串的格式化输出：" class="headerlink" title="15. 字符串的格式化输出："></a>15. 字符串的格式化输出：</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ...)</span></span>; <span class="hljs-comment">// 将格式化的字符串输出到标准输出流（stdout）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fprintf</span><span class="hljs-params">(FILE* stream, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ...)</span></span>; <span class="hljs-comment">// 将格式化的字符串输出到指定文件流</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sprintf</span><span class="hljs-params">(<span class="hljs-type">char</span>* str, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ...)</span></span>; <span class="hljs-comment">// 将格式化的字符串输出到指定字符缓冲区</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">snprintf</span><span class="hljs-params">(<span class="hljs-type">char</span>* str, <span class="hljs-type">size_t</span> size, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ...)</span></span>; <span class="hljs-comment">// 将格式化的字符串输出到指定字符缓冲区，限制输出的最大长度</span><br></code></pre></td></tr></table></figure><p>这些函数可以将格式化的字符串按指定格式输出到标准输出流、文件流或字符缓冲区中。这些函数的第一个参数是一个格式化字符串，其中包含了格式化指令和占位符，后面的可变参数列表则是要输出的实际内容。例如：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">double</span> b = <span class="hljs-number">3.1415926</span>;<br>string <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br><br>printf(<span class="hljs-string">&quot;a = %d, b = %.2lf, str = %s&quot;</span>, a, b, <span class="hljs-built_in">str</span>.c_str());<br><span class="hljs-comment">// 输出：a = 10, b = 3.14, str = hello</span><br></code></pre></td></tr></table></figure><p>这里的<code>%d</code>、<code>%.2lf</code>和<code>%s</code>都是格式化指令，分别表示输出整数、保留两位小数的浮点数和字符串。<code>c_str()</code>函数可以将一个<code>string</code>对象转换为一个C风格的字符串，以便在格式化输出时使用。</p><p>需要注意的是，这些函数都是C语言中的标准库函数，而不是C++标准库中的函数。在使用时需要包含对应的头文件，如<code>&lt;cstdio&gt;</code>、<code>&lt;cstring&gt;</code>等。此外，这些函数都没有进行格式字符串的类型检查，需要使用时要确保格式字符串和可变参数列表的类型匹配，否则可能会导致未定义行为。</p><h3 id="16-字符串的重复："><a href="#16-字符串的重复：" class="headerlink" title="16. 字符串的重复："></a>16. 字符串的重复：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string&amp; <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, <span class="hljs-type">char</span> c)</span></span>; <span class="hljs-comment">// 将字符串赋值为由n个c字符组成的字符串</span><br><span class="hljs-function">string&amp; <span class="hljs-title">assign</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str)</span></span>; <span class="hljs-comment">// 将字符串赋值为另一个字符串</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">size_t</span> n, <span class="hljs-type">char</span> c)</span></span>; <span class="hljs-comment">// 将n个c字符追加到字符串末尾</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str)</span></span>; <span class="hljs-comment">// 将另一个字符串追加到字符串末尾</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span> subpos, <span class="hljs-type">size_t</span> sublen)</span></span>; <span class="hljs-comment">// 将另一个字符串的子串追加到字符串末尾</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">size_t</span> n)</span></span>; <span class="hljs-comment">// 将指定长度的C风格字符串追加到字符串末尾</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span></span>; <span class="hljs-comment">// 将C风格字符串追加到字符串末尾</span><br><span class="hljs-function">string&amp; <span class="hljs-title">append</span><span class="hljs-params">(iterator first, iterator last)</span></span>; <span class="hljs-comment">// 将[first,last)范围内的字符追加到字符串末尾</span><br>string&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> string&amp; str); <span class="hljs-comment">// 将另一个字符串追加到字符串末尾，等价于调用append函数</span><br>string&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s); <span class="hljs-comment">// 将C风格字符串追加到字符串末尾，等价于调用append函数</span><br>string&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">char</span> c); <span class="hljs-comment">// 将一个字符追加到字符串末尾，等价于调用push_back函数</span><br><span class="hljs-function">string&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">size_t</span> n, <span class="hljs-type">char</span> c)</span></span>; <span class="hljs-comment">// 在指定位置插入由n个c字符组成的字符串</span><br><span class="hljs-function">string&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">const</span> string&amp; str)</span></span>; <span class="hljs-comment">// 在指定位置插入另一个字符串</span><br><span class="hljs-function">string&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">const</span> string&amp; str, <span class="hljs-type">size_t</span> subpos, <span class="hljs-type">size_t</span> sublen)</span></span>; <span class="hljs-comment">// 在指定位置插入另一个字符串的子串</span><br><span class="hljs-function">string&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, constchar* s, <span class="hljs-type">size_t</span> n)</span></span>; <span class="hljs-comment">// 在指定位置插入指定长度的C风格字符串</span><br><span class="hljs-function">string&amp; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span></span>; <span class="hljs-comment">// 在指定位置插入C风格字符串</span><br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(iterator p, <span class="hljs-type">char</span> c)</span></span>; <span class="hljs-comment">// 在指定位置插入一个字符</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(iterator p, <span class="hljs-type">size_t</span> n, <span class="hljs-type">char</span> c)</span></span>; <span class="hljs-comment">// 在指定位置插入由n个c字符组成的字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(iterator p, iterator first, iterator last)</span></span>; <span class="hljs-comment">// 在指定位置插入[first,last)范围内的字符</span><br></code></pre></td></tr></table></figure><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="1-构造函数：-1"><a href="#1-构造函数：-1" class="headerlink" title="1. 构造函数："></a>1. 构造函数：</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">vector</span>(); <span class="hljs-comment">// 默认构造函数，创建一个空的vector</span><br><span class="hljs-built_in">vector</span>(size_type count, const T&amp; value = T()); <span class="hljs-comment">// 创建一个包含count个元素，每个元素的值都为value的vector</span><br><span class="hljs-built_in">vector</span>(const vector&amp; other); <span class="hljs-comment">// 复制构造函数，创建一个other的副本</span><br><span class="hljs-built_in">vector</span>(vector&amp;&amp; other) noexcept; <span class="hljs-comment">// 移动构造函数，创建一个other的右值引用的副本</span><br><span class="hljs-built_in">vector</span>(initializer_list&lt;T&gt; init); <span class="hljs-comment">// 创建一个包含initializer_list对象中元素的vector</span><br></code></pre></td></tr></table></figure><h3 id="2-赋值运算符："><a href="#2-赋值运算符：" class="headerlink" title="2. 赋值运算符："></a>2. 赋值运算符：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> vector&amp; other); <span class="hljs-comment">// 复制赋值运算符，将当前vector赋值为other的副本</span><br>vector&amp; <span class="hljs-keyword">operator</span>=(vector&amp;&amp; other) <span class="hljs-keyword">noexcept</span>; <span class="hljs-comment">// 移动赋值运算符，将当前vector赋值为other的右值引用的副本</span><br>vector&amp; <span class="hljs-keyword">operator</span>=(initializer_list&lt;T&gt; init); <span class="hljs-comment">// 将当前vector赋值为initializer_list对象中元素</span><br></code></pre></td></tr></table></figure><h3 id="3-容量相关操作："><a href="#3-容量相关操作：" class="headerlink" title="3. 容量相关操作："></a>3. 容量相关操作：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">empty</span>() <span class="hljs-keyword">const</span> noexcept</span>; <span class="hljs-comment">// 判断vector是否为空，如果为空则返回true，否则返回false</span><br><span class="hljs-function">size_type <span class="hljs-title">size</span>() <span class="hljs-keyword">const</span> noexcept</span>; <span class="hljs-comment">// 返回vector中元素的数量</span><br><span class="hljs-function">size_type <span class="hljs-title">max_size</span>() <span class="hljs-keyword">const</span> noexcept</span>; <span class="hljs-comment">// 返回vector最大可容纳的元素数量</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reserve</span>(<span class="hljs-params">size_type new_cap</span>)</span>; <span class="hljs-comment">// 将vector的容量调整为至少为new_cap的大小</span><br><span class="hljs-function">size_type <span class="hljs-title">capacity</span>() <span class="hljs-keyword">const</span> noexcept</span>; <span class="hljs-comment">// 返回vector当前的容量</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shrink_to_fit</span>()</span>; <span class="hljs-comment">// 将vector的容量调整为当前元素数量的大小</span><br></code></pre></td></tr></table></figure><h3 id="4-访问元素："><a href="#4-访问元素：" class="headerlink" title="4. 访问元素："></a>4. 访问元素：</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">reference operator<span class="hljs-selector-attr">[]</span>(size_type pos); <span class="hljs-comment">// 访问vector中位于pos位置的元素</span><br>const_reference operator<span class="hljs-selector-attr">[]</span>(size_type pos) const; <span class="hljs-comment">// 访问vector中位于pos位置的元素（常量版本）</span><br>reference <span class="hljs-built_in">at</span>(size_type pos); <span class="hljs-comment">// 访问vector中位于pos位置的元素，并进行边界检查。如果越界，则抛出std::out_of_range异常</span><br>const_reference <span class="hljs-built_in">at</span>(size_type pos) const; <span class="hljs-comment">// 访问vector中位于pos位置的元素，并进行边界检查（常量版本）</span><br>reference <span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 返回vector中第一个元素的引用</span><br>const_reference <span class="hljs-built_in">front</span>() const; <span class="hljs-comment">// 返回vector中第一个元素的引用（常量版本）</span><br>reference <span class="hljs-built_in">back</span>(); <span class="hljs-comment">// 返回vector中最后一个元素的引用</span><br>const_reference <span class="hljs-built_in">back</span>() const; <span class="hljs-comment">// 返回vector中最后一个元素的引用（常量版本）</span><br>value_type* <span class="hljs-built_in">data</span>() noexcept; <span class="hljs-comment">// 返回指向vector中第一个元素的指针，如果vector为空，则返回nullptr</span><br>const value_type* <span class="hljs-built_in">data</span>() const noexcept; <span class="hljs-comment">// 返回指向vector中第一个元素的指针（常量版本）</span><br></code></pre></td></tr></table></figure><h3 id="5-修改容器："><a href="#5-修改容器：" class="headerlink" title="5. 修改容器："></a>5. 修改容器：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment">// 删除vector中所有元素</span><br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(const_iterator pos, <span class="hljs-type">const</span> T&amp; value)</span></span>; <span class="hljs-comment">// 在pos位置之前插入一个值为value的元素，并返回指向插入元素的迭代器</span><br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(const_iterator pos, T&amp;&amp; value)</span></span>; <span class="hljs-comment">// 在pos位置之前插入一个右值引用为value的元素，并返回指向插入元素的迭代器</span><br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(const_iterator pos, size_type count, <span class="hljs-type">const</span> T&amp; value)</span></span>; <span class="hljs-comment">// 在pos位置之前插入count个值为value的元素，并返回指向第一个插入元素的迭代器</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIt</span>&gt;<br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(const_iterator pos, InputIt first, InputIt last)</span></span>; <span class="hljs-comment">// 在pos位置之前插入[first,last)范围内的元素，并返回指向第一个插入元素的迭代器</span><br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(const_iterator pos, initializer_list&lt;T&gt; ilist)</span></span>; <span class="hljs-comment">// 在pos位置之前插入initializer_list对象中的元素，并返回指向第一个插入元素的迭代器</span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(const_iterator pos)</span></span>; <span class="hljs-comment">// 删除pos位置处的元素，并返回指向下一个元素的迭代器</span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(const_iterator first, const_iterator last)</span></span>; <span class="hljs-comment">// 删除[first,last)范围内的元素，并返回指向下一个元素的迭代器</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span></span>; <span class="hljs-comment">// 在vector末尾插入一个值为value的元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(T&amp;&amp; value)</span></span>; <span class="hljs-comment">// 在vector末尾插入一个右值引用为value的元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 删除vector末尾的元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(size_type count)</span></span>; <span class="hljs-comment">// 将vector的大小调整为count，并在必要时插入或删除元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(size_type count, <span class="hljs-type">const</span> value_type&amp; value)</span></span>; <span class="hljs-comment">// 将vector的大小调整为count，并在必要时插入或删除元素，新增的元素值为value</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(vector&amp; other)</span> <span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment">// 交换当前vector和other的元素</span><br></code></pre></td></tr></table></figure><h3 id="6-迭代器相关操作："><a href="#6-迭代器相关操作：" class="headerlink" title="6. 迭代器相关操作："></a>6. 迭代器相关操作：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">iterator <span class="hljs-title">begin</span>() noexcept</span>; <span class="hljs-comment">// 返回指向第一个元素的迭代器</span><br><span class="hljs-function">const_iterator <span class="hljs-title">begin</span>() <span class="hljs-keyword">const</span> noexcept</span>; <span class="hljs-comment">// 返回指向第一个元素的迭代器（常量版本）</span><br><span class="hljs-function">const_iterator <span class="hljs-title">cbegin</span>() <span class="hljs-keyword">const</span> noexcept</span>; <span class="hljs-comment">// 返回指向第一个元素的迭代器（常量版本）</span><br><span class="hljs-function">iterator <span class="hljs-title">end</span>() noexcept</span>; <span class="hljs-comment">// 返回指向vector末尾（下一个元素）的迭代器</span><br><span class="hljs-function">const_iterator <span class="hljs-title">end</span>() <span class="hljs-keyword">const</span> noexcept</span>; <span class="hljs-comment">// 返回指向vector末尾（下一个元素）的迭代器（常量版本）</span><br><span class="hljs-function">const_iterator <span class="hljs-title">cend</span>() <span class="hljs-keyword">const</span> noexcept</span>; <span class="hljs-comment">// 返回指向vector末尾（下一个元素）的迭代器（常量版本）</span><br><span class="hljs-function">reverse_iterator <span class="hljs-title">rbegin</span>() noexcept</span>; <span class="hljs-comment">// 返回指向最后一个元素的迭代器</span><br><span class="hljs-function">const_reverse_iterator <span class="hljs-title">rbegin</span>() <span class="hljs-keyword">const</span> noexcept</span>; <span class="hljs-comment">// 返回指向最后一个元素的迭代器（常量版本）</span><br><span class="hljs-function">const_reverse_iterator <span class="hljs-title">crbegin</span>() <span class="hljs-keyword">const</span> noexcept</span>; <span class="hljs-comment">// 返回指向最后一个元素的迭代器（常量版本）</span><br><span class="hljs-function">reverse_iterator <span class="hljs-title">rend</span>() noexcept</span>; <span class="hljs-comment">// 返回指向vector开头（前一个元素）的迭代器</span><br><span class="hljs-function">const_reverse_iterator <span class="hljs-title">rend</span>() <span class="hljs-keyword">const</span> noexcept</span>; <span class="hljs-comment">// 返回指向vector开头（前一个元素）的迭代器（常量版本）</span><br><span class="hljs-function">const_reverse_iterator <span class="hljs-title">crend</span>() <span class="hljs-keyword">const</span> noexcept</span>; <span class="hljs-comment">// 返回指向vector开头（前一个元素）的迭代器（常量版本）</span><br></code></pre></td></tr></table></figure><h3 id="7-其他操作："><a href="#7-其他操作：" class="headerlink" title="7. 其他操作："></a>7. 其他操作：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> vector&amp; lhs, <span class="hljs-type">const</span> vector&amp; rhs); <span class="hljs-comment">// 比较两个vector是否相等</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> vector&amp; lhs, <span class="hljs-type">const</span> vector&amp; rhs); <span class="hljs-comment">// 比较两个vector是否不相等</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> vector&amp; lhs, <span class="hljs-type">const</span> vector&amp; rhs); <span class="hljs-comment">// 比较两个vector的大小（字典序）</span><br><span class="hljs-type">bool</span> <span class="hljs-built_in">operator</span>&lt;=(<span class="hljs-type">const</span> vector&amp; lhs, <span class="hljs-type">const</span> vector&amp; rhs); <span class="hljs-comment">// 比较两个vector的大小（字典序）</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> vector&amp; lhs, <span class="hljs-type">const</span> vector&amp; rhs); <span class="hljs-comment">// 比较两个vector的大小（字典序）</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> vector&amp; lhs, <span class="hljs-type">const</span> vector&amp; rhs); <span class="hljs-comment">// 比较两个vector的大小（字典序）</span><br></code></pre></td></tr></table></figure><h3 id="8-查找元素："><a href="#8-查找元素：" class="headerlink" title="8. 查找元素："></a>8. 查找元素：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">iterator <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span></span>; <span class="hljs-comment">// 在vector中查找值为value的元素，并返回指向该元素的迭代器，如果未找到则返回end()</span><br><span class="hljs-function">const_iterator <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 在vector中查找值为value的元素，并返回指向该元素的迭代器（常量版本），如果未找到则返回end()</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Predicate&gt; iterator <span class="hljs-title">find_if</span><span class="hljs-params">(Predicate pred)</span></span>; <span class="hljs-comment">// 在vector中查找满足谓词pred的第一个元素，并返回指向该元素的迭代器，如果未找到则返回end()</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Predicate&gt; const_iterator <span class="hljs-title">find_if</span><span class="hljs-params">(Predicate pred)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 在vector中查找满足谓词pred的第一个元素，并返回指向该元素的迭代器（常量版本），如果未找到则返回end()</span><br></code></pre></td></tr></table></figure><h3 id="9-数值算法："><a href="#9-数值算法：" class="headerlink" title="9. 数值算法："></a>9. 数值算法：</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">T accumulate(InputIt <span class="hljs-built_in">first</span>, InputIt <span class="hljs-built_in">last</span>, T init); // 对[<span class="hljs-built_in">first</span>,<span class="hljs-built_in">last</span>)范围内的元素进行累加，初始值为init<br>T accumulate(InputIt <span class="hljs-built_in">first</span>, InputIt <span class="hljs-built_in">last</span>, T init, BinaryOp <span class="hljs-built_in">op</span>); // 对[<span class="hljs-built_in">first</span>,<span class="hljs-built_in">last</span>)范围内的元素进行二元运算<span class="hljs-built_in">op</span>的累加，初始值为init<br>void <span class="hljs-built_in">sort</span>(RandomIt <span class="hljs-built_in">first</span>, RandomIt <span class="hljs-built_in">last</span>); // 对[<span class="hljs-built_in">first</span>,<span class="hljs-built_in">last</span>)范围内的元素进行排序<br>void <span class="hljs-built_in">sort</span>(RandomIt <span class="hljs-built_in">first</span>, RandomIt <span class="hljs-built_in">last</span>, Compare comp); // 对[<span class="hljs-built_in">first</span>,<span class="hljs-built_in">last</span>)范围内的元素进行排序，使用比较函数comp进行排序<br>bool binary_search(ForwardIt <span class="hljs-built_in">first</span>, ForwardIt <span class="hljs-built_in">last</span>, const T&amp; value); // 二分查找，查找[<span class="hljs-built_in">first</span>,<span class="hljs-built_in">last</span>)范围内是否存在值为value的元素<br></code></pre></td></tr></table></figure><h3 id="10-与其他容器的转换："><a href="#10-与其他容器的转换：" class="headerlink" title="10. 与其他容器的转换："></a>10. 与其他容器的转换：</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIt</span>&gt; <span class="hljs-title">vector</span>(<span class="hljs-title">InputIt</span> <span class="hljs-title">first</span>, <span class="hljs-title">InputIt</span> <span class="hljs-title">last</span>) -&gt; <span class="hljs-title">vector</span>&lt;<span class="hljs-title">typename</span> <span class="hljs-title">iterator_traits</span>&lt;<span class="hljs-title">InputIt</span>&gt;::<span class="hljs-title">value_type</span>&gt;</span>; // 将[first,<span class="hljs-keyword">last</span>)范围内的元素复制到vector中<br>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; <span class="hljs-title">vector</span>(<span class="hljs-title">initializer_list</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">init</span>) -&gt; <span class="hljs-title">vector</span>&lt;<span class="hljs-title">T</span>&gt;</span>; // 使用initializer_list对象中的元素创建vector<br></code></pre></td></tr></table></figure><h3 id="11-自定义排序："><a href="#11-自定义排序：" class="headerlink" title="11. 自定义排序："></a>11. 自定义排序：</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compare</span>&gt; </span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">sort</span>(<span class="hljs-title">Compare</span> <span class="hljs-title">comp</span>)</span>; // 对vector中的元素进行排序，使用比较函数comp进行排序<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-comment">// 自定义比较函数，按照字符串长度排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; a, <span class="hljs-type">const</span> std::string&amp; b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">length</span>() &lt; b.<span class="hljs-built_in">length</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::string&gt; vec = &#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>&#125;;<br><br>    <span class="hljs-comment">// 对vector进行自定义比较函数排序</span><br>    std::<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), cmp);<br><br>    <span class="hljs-comment">// 输出排序后的结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; str : vec) &#123;<br>        std::cout &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-与其他容器的交互："><a href="#12-与其他容器的交互：" class="headerlink" title="12. 与其他容器的交互："></a>12. 与其他容器的交互：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T, <span class="hljs-keyword">class</span> Alloc&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(vector&lt;T,Alloc&gt;&amp; x, vector&lt;T,Alloc&gt;&amp; y)</span> <span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment">// 交换x和y的元素</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">std::<span class="hljs-built_in">iter_swap</span>(vec.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, vec.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>);<br>std::<span class="hljs-built_in">swap</span>(vec[<span class="hljs-number">1</span>], vec[<span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><h3 id="1-构造函数：-2"><a href="#1-构造函数：-2" class="headerlink" title="1. 构造函数："></a>1. 构造函数：</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">array</span>(); <span class="hljs-comment">// 默认构造函数，创建一个空的array</span><br><span class="hljs-built_in">array</span>(const array&amp; other); <span class="hljs-comment">// 复制构造函数，用other的副本构造一个新的array</span><br><span class="hljs-built_in">array</span>(array&amp;&amp; other) noexcept; <span class="hljs-comment">// 移动构造函数，用other的右值引用构造一个新的array</span><br><span class="hljs-built_in">array</span>(const value_type&amp; value); <span class="hljs-comment">// 构造一个包含N个元素的array，每个元素的值为value</span><br><span class="hljs-built_in">array</span>(initializer_list&lt;value_type&gt; init); <span class="hljs-comment">// 使用initializer_list对象中的元素创建array</span><br></code></pre></td></tr></table></figure><h3 id="2-访问元素："><a href="#2-访问元素：" class="headerlink" title="2. 访问元素："></a>2. 访问元素：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">reference <span class="hljs-title">at</span>(<span class="hljs-params">size_type pos</span>)</span>; <span class="hljs-comment">// 返回下标为pos的元素的引用，如果pos超出array的范围，抛出std::out_of_range异常</span><br><span class="hljs-function">const_reference <span class="hljs-title">at</span>(<span class="hljs-params">size_type pos</span>) <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回下标为pos的元素的常量引用，如果pos超出array的范围，抛出std::out_of_range异常</span><br><span class="hljs-function">reference <span class="hljs-title">front</span>()</span>; <span class="hljs-comment">// 返回array的第一个元素的引用</span><br><span class="hljs-function">const_reference <span class="hljs-title">front</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回array的第一个元素的常量引用</span><br><span class="hljs-function">reference <span class="hljs-title">back</span>()</span>; <span class="hljs-comment">// 返回array的最后一个元素的引用</span><br><span class="hljs-function">const_reference <span class="hljs-title">back</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回array的最后一个元素的常量引用</span><br><span class="hljs-function">pointer <span class="hljs-title">data</span>()</span>; <span class="hljs-comment">// 返回指向array中第一个元素的指针</span><br><span class="hljs-function">const_pointer <span class="hljs-title">data</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向array中第一个元素的常量指针</span><br>reference <span class="hljs-keyword">operator</span>[](size_type pos); <span class="hljs-comment">// 返回下标为pos的元素的引用</span><br>const_reference <span class="hljs-keyword">operator</span>[](size_type pos) <span class="hljs-keyword">const</span>; <span class="hljs-comment">// 返回下标为pos的元素的常量引用</span><br></code></pre></td></tr></table></figure><h3 id="3-修改元素："><a href="#3-修改元素：" class="headerlink" title="3. 修改元素："></a>3. 修改元素：</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fill</span><span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; value)</span></span>; <span class="hljs-comment">// 将所有元素的值设为value</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(array&amp; other)</span></span>; <span class="hljs-comment">// 交换array中的元素和other中的元素</span><br></code></pre></td></tr></table></figure><h3 id="4-容量和大小："><a href="#4-容量和大小：" class="headerlink" title="4. 容量和大小："></a>4. 容量和大小：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">size_type <span class="hljs-title">size</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回array中元素的个数，即N</span><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">empty</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 如果array为空，返回true，否则返回false</span><br><span class="hljs-function">size_type <span class="hljs-title">max_size</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回array最多可以容纳的元素个数，即N</span><br></code></pre></td></tr></table></figure><h3 id="5-比较操作："><a href="#5-比较操作：" class="headerlink" title="5. 比较操作："></a>5. 比较操作：</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">bool</span> operator==(<span class="hljs-keyword">const</span> <span class="hljs-built_in">array</span>&amp; other) <span class="hljs-keyword">const</span>; <span class="hljs-comment">// 判断当前array和other是否相等</span><br><span class="hljs-built_in">bool</span> operator!=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">array</span>&amp; other) <span class="hljs-keyword">const</span>; <span class="hljs-comment">// 判断当前array和other是否不相等</span><br><span class="hljs-built_in">bool</span> operator&lt;(<span class="hljs-keyword">const</span> <span class="hljs-built_in">array</span>&amp; other) <span class="hljs-keyword">const</span>; <span class="hljs-comment">// 判断当前array是否小于other</span><br><span class="hljs-built_in">bool</span> operator&lt;=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">array</span>&amp; other) <span class="hljs-keyword">const</span>; <span class="hljs-comment">// 判断当前array是否小于等于other</span><br><span class="hljs-built_in">bool</span> operator&gt;(<span class="hljs-keyword">const</span> <span class="hljs-built_in">array</span>&amp; other) <span class="hljs-keyword">const</span>; <span class="hljs-comment">// 判断当前array是否大于other</span><br><span class="hljs-built_in">bool</span> operator&gt;=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">array</span>&amp; other) <span class="hljs-keyword">const</span>; <span class="hljs-comment">// 判断当前array是否大于等于other</span><br></code></pre></td></tr></table></figure><h3 id="6-插入和删除元素："><a href="#6-插入和删除元素：" class="headerlink" title="6. 插入和删除元素："></a>6. 插入和删除元素：</h3><p><code>std::array</code>的容量是固定的，因此不能像<code>std::vector</code>那样插入或删除元素。</p><h3 id="7-迭代器："><a href="#7-迭代器：" class="headerlink" title="7. 迭代器："></a>7. 迭代器：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">iterator <span class="hljs-title">begin</span>()</span>; <span class="hljs-comment">// 返回指向第一个元素的迭代器</span><br><span class="hljs-function">const_iterator <span class="hljs-title">begin</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向第一个元素的常量迭代器</span><br><span class="hljs-function">const_iterator <span class="hljs-title">cbegin</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向第一个元素的常量迭代器</span><br><span class="hljs-function">iterator <span class="hljs-title">end</span>()</span>; <span class="hljs-comment">// 返回指向最后一个元素的下一个位置的迭代器</span><br><span class="hljs-function">const_iterator <span class="hljs-title">end</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向最后一个元素的下一个位置的常量迭代器</span><br><span class="hljs-function">const_iterator <span class="hljs-title">cend</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向最后一个元素的下一个位置的常量迭代器</span><br><span class="hljs-function">reverse_iterator <span class="hljs-title">rbegin</span>()</span>; <span class="hljs-comment">// 返回指向最后一个元素的迭代器</span><br><span class="hljs-function">const_reverse_iterator <span class="hljs-title">rbegin</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向最后一个元素的常量迭代器</span><br><span class="hljs-function">const_reverse_iterator <span class="hljs-title">crbegin</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向最后一个元素的常量迭代器</span><br><span class="hljs-function">reverse_iterator <span class="hljs-title">rend</span>()</span>; <span class="hljs-comment">// 返回指向第一个元素的前一个位置的迭代器</span><br><span class="hljs-function">const_reverse_iterator <span class="hljs-title">rend</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向第一个元素的前一个位置的常量迭代器</span><br><span class="hljs-function">const_reverse_iterator <span class="hljs-title">crend</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向第一个元素的前一个位置的常量迭代器</span><br></code></pre></td></tr></table></figure><h3 id="8-其他操作："><a href="#8-其他操作：" class="headerlink" title="8. 其他操作："></a>8. 其他操作：</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">void swap(<span class="hljs-built_in">array</span>&amp; <span class="hljs-built_in">lhs</span>, <span class="hljs-built_in">array</span>&amp; <span class="hljs-built_in">rhs</span>); // 交换<span class="hljs-built_in">lhs</span>和<span class="hljs-built_in">rhs</span>中的元素<br></code></pre></td></tr></table></figure><p>注意：<code>std::array</code>的元素类型必须是可复制的（CopyAssignable），因为<code>std::array</code>的复制构造函数和赋值操作符会复制每个元素。如果元素类型不支持复制操作，则不能用于<code>std::array</code>。</p><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><h3 id="1-构造函数：-3"><a href="#1-构造函数：-3" class="headerlink" title="1. 构造函数："></a>1. 构造函数：</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">deque</span>(); <span class="hljs-comment">// 构造一个空的deque</span><br><span class="hljs-built_in">deque</span>(size_type count); <span class="hljs-comment">// 构造一个包含count个元素的deque，元素的值为默认值</span><br><span class="hljs-built_in">deque</span>(size_type count, const value_type&amp; value); <span class="hljs-comment">// 构造一个包含count个元素的deque，元素的值为value</span><br><span class="hljs-built_in">deque</span>(const deque&amp; other); <span class="hljs-comment">// 复制构造函数，用other的副本构造一个新的deque</span><br><span class="hljs-built_in">deque</span>(deque&amp;&amp; other) noexcept; <span class="hljs-comment">// 移动构造函数，用other的右值引用构造一个新的deque</span><br><span class="hljs-built_in">deque</span>(initializer_list&lt;value_type&gt; init); <span class="hljs-comment">// 使用initializer_list对象中的元素创建deque</span><br>template&lt;class InputIt&gt; <span class="hljs-built_in">deque</span>(InputIt first, InputIt last); <span class="hljs-comment">// 从迭代器范围[first, last)中的元素创建deque</span><br></code></pre></td></tr></table></figure><h3 id="2-插入和删除元素："><a href="#2-插入和删除元素：" class="headerlink" title="2. 插入和删除元素："></a>2. 插入和删除元素：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_front</span><span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; value)</span></span>; <span class="hljs-comment">// 在deque的前面插入一个元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; value)</span></span>; <span class="hljs-comment">// 在deque的后面插入一个元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">emplace_front</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span>; <span class="hljs-comment">// 在deque的前面插入一个元素，使用参数args构造元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">emplace_back</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span>; <span class="hljs-comment">// 在deque的后面插入一个元素，使用参数args构造元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 删除deque的第一个元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_back</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 删除deque的最后一个元素</span><br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(const_iterator pos, <span class="hljs-type">const</span> value_type&amp; value)</span></span>; <span class="hljs-comment">// 在pos处插入一个元素，并返回指向该元素的迭代器</span><br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(const_iterator pos, size_type count, <span class="hljs-type">const</span> value_type&amp; value)</span></span>; <span class="hljs-comment">// 在pos处插入count个值为value的元素，并返回指向第一个新元素的迭代器</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> InputIt&gt; iterator <span class="hljs-title">insert</span><span class="hljs-params">(const_iterator pos, InputIt first, InputIt last)</span></span>; <span class="hljs-comment">// 在pos处插入迭代器[first, last)中的元素，并返回指向第一个新元素的迭代器</span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(const_iterator pos)</span></span>; <span class="hljs-comment">// 删除pos处的元素，并返回指向下一个元素的迭代器</span><br><span class="hljs-function">iterator <span class="hljs-title">erase</span><span class="hljs-params">(const_iterator first, const_iterator last)</span></span>; <span class="hljs-comment">// 删除[first, last)范围内的元素，并返回指向下一个元素的迭代器</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 删除deque中的所有元素</span><br></code></pre></td></tr></table></figure><h3 id="3-访问元素："><a href="#3-访问元素：" class="headerlink" title="3. 访问元素："></a>3. 访问元素：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">reference <span class="hljs-title">front</span>()</span>; <span class="hljs-comment">// 返回deque的第一个元素的引用</span><br><span class="hljs-function">const_reference <span class="hljs-title">front</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回deque的第一个元素的常量引用</span><br><span class="hljs-function">reference <span class="hljs-title">back</span>()</span>; <span class="hljs-comment">// 返回deque的最后一个元素的引用</span><br><span class="hljs-function">const_reference <span class="hljs-title">back</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回deque的最后一个元素的常量引用</span><br>reference <span class="hljs-keyword">operator</span>[](size_type pos); <span class="hljs-comment">// 返回下标为pos的元素的引用</span><br>const_reference <span class="hljs-keyword">operator</span>[](size_type pos) <span class="hljs-keyword">const</span>; <span class="hljs-comment">// 返回下标为pos的元素的常量引用</span><br><span class="hljs-function">reference <span class="hljs-title">at</span>(<span class="hljs-params">size_type pos</span>)</span>; <span class="hljs-comment">// 返回下标为pos的元素的引用，如果pos超出deque的范围，抛出std::out_of_range异常</span><br><span class="hljs-function">const_reference <span class="hljs-title">at</span>(<span class="hljs-params">size_type pos</span>) <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回下标为pos的元素的常量引用，如果pos超出deque的范围，抛出std::out_of_range异常</span><br></code></pre></td></tr></table></figure><h3 id="4-容量和大小：-1"><a href="#4-容量和大小：-1" class="headerlink" title="4. 容量和大小："></a>4. 容量和大小：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">empty</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 如果deque为空，返回true，否则返回false</span><br><span class="hljs-function">size_type <span class="hljs-title">size</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回deque中的元素个数</span><br><span class="hljs-function">size_type <span class="hljs-title">max_size</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回deque最多可以容纳的元素个数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shrink_to_fit</span>()</span>; <span class="hljs-comment">// 释放deque多余的内存，将它的capacity缩小到等于size</span><br></code></pre></td></tr></table></figure><h3 id="5-迭代器："><a href="#5-迭代器：" class="headerlink" title="5. 迭代器："></a>5. 迭代器：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">iterator <span class="hljs-title">begin</span>()</span>; <span class="hljs-comment">// 返回指向第一个元素的迭代器</span><br><span class="hljs-function">const_iterator <span class="hljs-title">begin</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向第一个元素的常量迭代器</span><br><span class="hljs-function">const_iterator <span class="hljs-title">cbegin</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向第一个元素的常量迭代器</span><br><span class="hljs-function">iterator <span class="hljs-title">end</span>()</span>; <span class="hljs-comment">// 返回指向最后一个元素的下一个位置的迭代器</span><br><span class="hljs-function">const_iterator <span class="hljs-title">end</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向最后一个元素的下一个位置的常量迭代器</span><br><span class="hljs-function">const_iterator <span class="hljs-title">cend</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向最后一个元素的下一个位置的常量迭代器</span><br><span class="hljs-function">reverse_iterator <span class="hljs-title">rbegin</span>()</span>; <span class="hljs-comment">// 返回指向最后一个元素的迭代器</span><br><span class="hljs-function">const_reverse_iterator <span class="hljs-title">rbegin</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向最后一个元素的常量迭代器</span><br><span class="hljs-function">const_reverse_iterator <span class="hljs-title">crbegin</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向最后一个元素的常量迭代器</span><br><span class="hljs-function">reverse_iterator <span class="hljs-title">rend</span>()</span>; <span class="hljs-comment">// 返回指向第一个元素的前一个位置的迭代器</span><br><span class="hljs-function">const_reverse_iterator <span class="hljs-title">rend</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向第一个元素的前一个位置的常量迭代器</span><br><span class="hljs-function">const_reverse_iterator <span class="hljs-title">crend</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向第一个元素的前一个位置的常量迭代器</span><br></code></pre></td></tr></table></figure><h3 id="6-修改容量："><a href="#6-修改容量：" class="headerlink" title="6. 修改容量："></a>6. 修改容量：</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">void</span> <span class="hljs-built_in">resize</span>(size_type <span class="hljs-built_in">count</span>); <span class="hljs-comment">// 将deque的元素个数调整为count，多余的元素会被删除</span><br><span class="hljs-keyword">void</span> <span class="hljs-built_in">resize</span>(size_type <span class="hljs-built_in">count</span>, const value_type&amp; value); <span class="hljs-comment">// 将deque的元素个数调整为count，多余的元素会被删除，新元素的值为value</span><br><span class="hljs-keyword">void</span> reserve(size_type new_cap); <span class="hljs-comment">// 将deque的容量调整为new_cap，如果new_cap小于等于deque当前的容量，该函数不会做任何操作</span><br></code></pre></td></tr></table></figure><h3 id="7-比较操作："><a href="#7-比较操作：" class="headerlink" title="7. 比较操作："></a>7. 比较操作：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> deque&amp; other) <span class="hljs-type">const</span>; <span class="hljs-comment">// 判断当前deque和other是否相等</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> deque&amp; other) <span class="hljs-type">const</span>; <span class="hljs-comment">// 判断当前deque和other是否不相等</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> deque&amp; other) <span class="hljs-type">const</span>; <span class="hljs-comment">// 判断当前deque是否小于other</span><br><span class="hljs-type">bool</span> <span class="hljs-built_in">operator</span>&lt;=(<span class="hljs-type">const</span> deque&amp; other) <span class="hljs-type">const</span>; <span class="hljs-comment">// 判断当前deque是否小于等于other</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> deque&amp; other) <span class="hljs-type">const</span>; <span class="hljs-comment">// 判断当前deque是否大于other</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> deque&amp; other) <span class="hljs-type">const</span>; <span class="hljs-comment">// 判断当前deque是否大于等于other</span><br></code></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h3 id="1-构造函数：-4"><a href="#1-构造函数：-4" class="headerlink" title="1. 构造函数："></a>1. 构造函数：</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">map</span>(); <span class="hljs-regexp">//</span> 构造一个空的<span class="hljs-keyword">map</span><br><span class="hljs-keyword">map</span>(const <span class="hljs-keyword">map</span>&amp; other); <span class="hljs-regexp">//</span> 复制构造函数，用other的副本构造一个新的<span class="hljs-keyword">map</span><br><span class="hljs-keyword">map</span>(<span class="hljs-keyword">map</span>&amp;&amp; other) noexcept; <span class="hljs-regexp">//</span> 移动构造函数，用other的右值引用构造一个新的<span class="hljs-keyword">map</span><br><span class="hljs-keyword">map</span>(initializer_list&lt;value_type&gt; init); <span class="hljs-regexp">//</span> 使用initializer_list对象中的元素创建<span class="hljs-keyword">map</span><br>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIt</span>&gt; <span class="hljs-title">map</span>(<span class="hljs-title">InputIt</span> <span class="hljs-title">first</span>, <span class="hljs-title">InputIt</span> <span class="hljs-title">last</span>)</span>; // 从迭代器范围[first, <span class="hljs-keyword">last</span>)中的元素创建<span class="hljs-keyword">map</span><br>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compare</span>&gt; <span class="hljs-title">map</span>(<span class="hljs-title">const</span> <span class="hljs-title">Compare</span>&amp; <span class="hljs-title">comp</span>)</span>; // 构造一个空的<span class="hljs-keyword">map</span>，并使用比较函数comp进行元素比较<br>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compare</span>&gt; <span class="hljs-title">map</span>(<span class="hljs-title">const</span> <span class="hljs-title">Compare</span>&amp; <span class="hljs-title">comp</span>, <span class="hljs-title">const</span> <span class="hljs-title">allocator_type</span>&amp; <span class="hljs-title">alloc</span>)</span>; // 构造一个空的<span class="hljs-keyword">map</span>，并使用比较函数comp进行元素比较，使用分配器alloc分配内存<br></code></pre></td></tr></table></figure><h3 id="2-插入和删除元素：-1"><a href="#2-插入和删除元素：-1" class="headerlink" title="2. 插入和删除元素："></a>2. 插入和删除元素：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">pair&lt;iterator, <span class="hljs-type">bool</span>&gt; <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; value)</span></span>; <span class="hljs-comment">// 在map中插入一个元素，返回一个pair对象，第一个元素是指向新元素的迭代器，第二个元素表示插入是否成功</span><br><span class="hljs-function">iterator <span class="hljs-title">insert</span><span class="hljs-params">(const_iterator hint, <span class="hljs-type">const</span> value_type&amp; value)</span></span>; <span class="hljs-comment">// 在hint处插入一个元素，返回指向新元素的迭代器</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(initializer_list&lt;value_type&gt; init)</span></span>; <span class="hljs-comment">// 使用initializer_list对象中的元素插入map</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> InputIt&gt; <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(InputIt first, InputIt last)</span></span>; <span class="hljs-comment">// 插入迭代器范围[first, last)中的元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(iterator pos)</span></span>; <span class="hljs-comment">// 删除pos处的元素</span><br><span class="hljs-function">size_type <span class="hljs-title">erase</span><span class="hljs-params">(<span class="hljs-type">const</span> key_type&amp; key)</span></span>; <span class="hljs-comment">// 删除键为key的元素，返回删除的元素个数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(iterator first, iterator last)</span></span>; <span class="hljs-comment">// 删除[first, last)范围内的元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 删除map中的所有元素</span><br></code></pre></td></tr></table></figure><h3 id="3-访问元素：-1"><a href="#3-访问元素：-1" class="headerlink" title="3. 访问元素："></a>3. 访问元素：</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xquery">mapped_type&amp; operator[](const key_type&amp;<span class="hljs-built_in"> key</span>); // 返回键<span class="hljs-built_in">为key</span>的元素的引用，如<span class="hljs-built_in">果key</span>不存在，会插入一个键<span class="hljs-built_in">为key</span>，值为mapped_type()的新元素<br>mapped_type&amp; <span class="hljs-keyword">at</span>(const key_type&amp;<span class="hljs-built_in"> key</span>); // 返回键<span class="hljs-built_in">为key</span>的元素的引用，如<span class="hljs-built_in">果key</span>不存在，抛出std::out_of_range异常<br>const mapped_type&amp; <span class="hljs-keyword">at</span>(const key_type&amp;<span class="hljs-built_in"> key</span>) const; // 返回键<span class="hljs-built_in">为key</span>的元素的常量引用，如<span class="hljs-built_in">果key</span>不存在，抛出std::out_of_range异常<br>iterator find(const key_type&amp;<span class="hljs-built_in"> key</span>); // 查找键<span class="hljs-built_in">为key</span>的元素，返回指向该元素的迭代器，如<span class="hljs-built_in">果key</span>不存在，返回<span class="hljs-built_in">map::end()</span><br><span class="hljs-built_in">const_iterator find</span>(const key_type&amp;<span class="hljs-built_in"> key</span>) const; // 查找键<span class="hljs-built_in">为key</span>的元素，返回指向该元素的常量迭代器，如<span class="hljs-built_in">果key</span>不存在，返回<span class="hljs-built_in">map::end()</span><br><span class="hljs-built_in">size_type count(const key_type&amp; key) const; // 返回键为key的元素的个数，因为map中每个键最多只能对应一个元素，因此返回值只可能是0或1</span><br><span class="hljs-built_in">bool contains</span>(const key_type&amp;<span class="hljs-built_in"> key</span>) const; // 判断<span class="hljs-keyword">map</span>中是否包含键<span class="hljs-built_in">为key</span>的元素，等价<span class="hljs-built_in">于count</span><span class="hljs-built_in">(key</span>) != <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="4-迭代器："><a href="#4-迭代器：" class="headerlink" title="4. 迭代器："></a>4. 迭代器：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">iterator <span class="hljs-title">begin</span>()</span>; <span class="hljs-comment">// 返回指向第一个元素的迭代器</span><br><span class="hljs-function">const_iterator <span class="hljs-title">begin</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向第一个元素的常量迭代器</span><br><span class="hljs-function">const_iterator <span class="hljs-title">cbegin</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向第一个元素的常量迭代器</span><br><span class="hljs-function">iterator <span class="hljs-title">end</span>()</span>; <span class="hljs-comment">// 返回指向最后一个元素的下一个位置的迭代器</span><br><span class="hljs-function">const_iterator <span class="hljs-title">end</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向最后一个元素的下一个位置的常量迭代器</span><br><span class="hljs-function">const_iterator <span class="hljs-title">cend</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向最后一个元素的下一个位置的常量迭代器</span><br><span class="hljs-function">reverse_iterator <span class="hljs-title">rbegin</span>()</span>; <span class="hljs-comment">// 返回指向最后一个元素的迭代器</span><br><span class="hljs-function">const_reverse_iterator <span class="hljs-title">rbegin</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向最后一个元素的常量迭代器</span><br><span class="hljs-function">const_reverse_iterator <span class="hljs-title">crbegin</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向最后一个元素的常量迭代器</span><br><span class="hljs-function">reverse_iterator <span class="hljs-title">rend</span>()</span>; <span class="hljs-comment">// 返回指向第一个元素的前一个位置的迭代器</span><br><span class="hljs-function">const_reverse_iterator <span class="hljs-title">rend</span>()<span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向第一个元素的前一个位置的常量迭代器</span><br><span class="hljs-function">const_reverse_iterator <span class="hljs-title">crend</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回指向第一个元素的前一个位置的常量迭代器</span><br></code></pre></td></tr></table></figure><h3 id="5-容量："><a href="#5-容量：" class="headerlink" title="5. 容量："></a>5. 容量：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">empty</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 判断map是否为空，即是否含有任何元素</span><br><span class="hljs-function">size_type <span class="hljs-title">size</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回map中元素的个数</span><br><span class="hljs-function">size_type <span class="hljs-title">max_size</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回map中最大元素个数，取决于分配器和计算机架构</span><br></code></pre></td></tr></table></figure><h3 id="6-比较和交换："><a href="#6-比较和交换：" class="headerlink" title="6. 比较和交换："></a>6. 比较和交换：</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> map&amp; other) <span class="hljs-type">const</span>; <span class="hljs-comment">// 判断当前map是否等于另一个map</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> map&amp; other) <span class="hljs-type">const</span>; <span class="hljs-comment">// 判断当前map是否不等于另一个map</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(map&amp; other)</span></span>; <span class="hljs-comment">// 交换当前map和另一个map中的元素</span><br></code></pre></td></tr></table></figure><h3 id="7-分配器："><a href="#7-分配器：" class="headerlink" title="7. 分配器："></a>7. 分配器：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">allocator_type <span class="hljs-title">get_allocator</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回当前map使用的分配器对象</span><br></code></pre></td></tr></table></figure><h3 id="8-键和值的访问："><a href="#8-键和值的访问：" class="headerlink" title="8. 键和值的访问："></a>8. 键和值的访问：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">key_compare <span class="hljs-title">key_comp</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 返回当前map使用的键比较函数</span><br><span class="hljs-function">value_compare <span class="hljs-title">value_comp</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 返回当前map使用的元素比较函数</span><br><span class="hljs-function"><span class="hljs-type">const</span> key_type&amp; <span class="hljs-title">rbegin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 返回map中最小的键</span><br><span class="hljs-function"><span class="hljs-type">const</span> key_type&amp; <span class="hljs-title">rend</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 返回map中最大的键</span><br><span class="hljs-function"><span class="hljs-type">const</span> mapped_type&amp; <span class="hljs-title">front</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 返回map中最小的值</span><br><span class="hljs-function"><span class="hljs-type">const</span> mapped_type&amp; <span class="hljs-title">back</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 返回map中最大的值</span><br></code></pre></td></tr></table></figure><h3 id="9-辅助函数："><a href="#9-辅助函数：" class="headerlink" title="9. 辅助函数："></a>9. 辅助函数：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">empty</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 判断map是否为空，即是否含有任何元素</span><br><span class="hljs-function">size_type <span class="hljs-title">size</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回map中元素的个数</span><br><span class="hljs-function">size_type <span class="hljs-title">max_size</span>() <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// 返回map中最大元素个数，取决于分配器和计算机架构</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span>()</span>; <span class="hljs-comment">// 删除map中的所有元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span>(<span class="hljs-params">map&amp; other</span>)</span>; <span class="hljs-comment">// 交换当前map和另一个map中的元素</span><br></code></pre></td></tr></table></figure><h3 id="10-相邻元素的访问："><a href="#10-相邻元素的访问：" class="headerlink" title="10. 相邻元素的访问："></a>10. 相邻元素的访问：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">iterator <span class="hljs-title">lower_bound</span><span class="hljs-params">(<span class="hljs-type">const</span> key_type&amp; key)</span></span>; <span class="hljs-comment">// 返回一个迭代器，指向第一个大于等于key的元素</span><br><span class="hljs-function">const_iterator <span class="hljs-title">lower_bound</span><span class="hljs-params">(<span class="hljs-type">const</span> key_type&amp; key)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 返回一个常量迭代器，指向第一个大于等于key的元素</span><br><span class="hljs-function">iterator <span class="hljs-title">upper_bound</span><span class="hljs-params">(<span class="hljs-type">const</span> key_type&amp; key)</span></span>; <span class="hljs-comment">// 返回一个迭代器，指向第一个大于key的元素</span><br><span class="hljs-function">const_iterator <span class="hljs-title">upper_bound</span><span class="hljs-params">(<span class="hljs-type">const</span> key_type&amp; key)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 返回一个常量迭代器，指向第一个大于key的元素</span><br><span class="hljs-function">pair&lt;iterator, iterator&gt; <span class="hljs-title">equal_range</span><span class="hljs-params">(<span class="hljs-type">const</span> key_type&amp; key)</span></span>; <span class="hljs-comment">// 返回一个pair对象，第一个元素是迭代器，指向第一个等于key的元素，第二个元素是迭代器，指向第一个大于key的元素</span><br><span class="hljs-function">pair&lt;const_iterator, const_iterator&gt; <span class="hljs-title">equal_range</span><span class="hljs-params">(<span class="hljs-type">const</span> key_type&amp; key)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 返回一个pair对象，第一个元素是常量迭代器，指向第一个等于key的元素，第二个元素是常量迭代器，指向第一个大于key的元素</span><br></code></pre></td></tr></table></figure><h3 id="11-比较运算符："><a href="#11-比较运算符：" class="headerlink" title="11. 比较运算符："></a>11. 比较运算符：</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> map&amp; other) <span class="hljs-type">const</span>; <span class="hljs-comment">// 判断当前map是否小于另一个map</span><br><span class="hljs-type">bool</span> <span class="hljs-built_in">operator</span>&lt;=(<span class="hljs-type">const</span> map&amp; other) <span class="hljs-type">const</span>; <span class="hljs-comment">// 判断当前map是否小于等于另一个map</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> map&amp; other) <span class="hljs-type">const</span>; <span class="hljs-comment">// 判断当前map是否大于另一个map</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> map&amp; other) <span class="hljs-type">const</span>; <span class="hljs-comment">// 判断当前map是否大于等于另一个map</span><br></code></pre></td></tr></table></figure><h3 id="12-按照键，值排序"><a href="#12-按照键，值排序" class="headerlink" title="12. 按照键，值排序"></a>12. 按照键，值排序</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyCompare</span> &#123;<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; lhs, <span class="hljs-type">const</span> std::string&amp; rhs)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">size</span>() &lt; rhs.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 按照字符串长度升序排序</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::map&lt;std::string, <span class="hljs-type">int</span>, MyCompare&gt; myMap = &#123;&#123;<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&quot;defg&quot;</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&quot;hijkl&quot;</span>, <span class="hljs-number">3</span>&#125;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; kv : myMap) &#123;<br>    std::cout &lt;&lt; kv.first &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span> &lt;&lt; kv.second &lt;&lt; std::endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;<br>std::vector&lt;std::pair&lt;K, V&gt;&gt; <span class="hljs-built_in">sort_map_by_value</span>(<span class="hljs-type">const</span> std::map&lt;K, V&gt;&amp; map) &#123;<br>  std::vector&lt;std::pair&lt;K, V&gt;&gt; vec;<br>  vec.<span class="hljs-built_in">reserve</span>(map.<span class="hljs-built_in">size</span>());<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; kv : map) &#123;<br>    vec.<span class="hljs-built_in">emplace_back</span>(kv.first, kv.second);<br>  &#125;<br>  std::<span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; lhs, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; rhs) &#123;<br>    <span class="hljs-keyword">return</span> lhs.second &lt; rhs.second;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> vec;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::map&lt;std::string, <span class="hljs-type">int</span>&gt; myMap = &#123;&#123;<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-number">5</span>&#125;, &#123;<span class="hljs-string">&quot;baz&quot;</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>  <span class="hljs-keyword">auto</span> sortedVec = <span class="hljs-built_in">sort_map_by_value</span>(myMap);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; kv : sortedVec) &#123;<br>    std::cout &lt;&lt; kv.first &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span> &lt;&lt; kv.second &lt;&lt; std::endl;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-运算符重载"><a href="#13-运算符重载" class="headerlink" title="13. 运算符重载"></a>13. 运算符重载</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInt</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">MyInt</span>(<span class="hljs-type">int</span> value = <span class="hljs-number">0</span>) : <span class="hljs-built_in">value_</span>(value) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> value_; &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> value_;<br><br>  <span class="hljs-keyword">friend</span> MyInt <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> MyInt&amp; lhs, <span class="hljs-type">const</span> MyInt&amp; rhs);<br>&#125;;<br><br>MyInt <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> MyInt&amp; lhs, <span class="hljs-type">const</span> MyInt&amp; rhs) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">MyInt</span>(lhs.value_ + rhs.value_);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h3 id="1-插入元素"><a href="#1-插入元素" class="headerlink" title="1. 插入元素"></a>1. 插入元素</h3><ul><li><code>insert(val)</code>：向<code>std::set</code>中插入一个值为<code>val</code>的元素。</li><li><code>insert(first, last)</code>：向<code>std::set</code>中插入区间<code>[first, last)</code>中的所有元素。</li><li><code>emplace(args...)</code>：通过传递参数<code>args</code>构造一个新的元素，并将其插入<code>std::set</code>中。</li><li><code>emplace_hint(hint, args...)</code>：通过传递参数<code>args</code>构造一个新的元素，并将其插入<code>std::set</code>中。插入位置的提示迭代器为<code>hint</code>。</li></ul><h3 id="2-删除元素"><a href="#2-删除元素" class="headerlink" title="2. 删除元素"></a>2. 删除元素</h3><ul><li><code>erase(val)</code>：从<code>std::set</code>中删除值为<code>val</code>的元素。</li><li><code>erase(pos)</code>：从<code>std::set</code>中删除迭代器<code>pos</code>指向的元素。</li><li><code>erase(first, last)</code>：从<code>std::set</code>中删除区间<code>[first, last)</code>中的所有元素。</li><li><code>clear()</code>：删除<code>std::set</code>中的所有元素。</li></ul><h3 id="3-访问元素"><a href="#3-访问元素" class="headerlink" title="3. 访问元素"></a>3. 访问元素</h3><ul><li><code>find(val)</code>：查找值为<code>val</code>的元素，返回该元素的迭代器，如果不存在，则返回<code>std::set::end()</code>。</li><li><code>count(val)</code>：返回<code>std::set</code>中值为<code>val</code>的元素的个数，由于<code>std::set</code>中元素的值都不相同，因此返回值只能是<code>0</code>或<code>1</code>。</li><li><code>lower_bound(val)</code>：返回一个迭代器，指向<code>std::set</code>中第一个不小于<code>val</code>的元素。</li><li><code>upper_bound(val)</code>：返回一个迭代器，指向<code>std::set</code>中第一个大于<code>val</code>的元素。</li><li><code>equal_range(val)</code>：返回一个<code>std::pair</code>对象，该对象包含两个迭代器。第一个迭代器指向<code>std::set</code>中第一个等于<code>val</code>的元素，如果不存在，则指向下一个大于<code>val</code>的元素；第二个迭代器指向<code>std::set</code>中第一个大于<code>val</code>的元素。</li></ul><h3 id="4-容量和状态"><a href="#4-容量和状态" class="headerlink" title="4. 容量和状态"></a>4. 容量和状态</h3><ul><li><code>size()</code>：返回<code>std::set</code>中元素的个数。</li><li><code>empty()</code>：如果<code>std::set</code>为空，则返回<code>true</code>，否则返回<code>false</code>。</li></ul><h3 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5. 迭代器"></a>5. 迭代器</h3><ul><li><code>begin()</code>：返回指向<code>std::set</code>中第一个元素的迭代器。</li><li><code>end()</code>：返回指向<code>std::set</code>中最后一个元素之后的迭代器。</li><li><code>rbegin()</code>：返回指向<code>std::set</code>中最后一个元素的迭代器。</li><li><code>rend()</code>：返回指向<code>std::set</code>中第一个元素之前的迭代器。</li></ul><h3 id="6-其他操作"><a href="#6-其他操作" class="headerlink" title="6. 其他操作"></a>6. 其他操作</h3><ul><li><code>swap(otherSet)</code>：交换<code>std::set</code>和<code>otherSet</code>中的元素。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set<span class="hljs-number">1.</span><span class="hljs-built_in">swap</span>(set2);<br>std::<span class="hljs-built_in">swap</span>(set1, set2);<br></code></pre></td></tr></table></figure><h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h2><p><code>std::multimap</code>是C++ STL中的一个关联容器，用于存储一组按照某种规则排序的键值对，并且允许键值可以重复。下面是<code>std::multimap</code>支持的所有操作：</p><h3 id="1-插入元素-1"><a href="#1-插入元素-1" class="headerlink" title="1. 插入元素"></a>1. 插入元素</h3><ul><li><code>insert(val)</code>：向<code>std::multimap</code>中插入一个值为<code>val</code>的键值对。</li><li><code>insert(first, last)</code>：向<code>std::multimap</code>中插入区间<code>[first, last)</code>中的所有键值对。</li><li><code>emplace(args...)</code>：通过传递参数<code>args</code>构造一个新的键值对，并将其插入<code>std::multimap</code>中。</li><li><code>emplace_hint(hint, args...)</code>：通过传递参数<code>args</code>构造一个新的键值对，并将其插入<code>std::multimap</code>中。插入位置的提示迭代器为<code>hint</code>。</li></ul><h3 id="2-删除元素-1"><a href="#2-删除元素-1" class="headerlink" title="2. 删除元素"></a>2. 删除元素</h3><ul><li><code>erase(key)</code>：从<code>std::multimap</code>中删除所有键为<code>key</code>的键值对。</li><li><code>erase(pos)</code>：从<code>std::multimap</code>中删除迭代器<code>pos</code>指向的键值对。</li><li><code>erase(first, last)</code>：从<code>std::multimap</code>中删除区间<code>[first, last)</code>中的所有键值对。</li><li><code>clear()</code>：删除<code>std::multimap</code>中的所有键值对。</li></ul><h3 id="3-访问元素-1"><a href="#3-访问元素-1" class="headerlink" title="3. 访问元素"></a>3. 访问元素</h3><ul><li><code>find(key)</code>：查找键为<code>key</code>的第一个键值对，返回该键值对的迭代器，如果不存在，则返回<code>std::multimap::end()</code>。</li><li><code>count(key)</code>：返回<code>std::multimap</code>中键为<code>key</code>的键值对的个数。</li><li><code>lower_bound(key)</code>：返回一个迭代器，指向<code>std::multimap</code>中第一个键不小于<code>key</code>的键值对。</li><li><code>upper_bound(key)</code>：返回一个迭代器，指向<code>std::multimap</code>中第一个键大于<code>key</code>的键值对。</li><li><code>equal_range(key)</code>：返回一个<code>std::pair</code>对象，该对象包含两个迭代器。第一个迭代器指向<code>std::multimap</code>中第一个键等于<code>key</code>的键值对，如果不存在，则指向下一个大于<code>key</code>的键值对；第二个迭代器指向<code>std::multimap</code>中第一个大于<code>key</code>的键值对。</li></ul><h3 id="4-容量和状态-1"><a href="#4-容量和状态-1" class="headerlink" title="4. 容量和状态"></a>4. 容量和状态</h3><ul><li><code>size()</code>：返回<code>std::multimap</code>中键值对的个数。</li><li><code>empty()</code>：如果<code>std::multimap</code>为空，则返回<code>true</code>，否则返回<code>false</code>。</li></ul><h3 id="5-迭代器-1"><a href="#5-迭代器-1" class="headerlink" title="5. 迭代器"></a>5. 迭代器</h3><ul><li><code>begin()</code>：返回指向<code>std::multimap</code>中第一个键值对的迭代器。</li><li><code>end()</code>：返回指向<code>std::multimap</code>中最后一个键值对之后的迭代器。</li><li><code>rbegin()</code>：返回指向<code>std::multimap</code>中最后一个键值对的迭代器。</li><li><code>rend()</code>：返回指向<code>std::multimap</code>中第一个键值对之前的迭代器。</li></ul><h3 id="6-其他操作-1"><a href="#6-其他操作-1" class="headerlink" title="6. 其他操作"></a>6. 其他操作</h3><ul><li><code>swap(otherMultimap)</code>：交换<code>std::multimap</code>和<code>otherMultimap</code>中的键值对。</li></ul><p>需要注意的是，<code>std::multimap</code>中的元素可以根据键值进行排序，因此插入、删除和查找元素的复杂度取决于排序规则。如果需要根据值对进行排序，并且不允许键值重复，可以使用<code>std::map</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-comment">// 自定义比较函数，按照键值从大到小进行排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> a &gt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function">std::multimap&lt;<span class="hljs-type">int</span>, std::string, <span class="hljs-title">decltype</span><span class="hljs-params">(compare)</span>*&gt; <span class="hljs-title">myMap</span><span class="hljs-params">(compare)</span></span>;<br><br>  <span class="hljs-comment">// 向 multimap 中插入元素</span><br>  myMap.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;apple&quot;</span>));<br>  myMap.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;banana&quot;</span>));<br>  myMap.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;cherry&quot;</span>));<br>  myMap.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;date&quot;</span>));<br>  myMap.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;elderberry&quot;</span>));<br><br>  <span class="hljs-comment">// 输出 multimap 中的元素</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = myMap.<span class="hljs-built_in">begin</span>(); it != myMap.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>    std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><h3 id="1-容器适配器操作："><a href="#1-容器适配器操作：" class="headerlink" title="1. 容器适配器操作："></a>1. 容器适配器操作：</h3><ul><li><code>stack()</code>：创建一个空的<code>std::stack</code>。</li><li><code>stack(c)</code>：创建一个<code>std::stack</code>，它包含容器<code>c</code>中的所有元素。</li><li><code>empty()</code>：如果<code>std::stack</code>为空，则返回<code>true</code>，否则返回<code>false</code>。</li><li><code>size()</code>：返回<code>std::stack</code>中的元素个数。</li><li><code>swap(otherStack)</code>：将<code>std::stack</code>和<code>otherStack</code>中的元素进行交换。</li></ul><h3 id="2-元素访问操作："><a href="#2-元素访问操作：" class="headerlink" title="2. 元素访问操作："></a>2. 元素访问操作：</h3><ul><li><code>top()</code>：返回<code>std::stack</code>顶部的元素的引用（不弹出）。</li><li><code>emplace(args...)</code>：通过传递参数<code>args</code>构造一个新的元素，并将其压入<code>std::stack</code>的顶部。</li><li><code>push(val)</code>：将值为<code>val</code>的元素压入<code>std::stack</code>的顶部。</li><li><code>pop()</code>：弹出<code>std::stack</code>顶部的元素。</li></ul><h2 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h2><p><code>std::forward_list</code>是C++ STL中的一个单向链表容器，它支持在常量时间内在链表前端（头部）插入和删除元素，但在链表中间或末尾进行插入和删除操作的复杂度为线性时间。下面是<code>std::forward_list</code>支持的所有操作：</p><h3 id="1-迭代器操作："><a href="#1-迭代器操作：" class="headerlink" title="1. 迭代器操作："></a>1. 迭代器操作：</h3><ul><li><code>begin()</code>：返回指向链表第一个元素的迭代器。</li><li><code>end()</code>：返回指向链表最后一个元素之后的迭代器。</li><li><code>cbegin()</code>：返回指向链表第一个元素的<code>const</code>迭代器。</li><li><code>cend()</code>：返回指向链表最后一个元素之后的<code>const</code>迭代器。</li></ul><h3 id="2-容器操作："><a href="#2-容器操作：" class="headerlink" title="2. 容器操作："></a>2. 容器操作：</h3><ul><li><code>empty()</code>：如果<code>std::forward_list</code>为空，则返回<code>true</code>，否则返回<code>false</code>。</li><li><code>size()</code>：返回<code>std::forward_list</code>中元素的个数。</li><li><code>max_size()</code>：返回<code>std::forward_list</code>中可以容纳的最大元素数量。</li></ul><h3 id="3-访问元素操作："><a href="#3-访问元素操作：" class="headerlink" title="3. 访问元素操作："></a>3. 访问元素操作：</h3><ul><li><code>front()</code>：返回链表的第一个元素的引用。</li><li><code>before_begin()</code>：返回链表中第一个元素之前的位置的迭代器。</li><li><code>cbefore_begin()</code>：返回链表中第一个元素之前的位置的<code>const</code>迭代器。</li></ul><h3 id="4-修改容器操作："><a href="#4-修改容器操作：" class="headerlink" title="4. 修改容器操作："></a>4. 修改容器操作：</h3><ul><li><code>clear()</code>：删除<code>std::forward_list</code>中的所有元素。</li><li><code>emplace_after(pos, args...)</code>：在迭代器<code>pos</code>之后插入一个新元素，使用参数<code>args</code>构造元素。</li><li><code>erase_after(pos)</code>：删除迭代器<code>pos</code>之后的元素。</li><li><code>erase_after(first, last)</code>：删除区间<code>[first, last)</code>中的所有元素。</li><li><code>insert_after(pos, val)</code>：在迭代器<code>pos</code>之后插入一个值为<code>val</code>的新元素。</li><li><code>insert_after(pos, n, val)</code>：在迭代器<code>pos</code>之后插入<code>n</code>个值为<code>val</code>的新元素。</li><li><code>insert_after(pos, first, last)</code>：在迭代器<code>pos</code>之后插入区间<code>[first, last)</code>中的所有元素。</li><li><code>emplace_front(args...)</code>：在链表头部插入一个新元素，使用参数<code>args</code>构造元素。</li><li><code>pop_front()</code>：删除链表头部的元素。</li><li><code>push_front(val)</code>：在链表头部插入一个值为<code>val</code>的新元素。</li><li><code>resize(count)</code>：将链表的大小调整为<code>count</code>，多余的元素将被删除。</li><li><code>resize(count, val)</code>：将链表的大小调整为<code>count</code>，不足的元素将使用值为<code>val</code>的新元素进行补充。</li><li><code>reverse()</code>：颠倒链表中的元素顺序。</li><li><code>sort()</code>：对链表中的元素进行排序。</li></ul><p>需要注意的是，由于<code>std::forward_list</code>是一个单向链表容器，它不支持像双向链表那样直接访问前一个元素。如果需要访问前一个元素，可以使用<code>before_begin()</code>操作获得一个迭代器，该迭代器指向链表中第一个元素之前的位置。在此基础上，可以使用<code>++</code>操作符来访问链表中的元素。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p><code>std::list</code>是C++ STL中的一个双向链表容器，它支持在常量时间内在链表前后端插入和删除元素，并且可以在常量时间内访问任意位置的元素。下面是<code>std::list</code>支持的所有操作：</p><h3 id="1-迭代器操作：-1"><a href="#1-迭代器操作：-1" class="headerlink" title="1. 迭代器操作："></a>1. 迭代器操作：</h3><ul><li><code>begin()</code>：返回指向链表第一个元素的迭代器。</li><li><code>end()</code>：返回指向链表最后一个元素之后的迭代器。</li><li><code>rbegin()</code>：返回指向链表最后一个元素的反向迭代器。</li><li><code>rend()</code>：返回指向链表第一个元素之前的反向迭代器。</li></ul><h3 id="2-容器操作：-1"><a href="#2-容器操作：-1" class="headerlink" title="2. 容器操作："></a>2. 容器操作：</h3><ul><li><code>empty()</code>：如果<code>std::list</code>为空，则返回<code>true</code>，否则返回<code>false</code>。</li><li><code>size()</code>：返回<code>std::list</code>中元素的个数。</li><li><code>max_size()</code>：返回<code>std::list</code>中可以容纳的最大元素数量。</li></ul><h3 id="3-访问元素操作：-1"><a href="#3-访问元素操作：-1" class="headerlink" title="3. 访问元素操作："></a>3. 访问元素操作：</h3><ul><li><code>front()</code>：返回链表的第一个元素的引用。</li><li><code>back()</code>：返回链表的最后一个元素的引用。</li></ul><h3 id="4-修改容器操作：-1"><a href="#4-修改容器操作：-1" class="headerlink" title="4. 修改容器操作："></a>4. 修改容器操作：</h3><ul><li><code>clear()</code>：删除<code>std::list</code>中的所有元素。</li><li><code>emplace(pos, args...)</code>：在迭代器<code>pos</code>之前插入一个新元素，使用参数<code>args</code>构造元素。</li><li><code>erase(pos)</code>：删除迭代器<code>pos</code>处的元素。</li><li><code>erase(first, last)</code>：删除区间<code>[first, last)</code>中的所有元素。</li><li><code>insert(pos, val)</code>：在迭代器<code>pos</code>之前插入一个值为<code>val</code>的新元素。</li><li><code>insert(pos, n, val)</code>：在迭代器<code>pos</code>之前插入<code>n</code>个值为<code>val</code>的新元素。</li><li><code>insert(pos, first, last)</code>：在迭代器<code>pos</code>之前插入区间<code>[first, last)</code>中的所有元素。</li><li><code>emplace_back(args...)</code>：在链表尾部插入一个新元素，使用参数<code>args</code>构造元素。</li><li><code>emplace_front(args...)</code>：在链表头部插入一个新元素，使用参数<code>args</code>构造元素。</li><li><code>pop_back()</code>：删除链表尾部的元素。</li><li><code>pop_front()</code>：删除链表头部的元素。</li><li><code>push_back(val)</code>：在链表尾部插入一个值为<code>val</code>的新元素。</li><li><code>push_front(val)</code>：在链表头部插入一个值为<code>val</code>的新元素。</li><li><code>resize(count)</code>：将链表的大小调整为<code>count</code>，多余的元素将被删除。</li><li><code>resize(count, val)</code>：将链表的大小调整为<code>count</code>，不足的元素将使用值为<code>val</code>的新元素进行补充。</li><li><code>reverse()</code>：颠倒链表中的元素顺序。</li><li><code>sort()</code>：对链表中的元素进行排序。</li></ul><p>需要注意的是，由于<code>std::list</code>是一个双向链表容器，它支持在常量时间内在链表前后端插入和删除元素，并且可以在常量时间内访问任意位置的元素。在此基础上，它还支持反向迭代器的操作，因此可以在从后往前遍历链表时使用反向迭代器。</p><p>下面是一个示例，演示了<code>std::list</code>的基本操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::list&lt;<span class="hljs-type">int</span>&gt; myList;<br><br>  <span class="hljs-comment">// 插入元素</span><br>  myList.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>  myList.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>  myList.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>  myList.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// 输出所有元素</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = myList.<span class="hljs-built_in">begin</span>(); it != myList.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>    std::cout &lt;&lt; *it &lt;&lt; std::endl;<br>  &#125;<br><br>  <span class="hljs-comment">// 删除元素</span><br>  myList.<span class="hljs-built_in">pop_back</span>();<br>  myList.<span class="hljs-built_in">pop_front</span>();<br><br>  <span class="hljs-comment">// 插入元素</span><br>  myList.<span class="hljs-built_in">insert</span>(myList.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">4</span>);<br>  myList.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">5</span>);<br><br>  <span class="hljs-comment">// 输出所有元素</span><br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = myList.<span class="hljs-built_in">begin</span>(); it != myList.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>    std::cout &lt;&lt; *it &lt;&lt; std::endl;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们创建了一个<code>std::list</code>对象<code>myList</code>，并向其中压入一些元素。然后，我们使用迭代器遍历<code>myList</code>中的所有元素，并使用<code>pop_back()</code>和<code>pop_front()</code>操作删除链表尾部和头部的元素。接下来，我们使用<code>insert()</code>和<code>emplace_back()</code>操作在链表中插入新元素，并再次使用迭代器遍历<code>myList</code>中的所有元素，输出它们的值。</p><p>需要注意的是，<code>std::list</code>的操作大多数都是针对链表头尾的操作，因此它在某些场景下比较高效。同时，由于它是一个双向链表容器，支持在常量时间内访问任意位置的元素，因此它在某些场景下也比较实用。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2023/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/09/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>单调栈；单调队列；KMP字符串；Trie树；并查集；哈希</p><span id="more"></span><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>数组模拟比较快；<code>node</code>较慢</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// head存储链表头</span><br><span class="hljs-comment">// e[]存储节点的值</span><br><span class="hljs-comment">// ne[]存储节点的next指针</span><br><span class="hljs-comment">// idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> head, e[N], ne[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  head = <span class="hljs-number">-1</span>;<br>  idx = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 在链表头插入一个数a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>  e[idx] = a, ne[idx] = head, head = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 将头结点删除，需要保证头结点存在</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  head = ne[head];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// e[]表示节点的值</span><br><span class="hljs-comment">// l[]表示节点的左指针</span><br><span class="hljs-comment">// r[]表示节点的右指针</span><br><span class="hljs-comment">// idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> e[N], l[N], r[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 0是左端点，1是右端点</span><br>  r[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, l[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  idx = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-comment">// 在节点a的右边插入一个数x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  e[idx] = x;<br>  l[idx] = a, r[idx] = r[a];<br>  l[r[a]] = idx, r[a] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 删除节点a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>  l[r[a]] = l[a];<br>  r[l[a]] = r[a];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="普通栈"><a href="#普通栈" class="headerlink" title="普通栈"></a>普通栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// tt表示栈顶</span><br><span class="hljs-type">int</span> stk[N], tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 向栈顶插入一个数</span><br>stk[ ++ tt] = x; <br><br><span class="hljs-comment">// 从栈顶弹出一个数</span><br>tt -- ;<br><br><span class="hljs-comment">// 栈顶的值</span><br>stk[tt];<br><br><span class="hljs-comment">// 判断栈是否为空</span><br><span class="hljs-keyword">if</span> (tt &gt; <span class="hljs-number">0</span>)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>常见模型：找出每个数左边离它最近的比它大&#x2F;小的数</p><p><img src="/Assets/image-20230917211701161.png" alt="图片示例"></p><p>在上述图片中红色方框能把$3,4$推出栈是因为：</p><ol><li>$2$是在$3,4$后面</li><li>$2$比$3,4$小</li></ol><p>所以比如$3,4$能满足比$7$小，那$2$肯定能满足，而且$2$还离得比$7$近，$3,4$没有用了就被推出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-type">int</span> tt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>  <span class="hljs-comment">// 栈顶是否&lt;=当前数</span><br>  <span class="hljs-keyword">while</span> (tt &amp;&amp; <span class="hljs-built_in">check</span>(stk[tt], i)) tt -- ;<br>  <span class="hljs-comment">// 当前数插入栈中</span><br>  stk[ ++ tt] = i;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// hh 表示队头，tt表示队尾</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[ ++ tt] = x;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh ++ ;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-keyword">if</span> (hh &lt;= tt)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// hh 表示队头，tt表示队尾的后一个位置</span><br><span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">0</span>; <br><br><span class="hljs-comment">// 向队尾插入一个数</span><br>q[tt ++ ] = x;<br><span class="hljs-keyword">if</span> (tt == N) tt = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 从队头弹出一个数</span><br>hh ++ ;<br><span class="hljs-keyword">if</span> (hh == N) hh = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 队头的值</span><br>q[hh];<br><br><span class="hljs-comment">// 判断队列是否为空</span><br><span class="hljs-keyword">if</span> (hh != tt)<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>常见模型：找出滑动窗口中的最大值&#x2F;最小值</p><p><img src="/Assets/image-20230917215305172.png" alt="示例图片"></p><p>红色代表所有从左侧推出的(可以推出该队列是一个单调递增的)，黄色代表所有从右侧推出的</p><ol><li>在上述图片中，第一个红色方框能把$0,1$推出队列是因为：<ol><li>$-1$代表的下标是在$0,1$后面</li><li>$-1$比$0,1$下标查出来的值小</li></ol></li></ol><p>​所以有$-1$，则$0,1$查出来的值$1,3$就永远不会被用到了；</p><ol start="2"><li>在上述图片中，黄色方框能把$3$推出队列是因为：<ol><li>因为$k&#x3D;3$，所以下标$3$就过期了</li></ol></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// hh是左指针，tt是右指针</span><br><span class="hljs-comment">// 队列是一个单调递增的双端队列，存储的是原数组的下标值</span><br><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>  <span class="hljs-comment">// 左侧弹出：队头是否滑出窗口</span><br>  <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check_out</span>(q[hh])) hh ++ ;<br>  <span class="hljs-comment">// 右侧弹出：队列中有值比新来的大</span><br>  <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="hljs-built_in">check</span>(q[tt], i)) tt -- ;<br>  q[ ++ tt] = i;<br>  <span class="hljs-comment">// 每次获取当前窗口最小值</span><br>  cout &lt;&lt; q[hh];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="KMP字符串"><a href="#KMP字符串" class="headerlink" title="KMP字符串"></a>KMP字符串</h2><p><img src="/Assets/image-20230918092838641.png" alt="next数组解释"></p><p><img src="/Assets/image-20231013201309437.png" alt="怎么求next数组"></p><p><img src="/Assets/image-20230918092939833.png" alt="怎么用next数组"></p><p>可以发现：求next数组和用next数组采用的同一个$i,j$循环逻辑</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 求Next数组：</span><br><span class="hljs-comment">// s[]是模式串，p[]是模板串, n是s的长度，m是p的长度</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++ )<br>&#123;<br>  <span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>  <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>  ne[i] = j;<br>&#125;<br><br><span class="hljs-comment">// 匹配</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ )<br>&#123;<br>  <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>  <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>  <span class="hljs-keyword">if</span> (j == m)<br>  &#123;<br>    j = ne[j];<br>    <span class="hljs-comment">// 匹配成功后的逻辑</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>高效地<strong>存储</strong>和<strong>查找</strong>字符串集合的数据结构</p><p><img src="/Assets/image-20230918100304972.png" alt="Trie树示例"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Trie字符串统计</span><br><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>], cnt[N], idx;<br><span class="hljs-comment">// 0号点既是根节点，又是空节点</span><br><span class="hljs-comment">// son[][]存储树中每个节点的子节点</span><br><span class="hljs-comment">// son[p][u],p代表当前结点编号,u代表子结点字母</span><br><span class="hljs-comment">// cnt[]存储以每个节点结尾的单词数量</span><br><br><span class="hljs-comment">// 插入一个字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>  &#123;<br>    <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-comment">// 没有子节点则创建</span><br>    <span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;<br>    <span class="hljs-comment">// 当前父节点变为原来子节点，循环</span><br>    p = son[p][u];<br>  &#125;<br>  <span class="hljs-comment">// 存储该节点结尾的单词数量</span><br>  cnt[p] ++ ;<br>&#125; <br><br><span class="hljs-comment">// 查询字符串出现的次数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i ++ )<br>  &#123;<br>    <span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    p = son[p][u];<br>  &#125;<br>  <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><ol><li>查询操作 - 找到元素的父节点</li><li>合并操作 - 将两个集合合并</li></ol><p><img src="/Assets/image-20230918104517510.png" alt="并查集过程"></p><h3 id="朴素并查集"><a href="#朴素并查集" class="headerlink" title="朴素并查集"></a>朴素并查集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> p[N]; <br><span class="hljs-comment">// p[]存储每个点的祖宗节点</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 路径压缩</span><br>  <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>  <span class="hljs-keyword">return</span> p[x];<br>&#125; <br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) p[i] = i;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br></code></pre></td></tr></table></figure><h3 id="维护size的并查集"><a href="#维护size的并查集" class="headerlink" title="维护size的并查集"></a>维护size的并查集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> p[N], size[N];<br><span class="hljs-comment">// p[]存储每个点的祖宗节点</span><br><span class="hljs-comment">// size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span><br><span class="hljs-comment">// 可以按照高度来合并</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(p[x]);<br>  <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>  p[i] = i;<br>  size[i] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br>size[b] += size[a];<br></code></pre></td></tr></table></figure><h3 id="维护到祖宗节点距离的并查集"><a href="#维护到祖宗节点距离的并查集" class="headerlink" title="维护到祖宗节点距离的并查集"></a>维护到祖宗节点距离的并查集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> p[N], d[N];<br><span class="hljs-comment">// p[]存储每个点的祖宗节点</span><br><span class="hljs-comment">// d[x]存储x到p[x]的距离</span><br><br><span class="hljs-comment">// 返回x的祖宗节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (p[x] != x)<br>  &#123;<br>    <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-comment">// 先到达最底层，然后回溯时更新</span><br>    d[x] += d[p[x]];<br>    p[x] = u;<br>  &#125;<br>  <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// 初始化，假定节点编号是1~n</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>   p[i] = i;<br>   d[i] = <span class="hljs-number">0</span>;<br>&#125; <br><br><span class="hljs-comment">// 合并a和b所在的两个集合：</span><br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b);<br>d[<span class="hljs-built_in">find</span>(a)] = distance; <span class="hljs-comment">// 根据具体问题，初始化find(a)的偏移量</span><br></code></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>用一维数组来存，因为是完全二叉树，所以对于$x$，左儿子$2x$，右儿子$2x+1$，基本方法有两个：</p><ol><li><p>$down[x]$向下调整；已经维护好的堆，要把头结点的值换掉</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"> <span class="hljs-attribute">1</span><br><span class="hljs-attribute">3</span><span class="hljs-number">4</span>头结点从<span class="hljs-number">1</span>换成<span class="hljs-number">6</span><br><span class="hljs-attribute">3</span><span class="hljs-number">5</span> <span class="hljs-number">4</span>  <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"> <span class="hljs-attribute">6</span><br><span class="hljs-attribute">3</span><span class="hljs-number">4</span>在<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>找到最小值，把<span class="hljs-number">6</span>换下去<br><span class="hljs-attribute">3</span><span class="hljs-number">5</span> <span class="hljs-number">4</span>  <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"> <span class="hljs-attribute">3</span><br><span class="hljs-attribute">6</span><span class="hljs-number">4</span>在<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>找到最小值，把<span class="hljs-number">6</span>换下去<br><span class="hljs-attribute">3</span><span class="hljs-number">5</span> <span class="hljs-number">4</span>  <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"> <span class="hljs-attribute">3</span><br><span class="hljs-attribute">3</span><span class="hljs-number">4</span>在<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>找到最小值，把<span class="hljs-number">6</span>换下去<br><span class="hljs-attribute">6</span><span class="hljs-number">5</span> <span class="hljs-number">4</span>  <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></li><li><p>$up[x]$向上调整；已经维护好的堆，要把后面结点的值换掉</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"> <span class="hljs-attribute">3</span><br><span class="hljs-attribute">3</span><span class="hljs-number">4</span>尾结点从<span class="hljs-number">5</span>换成<span class="hljs-number">2</span><br><span class="hljs-attribute">3</span><span class="hljs-number">5</span> <span class="hljs-number">4</span>  <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"> <span class="hljs-attribute">3</span><br><span class="hljs-attribute">3</span><span class="hljs-number">4</span>和父节点对比，如果小，则换上去<br><span class="hljs-attribute">3</span><span class="hljs-number">5</span> <span class="hljs-number">4</span>  <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"> <span class="hljs-attribute">3</span><br><span class="hljs-attribute">3</span><span class="hljs-number">2</span>和父节点对比，如果小，则换上去<br><span class="hljs-attribute">3</span><span class="hljs-number">5</span> <span class="hljs-number">4</span>  <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"> <span class="hljs-attribute">2</span><br><span class="hljs-attribute">3</span><span class="hljs-number">3</span>和父节点对比，如果小，则换上去<br><span class="hljs-attribute">3</span><span class="hljs-number">5</span> <span class="hljs-number">4</span>  <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure></li><li><p>插入一个数</p></li><li><p>求集合中最小值</p></li><li><p>删除最小值</p></li><li><p>删除任意一个元素</p></li><li><p>修改任意一个元素</p></li><li><p>STL可实现$1,2,3$</p></li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">小根堆：<br><span class="hljs-number">1.</span>插入一个数 heap[++ size] = x;<span class="hljs-built_in">up</span>(size);<br><span class="hljs-number">2.</span>求集合当中的最小值 heap[<span class="hljs-number">1</span>];<br><span class="hljs-number">3.</span>删除最小值 heap[<span class="hljs-number">1</span>] = heap[size);size--;<span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br><span class="hljs-number">4.</span>删除任意一个元素 heap[k] = heap[size];size--;<span class="hljs-built_in">down</span>(k);<span class="hljs-built_in">up</span>(k)；<br><span class="hljs-number">5.</span>修改任意一个元素 heap[k] = x;<span class="hljs-built_in">down</span>(k);<span class="hljs-built_in">up</span>(k);<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span><br><span class="hljs-comment">// ph[k]存储第k个插入的点在堆中的位置</span><br><span class="hljs-comment">// hp[k]存储堆中下标是k的点是第几个插入的</span><br><span class="hljs-type">int</span> h[N], ph[N], hp[N], size;<br><br><span class="hljs-comment">// 交换两个点，及其映射关系</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">swap</span>(ph[hp[a]],ph[hp[b]]);<br>  <span class="hljs-built_in">swap</span>(hp[a], hp[b]);<br>  <span class="hljs-built_in">swap</span>(h[a], h[b]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> t = u;<br>  <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (u != t)<br>  &#123;<br>    <span class="hljs-built_in">heap_swap</span>(u, t);<br>    <span class="hljs-built_in">down</span>(t);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>])<br>  &#123;<br>    <span class="hljs-built_in">heap_swap</span>(u, u / <span class="hljs-number">2</span>);<br>    u &gt;&gt;= <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// O(n)建堆,从n/2开始是从最后一个叶子结点的父节点开始</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span>; i; i -- ) <span class="hljs-built_in">down</span>(i);<br></code></pre></td></tr></table></figure><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="一般哈希"><a href="#一般哈希" class="headerlink" title="一般哈希"></a>一般哈希</h3><ol><li>离散化可以看作一种比较特殊的哈希方式：是保序的(需要递增的)</li><li>一般是添加和查找两个操作</li></ol><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><p><img src="/Assets/image-20230918122923277.png" alt="拉链法示例"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><br><span class="hljs-comment">// 向哈希表中插入一个数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// N就是取模，模的数尽量选质数(冲突较少)</span><br>    <span class="hljs-type">int</span> k = (x % N + N) % N; <span class="hljs-comment">// +N代表变成正数</span><br>    e[idx] = x;<br>    ne[idx] = h[k];<br>    h[k] = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 在哈希表中查询某个数是否存在</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = (x % N + N) % N;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h[k]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>        <span class="hljs-keyword">if</span> (e[i] == x)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p><img src="/Assets/image-20230918123452498.png" alt="开放寻址法"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> h[N];<br><span class="hljs-comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = (x % N + N) % N;<br>    <span class="hljs-keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)<br>    &#123;<br>        t ++ ;<br>        <span class="hljs-keyword">if</span> (t == N) t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><ol><li><p>$h[]$数组代表什么：前缀哈希</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">str=&quot;A B C A B C D E Y X C A&quot; <br>h[0] = 0 <br>h[1] = &quot;A&quot;的哈希 <br>h[2] = &quot;AB&quot;的哈希 <br>h[3] = &quot;ABC&quot;的哈希 <br>h[4] = &quot;ABCA&quot;的哈希<br></code></pre></td></tr></table></figure></li><li><p>字符串的哈希值怎么求：将字符串看成$P$进制数，P的经验值是$131$或$13331$，取这两个值的冲突概率低</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">字符串&quot; A       B      C     A&quot;<br>p进制 ( 1       2      3     1)p<br>十进制 (1*p^3 + 2*p^2 + 3^p +  1) mod Q<br></code></pre></td></tr></table></figure></li><li><p>可以用前缀哈希求所有子串的哈希值</p><ol><li>已知$1 \sim L-1$和$1 \sim R$的哈希值，要求$L \sim R$的哈希值</li><li>$h[R]&#x3D;(s[0]*p^{R-1}+s[1]*p^{R-2}+…+s[R-1]*p^0)modQ$</li><li>$h[L-1]&#x3D;(s[0]*p^{L-2}+s[1]*p^{L-3}+…+s[L-2]*p^0)modQ$</li><li>平移$h[L-1]$，让他和$h[R]$的次方对齐，先$*p^{R-L+1}$</li><li>则$L-R$的哈希值&#x3D;$h[R]-h[L-1]*p^{R-L+1}$</li><li><img src="/Assets/image-20230918134944213.png" alt="示例图片"></li></ol></li><li><p>小技巧：$Q$取模的数用$2^{64}$，这样直接用unsigned long long存储，溢出的结果就是取模的结果</p></li><li><p>不能映射成0，假定不存在冲突</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br>ULL h[N], p[N]; <span class="hljs-comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span><br><br><span class="hljs-comment">// 初始化</span><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>&#123;<br>    h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];<br>    p[i] = p[i - <span class="hljs-number">1</span>] * P;<br>&#125;<br><br><span class="hljs-comment">// 计算子串 str[l ~ r] 的哈希值</span><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l - <span class="hljs-number">1</span>] * p[r - l + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><a href="/2023/09/17/STL/" title="STL">STL数据类型及相关操作</a><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>变长数组，倍增的思想，支持比较运算，按字典序</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span>  返回元素个数<br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span>  返回是否为空<br><span class="hljs-function"><span class="hljs-title">clear</span><span class="hljs-params">()</span></span>  清空<br><span class="hljs-function"><span class="hljs-title">front</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">back</span>()<br><span class="hljs-function"><span class="hljs-title">push_back</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">pop_back</span>()<br><span class="hljs-function"><span class="hljs-title">begin</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">end</span>()<br><span class="hljs-selector-attr">[]</span><br></code></pre></td></tr></table></figure><h3 id="pair"><a href="#pair" class="headerlink" title="pair&lt;int, int&gt;"></a>pair&lt;int, int&gt;</h3><p>支持比较运算，以first为第一关键字，以second为第二关键字（字典序）    </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">first</span>, 第一个元素<br><span class="hljs-keyword">second</span>, 第二个元素<br></code></pre></td></tr></table></figure><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">length</span>()  返回字符串长度<br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">clear</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">substr</span><span class="hljs-params">(起始下标，(子串长度)</span></span>)  返回子串<br><span class="hljs-function"><span class="hljs-title">c_str</span><span class="hljs-params">()</span></span>  返回字符串所在字符数组的起始地址<br></code></pre></td></tr></table></figure><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">push</span><span class="hljs-params">()</span></span>  向队尾插入一个元素<br><span class="hljs-function"><span class="hljs-title">front</span><span class="hljs-params">()</span></span>  返回队头元素<br><span class="hljs-function"><span class="hljs-title">back</span><span class="hljs-params">()</span></span>  返回队尾元素<br><span class="hljs-function"><span class="hljs-title">pop</span><span class="hljs-params">()</span></span>  弹出队头元素<br></code></pre></td></tr></table></figure><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p>默认是大根堆；定义成小根堆的方式：<code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">push</span><span class="hljs-params">()</span></span>  插入一个元素<br><span class="hljs-function"><span class="hljs-title">top</span><span class="hljs-params">()</span></span>  返回堆顶元素<br><span class="hljs-function"><span class="hljs-title">pop</span><span class="hljs-params">()</span></span>  弹出堆顶元素<br></code></pre></td></tr></table></figure><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">push</span><span class="hljs-params">()</span></span>  向栈顶插入一个元素<br><span class="hljs-function"><span class="hljs-title">top</span><span class="hljs-params">()</span></span>  返回栈顶元素<br><span class="hljs-function"><span class="hljs-title">pop</span><span class="hljs-params">()</span></span>  弹出栈顶元素<br></code></pre></td></tr></table></figure><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">clear</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">front</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">back</span>()<br><span class="hljs-function"><span class="hljs-title">push_back</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">pop_back</span>()<br><span class="hljs-function"><span class="hljs-title">push_front</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">pop_front</span>()<br><span class="hljs-function"><span class="hljs-title">begin</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">end</span>()<br><span class="hljs-selector-attr">[]</span><br></code></pre></td></tr></table></figure><h3 id="set-map"><a href="#set-map" class="headerlink" title="set, map"></a>set, map</h3><h4 id="multiset-multimap"><a href="#multiset-multimap" class="headerlink" title="multiset, multimap"></a>multiset, multimap</h4><p>基于平衡二叉树（红黑树），动态维护有序序列</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">size</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">clear</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">begin</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">end</span>()<br>++, -- 返回前驱和后继，时间复杂度 <span class="hljs-built_in">O</span>(logn)<br></code></pre></td></tr></table></figure><pre><code class="hljs">set/multiset    insert()  插入一个数    find()  查找一个数    count()  返回某一个数的个数    erase()        (1) 输入是一个数x，删除所有x   O(k + logn)        (2) 输入一个迭代器，删除这个迭代器    lower_bound()/upper_bound()        lower_bound(x)  返回大于等于x的最小的数的迭代器        upper_bound(x)  返回大于x的最小的数的迭代器map/multimap    insert()  插入的数是一个pair    erase()  输入的参数是pair或者迭代器    find()    []  注意multimap不支持此操作。 时间复杂度是 O(logn)    lower_bound()/upper_bound()</code></pre><h4 id="unordered"><a href="#unordered" class="headerlink" title="unordered"></a>unordered</h4><p>unordered_set, unordered_map, unordered_multiset, unordered_multimap</p><p>哈希表</p><ol><li>和上面类似，增删改查的时间复杂度是 O(1)</li><li>凡是和排序有关的都不支持： lower_bound()&#x2F;upper_bound()， 迭代器的++，–</li></ol><h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><p>圧位</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">bitset<span class="hljs-variable">&lt;10000&gt;</span> s; <span class="hljs-variable">&lt;&gt;</span>存储的是位数<br>~, &amp;, |<span class="hljs-string">, ^</span><br><span class="hljs-string">&gt;&gt;, &lt;&lt;</span><br><span class="hljs-string">==, !=</span><br><span class="hljs-string">[]</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">count()  返回有多少个1any()  判断是否至少有一个1none()  判断是否全为0set()  把所有位置成1set(k, v)  将第k位变成vreset()  把所有位变成0flip()  等价于~flip(k) 把第k位取反</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>KMP字符串</tag>
      
      <tag>Trie树</tag>
      
      <tag>并查集</tag>
      
      <tag>哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础算法</title>
    <link href="/2023/09/17/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    <url>/2023/09/17/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>二分；高精度；前缀和与差分；双指针算法；位运算；离散化</p><span id="more"></span><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><p><img src="/Assets/image-20230917144116744.png" alt="示例图片"></p><p>有两个模版：求红绿的边界点，一定能求出边界点，之后根据边界点的数得到题目有无解；</p><p>比如查找一个数，<code>check</code>如果是右边模版则为<code>q[mid]&gt;=target</code>；如果是左边模版则为<code>q[mid]&lt;=target</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 补上加1：如果l=r-1，则mid=l+r向下取整=l，则l=l，会死循环</span><br><span class="hljs-comment">// check =&gt; l=mid/r=mid =&gt; 是否要补上+1</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">while</span>(l &lt; r)<br>  &#123;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// check 是否满足绿颜色的性质</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) r = mid;<br>    <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">while</span>(l &lt; r)<br>  &#123;<br>    <span class="hljs-comment">// 区别，如果更新的是l=mid,则mid需要加上1</span><br>    <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt;<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// check 是否满足红颜色的性质</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) l = mid;<br>    <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h3><ol><li>直接判断$r-l$的范围，例如$r-l&gt;&#x3D;1e-6$</li><li>没有$+1,-1$，直接$l&#x3D;mid,r&#x3D;mid$</li><li>或者不用判断$r-l$，直接循环$100$次</li></ol><h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><ol><li><p>当输入的数很大时，可采用字符串方式接收</p></li><li><p>拆成一位一位的数字，把它们存在一个数组中，一个数组元素表示一位数字</p></li><li><p>数组从左到右依次为从低位到高位，因为加法可能会产生进位，而数组在最前面加上数字是不可能的，但在尾巴处加上数字是好做的</p><p><img src="/Assets/image-20231012161357711.png" alt="示例"></p></li><li><p>有+−×÷模版</p></li></ol><h2 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><ol><li>一维公式：<ol><li>$s_i&#x3D;a_1+a_2+…+a_i \quad s_0&#x3D;0$</li><li>$a_i+…+a_j&#x3D;s_j-s_i$</li></ol></li><li>二维公式：<ol><li>$s[i][j]&#x3D;s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]$</li><li>$a[x1][y1]+…+a[x2][y2]&#x3D;s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]$</li><li><img src="/Assets/image-20230917163552064.png" alt="画图示例"></li></ol></li></ol><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><ol><li><p>一维公式：</p><ol><li>$b_i&#x3D;a_i-a_{i-1}$</li><li>$a_i&#x3D;b_1+b_2+…b_i$</li><li>当需要在$a_i…a_j$之间所有数都加上$c$，则只需要$b_i+c,b_{j+1}-c$即可</li></ol></li><li><p>二维公式：</p><ol><li>$b[i][j]&#x3D;a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]$</li><li>当需要在$a[x1][y1]…a[x2][y2]$之间所有数都加上$c$，则只需要$b[x1][y1]+c;b[x1][y2+1]-c;b[x2+1][y1]-c;b[x2+1][y2+1]+c$即可</li><li><img src="/Assets/image-20230917164916453.png" alt="画图示例"></li></ol></li></ol><h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><ol><li><p>指向的是两个序列，维护某种次序，比如归并排序合并</p></li><li><p>指向的是一个序列，两个指针维护一段区间</p></li><li><p>一般是将朴素算法优化到$O(N)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 朴素算法</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>    <span class="hljs-comment">// 具体逻辑</span><br><br><span class="hljs-comment">// 双指针</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;i&lt;n;i++)<br>  <span class="hljs-keyword">while</span>(j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i,j)) j++ <span class="hljs-comment">//单调性</span><br>  <span class="hljs-comment">// 具体逻辑</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ol><li>求出$x$的二进制表示第$k$位的值：$(x&gt;&gt;k)&amp;1$</li><li>返回$x$的二进制表示最后一位$1$：$x&amp;-x&#x3D;x&amp;(\sim x + 1)$<ol><li>证明：<ol><li>$x&#x3D;1010…10000$</li><li>$\sim x&#x3D;0101…01111$</li><li>$\sim x +1&#x3D;0101…10000$</li><li>$x&amp;(\sim x + 1)&#x3D;0000….10000$</li></ol></li><li>应用：得到$x$有多少个$1$，每次把$x$的最后一位去掉(也就是$-(x&amp;-x)$)，计算次数即可</li></ol></li><li>消除$x$的二进制表示最后一位$1$：$x&amp;x-1$</li></ol><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><ol><li><p>值域很大，但是真正用到的很稀疏</p></li><li><p>$a[]$中可能有重复元素-去重</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 去掉重复元素</span><br></code></pre></td></tr></table></figure></li><li><p>如何求出$x$离散化的值-二分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
      <tag>二分</tag>
      
      <tag>高精度</tag>
      
      <tag>前缀和与差分</tag>
      
      <tag>双指针算法</tag>
      
      <tag>离散化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2023/09/16/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2023/09/16/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>插入排序；交换排序；选择排序；归并排序；分配排序；</p><span id="more"></span><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>直接插入；折半插入；链表插入</p><ol><li>插入第i个时，前面i-1个已经排好序</li><li>$v[i]$与$v[i-1],v[i-2].$..比较，找到插入位置</li><li>原来位置元素向后移</li></ol><p>希尔排序</p><ol><li>将全部元素分为gap个子序列</li><li>缩小间隔gap</li><li>直到gap为1</li></ol><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ol><li><p>以某个元素为基准；确定分界点（$q[l],q[(l+r)&#x2F;2],q[r]$）随机</p></li><li><p>按照该元素的排序码大小，将整个元素序列分为两部分</p><ol><li><p>第一种</p><ol><li>分为两个区间$a[],b[]$</li><li>对于$q[l-r]$，若$q[i]&lt;&#x3D;x,x-&gt;a[]$，否则$x-&gt;b[]$</li><li>$a[],b[]$放入$q[]$中</li></ol></li><li><p>第二种</p><ol><li>$i,j$指针分别从左边和右边，$i$指向的数$&lt;&#x3D;x$，$j$指向的数$&gt;&#x3D;x$</li><li>直到$q[i]&gt;x,q[j]&lt;x$，$i,j$指针指向数交换</li><li>直到$i,j$相遇，那么$i$左边的数都是$&lt;&#x3D;x$，$j$右边的数都是$&gt;&#x3D;x$的，分为两段</li></ol></li></ol></li><li><p>对这两部分重复实施上述方法，递归</p></li><li><p>背快排模版-注意边界问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-type">int</span> x = q[l], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(i &lt; j)<br>  &#123;<br>    <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>    <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>    <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>  &#125;<br>  <span class="hljs-comment">// 边界问题</span><br>  <span class="hljs-comment">// 如果改成(q, l, i - 1), (q, i, r)则上面改为x = q[r]</span><br>  <span class="hljs-built_in">quick_sort</span>(q, l, j); <br>  <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ol><li>对象个数为$n$，最多做$n-1$趟排序</li><li>发生逆序，则交换$v[n]$和$v[n-1]$</li></ol><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><ol><li>在一组元素中选择最小的</li><li>将最小元素放到这组的第一个位置</li><li>在剩下元素中重复过程</li><li>直到只剩下1个元素</li></ol><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ol><li>将无序数组构造成一个大根堆（新插入的数据与其父结点比较）</li><li>固定一个最大值，将剩余的数重新构造成一个大根堆，重复这样的过程</li></ol><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ol><li>确定分界点，$mid&#x3D;(l+r)&#x2F;2$，是下标的中间值</li><li>先分成两个数组，递归排序两个数组</li><li>将两个数组合二为一<ol><li>两个数组分别有指针$i,j$指向</li><li>将$i,j$指向的进行对比，选择小的存在$temp$中，剩余的直接接在后面</li><li>将$temp$数组赋值到原数组中</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间问题</title>
    <link href="/2023/09/15/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"/>
    <url>/2023/09/15/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>区间选点；最大不相交区间数量；区间分组；区间覆盖</p><span id="more"></span><p>主要难点在于证明 + 多做题找思路</p><blockquote><p>AcWing 905. 区间选点 &amp; AcWing 908. 最大不相交区间数量</p></blockquote><ol><li>选择尽可能少的点能够覆盖所有的区间；选择尽量多的区间没有交集</li><li>做法<ol><li>将每个区间按照右端点从小到大排序</li><li>从前往后枚举每个区间<ol><li>如果当前区间已经包含点，则直接过</li><li>否则，选择当前区间的右端点</li></ol></li></ol></li></ol><p>![[&#x2F;Assets&#x2F;2d5f96f263796b3e8aa363ac513d839e_MD5.jpeg]]</p><blockquote><p>AcWing 906. 区间分组</p></blockquote><ol><li>将区间分为尽量少的组，让组内部区间没有交集</li><li>做法<ol><li>将每个区间按照左端点从小到大排序</li><li>从前往后枚举每个区间<ol><li>如果能放到某个组中$l_i&gt;max(r_j)$，则放入并更新$max(r_j)$</li><li>否则开新组，将其放入</li></ol></li></ol></li></ol><p>![[&#x2F;Assets&#x2F;694b2c7b5ac6460d6364939d8a6dba91_MD5.jpeg]]</p><blockquote><p>AcWing 907. 区间覆盖</p></blockquote><ol><li>给定多个区间，指定一个线段，选择尽可能少的区间覆盖线段</li><li>做法<ol><li>将每个区间按照左端点从小到大排序</li><li>从前往后枚举每个区间<ol><li>选择能覆盖起点的右端点最大的区间</li><li>将起点更新成右端点最大值</li></ol></li></ol></li></ol><p>[[&#x2F;Assets&#x2F;5dcac4d633c18dd2f8a7c0e4212ef4f2_MD5.jpeg|Open: image-20240401150643110.png]]<br>![[&#x2F;Assets&#x2F;5dcac4d633c18dd2f8a7c0e4212ef4f2_MD5.jpeg]]</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区间问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Notion学习</title>
    <link href="/2023/09/15/Notion%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/15/Notion%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>下面主要是记录一下用Notion</p><span id="more"></span><h3 id="Formula中常用公式"><a href="#Formula中常用公式" class="headerlink" title="Formula中常用公式"></a>Formula中常用公式</h3><ol><li><p>属性（Properties）</p><ol><li><code>prop(&quot;属性&quot;)</code>得到属性值</li><li>包括：数字、文本、日期、布尔值<ol><li>数字：可用<code>add</code>,<code>around</code>,<code>ceil</code>等函数</li><li>文本：用<code>+</code>号即可</li><li>日期：用<code>end</code>可得到截止日期</li><li>布尔：用打勾来代表<code>bool</code>值</li></ol></li></ol></li><li><p>常量（Constants）</p></li><li><p>运算符（Operators）</p></li><li><p>函数（Functions）</p><ol><li><code>if</code>函数：<code>if(boolean,value,value)</code></li></ol></li></ol><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>⇧⌫ 放大字体<br>⇧⌘L 黑暗模式</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Notion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>其他DP</title>
    <link href="/2023/09/14/%E5%85%B6%E4%BB%96DP/"/>
    <url>/2023/09/14/%E5%85%B6%E4%BB%96DP/</url>
    
    <content type="html"><![CDATA[<p>区间DP；计数类DP；数位统计DP；状态压缩DP；树形DP；记忆化搜索</p><span id="more"></span><h3 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h3><blockquote><p>AcWing 282. 石子合并</p></blockquote><ol><li><p>$f(i,j)$表示从第$i$堆石子到第$j$堆石子合并成一堆的所有方式中，合并代价最小的$MIN$</p></li><li><p>代价就是$f[i][k]+f[k+1][j]+s[j]-s[i-1]\quad k&#x3D;i \sim j-1$，后面用前缀和</p></li></ol><p>![[&#x2F;Assets&#x2F;image-20240401145504006.png|450]]</p><h3 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h3><p>强调分情况讨论！</p><blockquote><p>AcWing 338. 计数问题</p></blockquote><ol><li><p>题目：对于$1 \sim n \quad n&#x3D;abcdefg$，需要求出$1 \sim 9$在出现在全部数字的每一位的次数总和</p><blockquote><p>eg：n&#x3D;11，则全部数字为1,2,3…11，则1在1中出现1次，在10中出现1次，在11中出现2次；2在2中出现一次…</p><p>最终得到1出现总次数为4，2出现总次数为1…</p></blockquote></li><li><p>例如$n&#x3D;abcdefg$，可以先求1在第4位上面出现次数，下面是分情况讨论：$1&lt;&#x3D;xxx1yyy&lt;&#x3D;abcdefg$，其中就是求$xxx1yyy$有多少个</p><ol><li>$xxx&#x3D;000 \sim abc-1$，则$yyy&#x3D;000 \sim 999$，有$abc*1000$种</li><li>$xxx&#x3D;abc$<ol><li>$d&lt;1$，则$abc1yyy&gt;abc0efg$，有0种</li><li>$d&#x3D;1$，则$yy000 \sim efg$，有$efg+1$种</li><li>$d&gt;1$，则$yyy&#x3D;000 \sim 999$，有$1000$种</li></ol></li></ol><p>然后求出1在所有位上出现的次数相加-&gt;$1 \sim 9$都可以这么求</p></li></ol><h3 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h3><blockquote><p>AcWing 291. 蒙德里安的梦想</p></blockquote><ol><li><p>$f(i,j)$表示的是第$i$列是第$j$种格子摆放状态时的所有方式的总和$SUM$</p></li><li><p>例子如下：</p><ol><li>首先因为横着放的格子放满之后，竖着放的格子就自然放了，所以只考虑横着的</li><li>下图为$f[i,j],j&#x3D;00001,k&#x3D;10010$时的情况；$j,k$分别指格子在$i,i-1$列的占用状态(格子的第二个)，用二进制表示</li><li>$j$和$k$要满足条件</li></ol><ul><li>两列不能重合：$j&amp;k&#x3D;&#x3D;0$</li><li>竖着放的格子需要两个：$j|k$不存在连续奇数个0</li></ul></li></ol><p>![[&#x2F;Assets&#x2F;700ef16fa06e3e8bb5001e3a2adc4400_MD5.jpeg|350]]</p><blockquote><p>AcWing 91. 最短Hamilton路径</p></blockquote><ol><li>$f(i,j)$表示的所有从$0$走到$i$走过的所有点是$j$的所有方式中，距离最小的$MIN$</li></ol><p>![[&#x2F;Assets&#x2F;8d38e9ee63dc30e629a9b69547dd5819_MD5.jpeg|500]]</p><h3 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h3><blockquote><p>AcWing 285. 没有上司的舞会</p></blockquote><ol><li><p>有两个状态$f(u,0),f(u,1)$，$f(u,0)$表示的是不选择$u$这个点的所有方案获得值的最大值，$f(u,1)$表示的是选择$u$这个点的所有方案获得值的最大值$MAX$</p></li><li><p>$s_i$是$u$的所有儿子</p><p>$f(u,0)&#x3D;\sum max(f(s_i,0),f(s_i,1))$</p><p>$f(u,1)&#x3D;\sum f(s_i,0)$  选择上司就下属就不会再被选了</p></li></ol><h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3><blockquote><p>AcWing 901. 滑雪</p></blockquote><ol><li>$f(i,j)$表示的是从$(i,j)$开始滑所有路径的最大值$MAX$</li><li>代码复杂度会降低</li></ol><p>![[&#x2F;Assets&#x2F;image-20240401145758353.png|400]]</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>区间DP</tag>
      
      <tag>计数类DP</tag>
      
      <tag>数位统计DP</tag>
      
      <tag>状态压缩DP</tag>
      
      <tag>树形DP</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性DP</title>
    <link href="/2023/09/12/%E7%BA%BF%E6%80%A7DP/"/>
    <url>/2023/09/12/%E7%BA%BF%E6%80%A7DP/</url>
    
    <content type="html"><![CDATA[<p>数字三角形；最长上升子序列；最长公共子序列；编辑距离</p><span id="more"></span><p><img src="/Assets/image-20230912171857992.png" alt="线性DP状态计算"></p><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><ol><li>$f(i,j)$表示从起点走到$(i,j)$终点的所有路径中，路径长度的最大值$MAX$</li><li>递推公式：$dp[i][j]&#x3D;max(dp[i-1][j-1]+a[i][j],dp[i-1][j]+a[i][j])$</li></ol><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><ol><li>$f(i)$表示所有以$i$结尾的上升子序列中，序列长度的最大值$MAX$</li><li>递推公式：$dp[i]&#x3D;max(dp[j]+1) \quad j&#x3D;0,1,2…i-1$</li><li>前提就是$dp[i]&gt;dp[j]$</li><li>优化做法(贪心)：<ol><li><code>q</code>数组下标为序列长度，值为所有该序列长度中具有的末尾最小值，该数组是严格单调递增的</li><li>遍历到一个新的值<code>a[i]</code>，则找<code>q</code>数组中小于它的最大值<code>q[j]</code>，找到则可以替换<code>q[j+1]</code>-可以用二分</li><li>证明q数组是严格单调递增的：如果长度为6的结尾最小值&#x3D;长度为5的结尾最小值，则矛盾（因为是最长上升子序列）</li><li><img src="/Assets/image-20231027113909338.png" alt="示例"></li></ol></li></ol><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><ol><li>$f[i,j]$表示第一个序列的前$i$个字母和第二个序列的前$j$个字母所有公共子序列中，子序列长度的最大值$MAX$</li><li>求最大值，最小值分类是可以有重复的；但是求数量不可以</li></ol><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><ol><li>$f[i,j]$表示所有将$a[1-i]$变成$b[1-j]$的操作方式中，操作次数的最小值$MIN$</li><li>递推公式：$dp[i][j]&#x3D;min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+1&#x2F;0)$</li><li>4种情况(转换为代码，主要还是看来的方向)<ol><li>删除：如果删除$a[i]$后匹配($a[i]!&#x3D;b[j])$；$a[1 \sim i-1]$和$b[1 \sim j]$匹配；</li><li>插入：如果插入$a[i]$后匹配($a[i]&#x3D;b[j])$；$a[1 \sim i]$和$b[1 \sim j-1]$匹配；</li><li>替换：如果$a[i]$替换成$b[j]$后匹配($a[i]!&#x3D;b[j])$，$a[1 \sim i-1]$和$b[1 \sim j-1]$匹配；</li><li>相等：如果不做任何操作后匹配($a[i]&#x3D;b[j]$)，则$a[1 \sim i-1]$和$b[1 \sim j-1]$匹配；</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线性DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/2023/09/12/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2023/09/12/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>01背包；完全背包；多重背包；分组背包；混合背包</p><span id="more"></span><ol><li>DP优化一般是对代码或者方程做一个等价变形</li><li>复杂度是状态数量×转移时间</li></ol><p><img src="/Assets/image-20230912104603831.png" alt="DP问题"></p><p><img src="/Assets/image-20230912160007398.png" alt="背包问题状态计算"></p><p>背包问题中$f(i,j)$表示物品数量为$i$，容量为$j$时候所有物品组合中，价值的最大值$MAX$</p><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><ol><li>递推公式：$dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - w ]+ v);$</li><li>优化：二维变一维(滚动数组)<ol><li>第$i$层的数据可以直接用$i-1$层的数据</li><li>公式：$dp[j] &#x3D; max(dp[j], dp[j - w] + v);$</li><li>如果$j$从小到大循环，则原来$dp[j]$中$j$小的值会被覆盖掉，则会导致物品$i$在循环过程中被放置很多次</li></ol></li><li><img src="/Assets/8562-20211007092633901-1608550701.png" alt="图片示例"></li></ol><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><ol><li><p>递推公式：$dp[i][j]&#x3D;max(dp[i-1][j-w<em>k]+v</em>k) \quad k$动态变</p></li><li><p>和01背包问题区别就是，01背包$f[i][j]$是分为两个，完全背包$f[i][j]$分为$k$个</p></li><li><p>优化：通过表达式改进</p><ol><li><p>$dp[i][j]&#x3D;max(dp[i-1,j],dp[i-1][j-w]+v,dp[i-1][j-2w]+2v,…)$</p><p>$dp[i][j-w]&#x3D;max(dp[i-1,j-w],dp[i-1][j-2w]+v,dp[i-1][j-3w]+2v,…)$</p></li><li><p>可以发现$dp[i,j-w]$和上面的式子后半部分就少了$v$，表达式变为：$dp[i,j]&#x3D;max(dp[i-1,j],dp[i,j-w]+v)$</p></li><li><p>然后可以改为一维：$dp[i,j]&#x3D;max(dp[j],dp[j-w]+v)$</p></li><li><p>改为一维之后的方程是从小到大的，就是用的前面的结果，因为物品可以被添加多次-最终和01背包问题差的就是对于$j$循环的顺序了</p></li></ol></li></ol><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><ol><li>和完全背包很像：$dp[i][j]&#x3D;max(dp[i-1][j-w<em>k]+v</em>k) \quad k&#x3D;1,2,..,s[i]$</li><li>转换为01背包问题：相当于第$i$个物品可以最多拿$s[i]$个<ol><li>用二进制表示法：将$s[i]$分解为$1,2,4,8…2^k,s[i]-$前面的，那么$0-s[i]$当中的任何一个数都可以用这些分解出来的数组合表示</li><li>如果用二进制表示：则从$s[i]$个变成了$logs[i]$个，然后就可以按照01背包问题的优化来解决了</li></ol></li></ol><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><ol><li>递推公式：$dp[i][j]&#x3D;max(dp[i][j],dp[i−1][j−w[i][k]]+v[i][k])$</li><li>和01背包问题区别就是$w[i]$也需要进行$k$次循环了</li><li>优化(滚动数组)：$dp[j]&#x3D;max(dp[j],dp[j−w[i][k]]+v[i][k]$</li></ol><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p><img src="/Assets/image-20230912144746326.png" alt="背包问题分类"></p><h4 id="几种问题问法和递推公式"><a href="#几种问题问法和递推公式" class="headerlink" title="几种问题问法和递推公式"></a>几种问题问法和递推公式</h4><ol><li>能否能装满背包：<code>dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</code></li><li>装满背包有几种方法：<code>dp[j] += dp[j - nums[i]]</code></li><li>背包装满最大价值：<code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i])</code></li><li>装满背包所有物品的最小个数：<code>dp[j] = min(dp[j - coins[i]] + 1, dp[j])</code></li></ol><h4 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="遍历顺序"></a>遍历顺序</h4><ol><li>完全背包问题<ol><li>如果求组合数就是外层for循环遍历物品，内层for遍历背包</li><li>如果求排列数就是外层for遍历背包，内层for循环遍历物品</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习</title>
    <link href="/2023/09/11/git%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/11/git%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>下面主要是记录一下Git间接性学习过程</p><span id="more"></span><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h2><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里</p><p><img src="/Assets/640.jpeg" alt="图片"></p><h2 id="2-基本Linux命令"><a href="#2-基本Linux命令" class="headerlink" title="2. 基本Linux命令"></a>2. 基本Linux命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">clear 清屏。<span class="hljs-built_in">cd</span>          改变目录。<br><span class="hljs-built_in">cd</span> . . 回退到上一个目录，直接<span class="hljs-built_in">cd</span>进入默认目录<br><span class="hljs-built_in">pwd</span>   显示当前所在的目录路径。<br><span class="hljs-built_in">ls</span>(ll)  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细<br><span class="hljs-built_in">touch</span>       新建一个文件 如 <span class="hljs-built_in">touch</span> index.js 就会在当前目录下新建一个index.js文件<br><span class="hljs-built_in">rm</span>删除一个文件, <span class="hljs-built_in">rm</span> index.js 就会把index.js文件删除<br><span class="hljs-built_in">mkdir</span>新建一个目录,就是新建一个文件夹<br><span class="hljs-built_in">rm</span> -r 删除一个文件夹, <span class="hljs-built_in">rm</span> -r src 删除src目录<br><span class="hljs-built_in">rm</span> -rf / 删除电脑中全部文件<br><span class="hljs-built_in">mv</span> 移动文件<br>reset 重新初始化终端/清屏。<br>clear 清屏<br><span class="hljs-built_in">history</span> 查看命令历史<br><span class="hljs-built_in">help</span> 帮助<br><span class="hljs-built_in">exit</span> 退出<br><span class="hljs-comment">#表示注释</span><br></code></pre></td></tr></table></figure><h2 id="3-基本理论"><a href="#3-基本理论" class="headerlink" title="3. 基本理论"></a>3. 基本理论</h2><ol><li><strong>工作目录(Working Directory):平时存放项目代码的地方</strong></li><li><strong>暂存区(Stage&#x2F;Index):事实上它只是一个文件</strong></li><li><strong>资源库(Repository或Git Directory):有提交到所有版本的数据</strong></li><li><strong>远程的git仓库(Remote Directory):托管代码的服务器</strong></li></ol><p><img src="/Assets/640.png" alt="图片"></p><h2 id="4-文件的四种状态"><a href="#4-文件的四种状态" class="headerlink" title="4. 文件的四种状态"></a>4. 文件的四种状态</h2><ol><li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li><li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li><li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改</li><li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li></ol><h2 id="5-忽略格式"><a href="#5-忽略格式" class="headerlink" title="5. 忽略格式"></a>5. 忽略格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">*.txt        <span class="hljs-comment">#忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br>!lib.txt     <span class="hljs-comment">#但lib.txt除外</span><br>/temp        <span class="hljs-comment">#仅忽略项目根目录下的TODO文件,不包括其它目录temp</span><br>build/       <span class="hljs-comment">#忽略build/目录下的所有文件</span><br>doc/*.txt    <span class="hljs-comment">#会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></code></pre></td></tr></table></figure><h2 id="6-分支"><a href="#6-分支" class="headerlink" title="6. 分支"></a>6. 分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有本地分支</span><br>git branch<br><span class="hljs-comment"># 列出所有远程分支</span><br>git branch -r<br><span class="hljs-comment"># 新建一个分支，但依然停留在当前分支</span><br>git branch [branch-name]<br><span class="hljs-comment"># 新建一个分支，并切换到该分支</span><br>git checkout -b [branch]<br><span class="hljs-comment"># 合并指定分支到当前分支</span><br>$ git merge [branch]<br><span class="hljs-comment"># 删除分支</span><br>$ git branch -d [branch-name]<br><span class="hljs-comment"># 删除远程分支</span><br>$ git push origin --delete [branch-name]<br>$ git branch -dr [remote/branch]<br></code></pre></td></tr></table></figure><h2 id="7-Git-ignore清除缓存"><a href="#7-Git-ignore清除缓存" class="headerlink" title="7. Git ignore清除缓存"></a>7. Git ignore清除缓存</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> `项目目录`<br>git <span class="hljs-built_in">rm</span> -r --cached .<br>git add .<br>git commit -m <span class="hljs-string">&#x27;update .gitignore&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flowable学习</title>
    <link href="/2023/09/01/Flowable%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/01/Flowable%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>下面主要是记录一下Flowable的学习过程</p><span id="more"></span><h2 id="官方手册"><a href="#官方手册" class="headerlink" title="官方手册"></a>官方手册</h2><p><a href="https://tkjohn.github.io/flowable-userguide/">https://tkjohn.github.io/flowable-userguide/</a></p><h2 id="表说明"><a href="#表说明" class="headerlink" title="表说明"></a>表说明</h2><p>大致功能</p><table><thead><tr><th>表名称</th><th>功能</th></tr></thead><tbody><tr><td>ACT_RE_*</td><td>‘RE’表示 repository。RepositoryService接口操作的表。带此前缀的表包含的是静态信息，如，流程定义，流程的资源（图片，规则等）</td></tr><tr><td>ACT_RU_*</td><td>‘RU’表示 runtime。 运行时的表存储着流程变量，用户任务，变量，职责（job）等运行时的数据</td></tr><tr><td>ACT_ID_*</td><td>’ID’表示identity(组织机构)。包含标识的信息，如用户，用户组</td></tr><tr><td>ACT_HI_*</td><td>‘HI’表示 history。这些表包含着历史的相关数据，如结束的流程实例，变量，任务</td></tr><tr><td>ACT_GE_*</td><td>GE 表示 general。普通数据，各种情况都使用的数据</td></tr></tbody></table><p>具体的表结构的含义:</p><table><thead><tr><th><strong>表分类</strong></th><th><strong>表名</strong></th><th><strong>解释</strong></th></tr></thead><tbody><tr><td>一般数据</td><td></td><td></td></tr><tr><td></td><td>[ACT_GE_BYTEARRAY]</td><td>二进制数据表，如流程定义、流程模板、流程图的字节流文件</td></tr><tr><td></td><td>[ACT_GE_PROPERTY]</td><td>属性数据表</td></tr><tr><td>流程历史记录</td><td></td><td></td></tr><tr><td></td><td>[ACT_HI_ACTINST]</td><td>历史节点表，存放流程实例运转的各个节点信息（包含开始、结束等非任务节点）</td></tr><tr><td></td><td>[ACT_HI_ATTACHMENT]</td><td>历史附件表，存放历史节点上传的附件信息</td></tr><tr><td></td><td>[ACT_HI_COMMENT]</td><td>历史意见表</td></tr><tr><td></td><td>[ACT_HI_DETAIL]</td><td>历史详情表，存储节点运转的一些信息</td></tr><tr><td></td><td>[ACT_HI_IDENTITYLINK]</td><td>历史流程人员表，存储流程各节点候选、办理人员信息，常用于查询某人或部门的已办任务</td></tr><tr><td></td><td>[ACT_HI_PROCINST]</td><td>历史流程实例表，存储流程实例历史数据</td></tr><tr><td></td><td>[ACT_HI_TASKINST]</td><td>历史流程任务表，存储历史任务节点</td></tr><tr><td></td><td>[ACT_HI_VARINST]</td><td>流程历史变量表，存储流程历史节点的变量信息</td></tr><tr><td>流程定义表</td><td></td><td></td></tr><tr><td></td><td>[ACT_RE_DEPLOYMENT]</td><td>部属信息表，存储流程定义、模板部署信息</td></tr><tr><td></td><td>[ACT_RE_MODEL]</td><td>流程模板信息表，存储流程模板相关描述信息，但其真正内容存储在act_ge_bytearray表中，以字节形式存储</td></tr><tr><td></td><td>[ACT_RE_PROCDEF]</td><td>流程定义信息表，存储流程定义相关描述信息，但其真正内容存储在act_ge_bytearray表中，以字节形式存储</td></tr><tr><td>运行实例表</td><td></td><td></td></tr><tr><td></td><td>[ACT_RU_EVENT_SUBSCR]</td><td>监听信息表</td></tr><tr><td></td><td>[ACT_RU_EXECUTION]</td><td>运行时流程执行实例表，记录运行中流程运行的各个分支信息（当没有子流程时，其数据与act_ru_task表数据是一一对应的）</td></tr><tr><td></td><td>[ACT_RU_IDENTITYLINK]</td><td>运行时流程人员表，重要，常用于查询人员或部门的待办任务时使用</td></tr><tr><td></td><td>[ACT_RU_JOB]</td><td>运行时定时任务数据表，存储流程的定时任务信息</td></tr><tr><td></td><td>[ACT_RU_TASK]</td><td>运行时流程任务节点表，存储运行中流程的任务节点信息，常用于查询人员或部门的待办任务时使用</td></tr><tr><td></td><td>[ACT_RU_VARIABLE]</td><td>运行时流程变量数据表，存储运行中的流程各节点的变量信息</td></tr><tr><td>用户用户组表</td><td></td><td></td></tr><tr><td></td><td>[ACT_ID_BYTEARRAY]</td><td>二进制数据表</td></tr><tr><td></td><td>[ACT_ID_GROUP]</td><td>用户组信息表，对应节点选定候选组信息</td></tr><tr><td></td><td>[ACT_ID_INFO]</td><td>用户扩展信息表，存储用户扩展信息</td></tr><tr><td></td><td>[ACT_ID_MEMBERSHIP]</td><td>用户与用户组关系表</td></tr><tr><td></td><td>[ACT_ID_PRIV]</td><td>权限表</td></tr><tr><td></td><td>[ACT_ID_PRIV_MAPPING]</td><td>用户或组权限关系表</td></tr><tr><td></td><td>[ACT_ID_PROPERTY]</td><td>属性表</td></tr><tr><td></td><td>[ACT_ID_TOKEN]</td><td>记录用户的token信息</td></tr><tr><td></td><td>[ACT_ID_USER]</td><td>用户信息表，对应节点选定办理人或候选人信息</td></tr></tbody></table><h2 id="服务说明"><a href="#服务说明" class="headerlink" title="服务说明"></a>服务说明</h2><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service是工作流引擎提供用于进行工作流部署、执行、管理的服务接口，我们使用这些接口可以就是操作服务对应的数据表</p><table><thead><tr><th>service名称</th><th>service作用</th></tr></thead><tbody><tr><td>ProcessEngine</td><td>引擎</td></tr><tr><td>RepositoryService</td><td>资源管理</td></tr><tr><td>RuntimeService</td><td>流程运行管理</td></tr><tr><td>TaskService</td><td>任务管理</td></tr><tr><td>HistoryService</td><td>历史服务</td></tr><tr><td>ManagementService</td><td>定时器等，读取数据库和原始表的信息</td></tr><tr><td>IdentityService</td><td>管理用户</td></tr><tr><td>FormService</td><td>表单服务</td></tr><tr><td>DynamicBpmnService</td><td>修改流程定义</td></tr></tbody></table><h3 id="重要名词"><a href="#重要名词" class="headerlink" title="重要名词"></a>重要名词</h3><ol><li>事件：捕获与抛出事件</li><li>顺序流：顺序流是流程中两个元素间的连接器</li><li>网关：用于控制执行的流向</li><li>任务：用户任务，邮件任务等</li><li>子流程与调用活动：之间有区别</li></ol><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><h3 id="1-设计流程"><a href="#1-设计流程" class="headerlink" title="1. 设计流程"></a>1. 设计流程</h3><p>涉及到表结构：</p><table><thead><tr><th>名称</th><th>功能</th></tr></thead><tbody><tr><td>act_de_model</td><td>保存的是流程设计的json格式文件</td></tr><tr><td>act_de_model_history</td><td>保存的是流程设计的历史文件</td></tr></tbody></table><h3 id="2-部署流程定义"><a href="#2-部署流程定义" class="headerlink" title="2. 部署流程定义"></a>2. 部署流程定义</h3><ol><li>流程引擎会用XML文件存储在数据库中；<em>repositoryService</em></li><li>转换为内部的、可执行的对象模型-启动实例</li><li>部署流程之后，可以通过<em>RepositoryService</em>创建的<em>ProcessDefinitionQuery</em>对象实现查询</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 部署流程 获取RepositoryService对象</span><br><span class="hljs-type">RepositoryService</span> <span class="hljs-variable">repositoryService</span> <span class="hljs-operator">=</span> processEngine.getRepositoryService();<br><span class="hljs-type">Deployment</span> <span class="hljs-variable">deployment</span> <span class="hljs-operator">=</span> repositoryService.createDeployment()<span class="hljs-comment">// 创建Deployment对象</span><br>        .addClasspathResource(<span class="hljs-string">&quot;holiday-request.bpmn20.xml&quot;</span>) <span class="hljs-comment">// 添加流程部署文件</span><br>        .name(<span class="hljs-string">&quot;请求流程&quot;</span>) <span class="hljs-comment">// 设置部署流程的名称</span><br>        .deploy(); <span class="hljs-comment">// 执行部署操作</span><br></code></pre></td></tr></table></figure><ol start="4"><li>如果对流程只是部署没有启动，则是可以直接删除；如果流程启动了，则可以选择级联删除（相关任务也会删除）</li><li>相关图标：事件图标；活动图标；结构图标；网关图标</li></ol><p>涉及到表结构：</p><table><thead><tr><th>名称</th><th>功能</th></tr></thead><tbody><tr><td>act_re_deployment</td><td>流程定义部署表，每部署一次就增加一条记录</td></tr><tr><td>act_re_procdef</td><td>流程定义表，部署每个新的流程定义都会在这张表中增加一条记录</td></tr><tr><td>act_ge_bytearray</td><td>流程资源表，流程部署的 bpmn文件和png图片会保存在该表中</td></tr></tbody></table><h3 id="3-启动流程实例"><a href="#3-启动流程实例" class="headerlink" title="3. 启动流程实例"></a>3. 启动流程实例</h3><ol><li>启动流程实例通过 <em>runtimeService</em>服务；参数（流程定义<em>id</em>；参数<em>variables</em>）</li></ol><p>涉及到表结构：</p><table><thead><tr><th>名称</th><th>功能</th></tr></thead><tbody><tr><td>act_hi_actinst</td><td>流程实例执行历史</td></tr><tr><td>act_hi_identitylink</td><td>流程的参与用户的历史信息</td></tr><tr><td>act_hi_procinst</td><td>流程实例历史信息</td></tr><tr><td>act_hi_taskinst</td><td>流程任务历史信息</td></tr><tr><td>act_hi_varinst</td><td>流程变量历史信息</td></tr><tr><td>act_ru_execution</td><td>流程执行信息</td></tr><tr><td>act_ru_identitylink</td><td>流程的参与用户信息</td></tr><tr><td>act_ru_task</td><td>任务信息</td></tr><tr><td>act_ru_variable</td><td>流程的变量信息</td></tr></tbody></table><h3 id="4-查看任务"><a href="#4-查看任务" class="headerlink" title="4.查看任务"></a>4.查看任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TaskService</span> <span class="hljs-variable">taskService</span> <span class="hljs-operator">=</span> processEngine.getTaskService();<br>List&lt;Task&gt; list = taskService.createTaskQuery()<br>        .processDefinitionKey(<span class="hljs-string">&quot;holidayRequestNew&quot;</span>)<br>        .taskAssignee(<span class="hljs-string">&quot;lisi&quot;</span>)<br>        .list();<br></code></pre></td></tr></table></figure><h3 id="5-完成任务"><a href="#5-完成任务" class="headerlink" title="5.完成任务"></a>5.完成任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 添加流程变量</span><br>Map&lt;String,Object&gt; variables = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>variables.put(<span class="hljs-string">&quot;approved&quot;</span>,<span class="hljs-literal">false</span>); <span class="hljs-comment">// 拒绝请假</span><br><span class="hljs-comment">// 完成任务</span><br>taskService.complete(task.getId(),variables);<br></code></pre></td></tr></table></figure><h3 id="6-流程的删除"><a href="#6-流程的删除" class="headerlink" title="6.流程的删除"></a>6.流程的删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 删除流程定义，如果该流程定义已经有了流程实例启动则删除时报错</span><br><span class="hljs-comment">// repositoryService.deleteDeployment(&quot;1&quot;);</span><br><span class="hljs-comment">// 设置为TRUE 级联删除流程定义，及时流程有实例启动，也可以删除，设置为false 非级联删除操作。</span><br>repositoryService.deleteDeployment(<span class="hljs-string">&quot;2501&quot;</span>,<span class="hljs-literal">true</span>);<br><br></code></pre></td></tr></table></figure><h3 id="7-查看历史信息"><a href="#7-查看历史信息" class="headerlink" title="7.查看历史信息"></a>7.查看历史信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;HistoricActivityInstance&gt; list = historyService.createHistoricActivityInstanceQuery()<br>   .processDefinitionId(<span class="hljs-string">&quot;holidayRequestNew:1:10003&quot;</span>)<br>   .finished()<br>   .orderByHistoricActivityInstanceEndTime().asc()<br>   .list();<br></code></pre></td></tr></table></figure><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p><img src="/Assets/9411696916178_.pic_hd.jpg" alt="高清图"></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Flowable</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo学习</title>
    <link href="/2023/08/21/Hexo%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/08/21/Hexo%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>下面主要是记录一下用Github+Hexo搭建踩的坑 &amp;&amp; 开始搭建常用的命令</p><span id="more"></span><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="Hexo指令"><a href="#Hexo指令" class="headerlink" title="Hexo指令"></a>Hexo指令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean <span class="hljs-comment">#删除public文件的内容</span><br>hexo g <span class="hljs-comment">#生成静态文件到public</span><br>hexo d <span class="hljs-comment">#发布静态文件</span><br>hexo s <span class="hljs-comment">#本地运行</span><br>hexo new post &#123;&#123;文章标题&#125;&#125; <span class="hljs-comment">#创建新的文章</span><br>hexo new page <span class="hljs-comment">#source</span><br>hexo new draft <span class="hljs-comment">#source/_drafts</span><br></code></pre></td></tr></table></figure><h3 id="写作指令"><a href="#写作指令" class="headerlink" title="写作指令"></a>写作指令</h3><p><code>tags</code>用法： [标签1, 标签2]<br><code>categories</code>用法：[分类1,分类2]</p><h2 id="其他解决"><a href="#其他解决" class="headerlink" title="其他解决"></a>其他解决</h2><h3 id="Operation-timed-out"><a href="#Operation-timed-out" class="headerlink" title="Operation timed out"></a>Operation timed out</h3><h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h4><p>这个是因为代理的问题，采用终端需要配置代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl cip.cc <span class="hljs-comment">#查看当前IP地址</span><br>vi ~/.zshrc <span class="hljs-comment">#编辑配置,Mac电脑</span><br></code></pre></td></tr></table></figure><p>在配置中添加如下内容，这里的端口号需要自行查看自己的网络设置中的端口号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> proxy=<span class="hljs-string">&#x27;export http_proxy=127.0.0.1:7897;export https_proxy=$http_proxy&#x27;</span><br><span class="hljs-built_in">alias</span> proxyOff=<span class="hljs-string">&#x27;unset http_proxy;unset https_proxy&#x27;</span><br></code></pre></td></tr></table></figure><p>让配置生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure><p>代理模式的开启和关闭</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">proxy <span class="hljs-comment">#开启代理模式</span><br>unproxy <span class="hljs-comment">#关闭代理模式</span><br></code></pre></td></tr></table></figure><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>设置代理，这里的端口号需要自行查看自己的网络设置中的端口号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> http_proxy=http://127.0.0.1:7890<br><span class="hljs-built_in">set</span> https_proxy=http://127.0.0.1:7890<br></code></pre></td></tr></table></figure><p>还原代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> http_proxy=<br><span class="hljs-built_in">set</span> https_proxy=<br></code></pre></td></tr></table></figure><h3 id="Permission-denied"><a href="#Permission-denied" class="headerlink" title="Permission denied"></a>Permission denied</h3><p>这里是需要把repo的格式改一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">https://自己的token@github.com/用户名/用户名.github.io.git<br></code></pre></td></tr></table></figure><h3 id="插入图片问题"><a href="#插入图片问题" class="headerlink" title="插入图片问题"></a>插入图片问题</h3><ol><li>我采用的本地编辑器是typora，首先设置图片路径为如下：</li></ol><p><img src="/Assets/image-20230902125637824.png" alt="image-20230902125637824"></p><ol start="2"><li><p>在<code>_config.yml</code>配置文件把<code>false</code>改成<code>true</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">post_asset_folder: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install https://github.com/CodeFalling/hexo-asset-image --save<br></code></pre></td></tr></table></figure></li><li><p>踩的坑：不要在文档上方加<code>typora-root-url:../</code>，解析出来反而不太对</p><ul><li>正确的解析路径应该如下：<code>/2023/09/01/Flowable/image-20230902125239150.png</code></li><li>之前解析路径如下：<code>/2023/09/01/Flowable/Flowable/image-20230902125239150.png</code></li></ul></li></ol><h3 id="Update插入图片问题"><a href="#Update插入图片问题" class="headerlink" title="Update插入图片问题"></a>Update插入图片问题</h3><p>由于最近入坑了Obsidian，感觉很多文件夹比较繁杂，所以采用统一assets管理图片附件，放在<code>source/Assets</code>下。但是如果在Obsidian采用相对路径<code>/Assets</code>，在主页显示不了，因为它的图片读取路径和本地不一样；但如果将路径改为<code>/Assets</code>则可以读取，这是因为它把<code>source</code>看作根路径了<br>同时在Obsidian中，也需要将图片的粘贴路径做如下更改：<br><img src="/Assets/Pasted%20image%2020240418162040.png"></p><p>所以写了一个js文件，在<code>hexo s</code>生成<code>public</code>文件前，把所有<code>/Assets</code>改为<code>/Assets</code>即可，生成后再复原，这样在本地和网页都能显示。<code>js</code>文件如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);  <br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);  <br><span class="hljs-keyword">const</span> glob = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;glob&#x27;</span>);  <br>  <br><span class="hljs-keyword">const</span> directoryPaths = [  <br>  <span class="hljs-string">&#x27;source/_posts&#x27;</span><br>];  <br>  <br><span class="hljs-keyword">const</span> extension = <span class="hljs-string">&#x27;**/*.md&#x27;</span>;<br>  <br>directoryPaths.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">directoryPath</span> =&gt;</span> &#123;  <br>  <span class="hljs-title function_">glob</span>(path.<span class="hljs-title function_">join</span>(directoryPath, extension), <span class="hljs-function">(<span class="hljs-params">err, files</span>) =&gt;</span> &#123;  <br>    <span class="hljs-keyword">if</span> (err) &#123;  <br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Error reading <span class="hljs-subst">$&#123;directoryPath&#125;</span>:`</span>, err);  <br>      <span class="hljs-keyword">return</span>;  <br>    &#125;  <br>  <br>    files.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> &#123;  <br>      fs.<span class="hljs-title function_">readFile</span>(file, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;  <br>        <span class="hljs-keyword">if</span> (err) &#123;  <br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Error reading file <span class="hljs-subst">$&#123;file&#125;</span>:`</span>, err);  <br>          <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>        <br>        <span class="hljs-comment">// const newData = data.replace(/\/Assets/g, &#x27;/Assets&#x27;);  </span><br>        <span class="hljs-keyword">const</span> newData = data.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\.\.\/Assets/g</span>, <span class="hljs-string">&#x27;\/Assets&#x27;</span>);  <br>  <br>        fs.<span class="hljs-title function_">writeFile</span>(file, newData, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;  <br>          <span class="hljs-keyword">if</span> (err) &#123;  <br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Error writing to file <span class="hljs-subst">$&#123;file&#125;</span>:`</span>, err);  <br>            <span class="hljs-keyword">return</span>;  <br>          &#125;  <br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`File <span class="hljs-subst">$&#123;file&#125;</span> updated successfully.`</span>);  <br>        &#125;);  <br>      &#125;);  <br>    &#125;);  <br>  &#125;);  <br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="Latex数学公式显示问题"><a href="#Latex数学公式显示问题" class="headerlink" title="Latex数学公式显示问题"></a>Latex数学公式显示问题</h3><p>在官网找到对应的设置修改即可</p><ol><li>在主题配置中修改：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">post:<br>  math:<br>    <span class="hljs-built_in">enable</span>: <span class="hljs-literal">true</span><br>    specific: <span class="hljs-literal">false</span><br>    engine: katex<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm uninstall hexo-renderer-marked --save<br>npm install hexo-renderer-markdown-it --save<br>npm install @traptitech/markdown-it-katex --save<br></code></pre></td></tr></table></figure><ol start="2"><li>在站点配置中修改：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">markdown:<br>  plugins:<br>    - <span class="hljs-string">&quot;@traptitech/markdown-it-katex&quot;</span><br></code></pre></td></tr></table></figure><h3 id="文章引用"><a href="#文章引用" class="headerlink" title="文章引用"></a>文章引用</h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">post_path</span> filename %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">post_link</span> filename [title] [escape] %&#125;</span><br></code></pre></td></tr></table></figure><ol><li>默认链接文字是文章的标题，也可以自定义要显示的文本</li><li>可以使用 <code>escape</code> 选项，禁止对特殊字符进行转义</li></ol><h3 id="添加更新时间"><a href="#添加更新时间" class="headerlink" title="添加更新时间"></a>添加更新时间</h3><ol><li>在模版中添加<code>updated:</code></li><li>添加下面<code>js</code>文件，然后运行，即可更新</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">#!/usr/bin/env node</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;脚本开始运行..&#x27;</span>);<br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;fs&quot;</span>); <br><span class="hljs-keyword">var</span> file = <span class="hljs-string">&quot;./txt&quot;</span>; <br><span class="hljs-keyword">var</span> <span class="hljs-title class_">RegExp</span>=<span class="hljs-regexp">/(updated:\s*)((\d&#123;2&#125;(([02468][048])|([13579][26]))[\-\/\s]?((((0?[13578])|(1[02]))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\-\/\s]?((0?[1-9])|([1-2][0-9])))))|(\d&#123;2&#125;(([02468][1235679])|([13579][01345789]))[\-\/\s]?((((0?[13578])|(1[02]))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(3[01])))|(((0?[469])|(11))[\-\/\s]?((0?[1-9])|([1-2][0-9])|(30)))|(0?2[\-\/\s]?((0?[1-9])|(1[0-9])|(2[0-8]))))))(\s((([0-1][0-9])|(2?[0-3]))\:([0-5]?[0-9])((\s)|(\:([0-5]?[0-9])))))/g</span>;<br><span class="hljs-keyword">let</span> toppath=<span class="hljs-string">&quot;source/_posts/&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">path</span>)&#123;<br>    fs.<span class="hljs-title function_">readdir</span>(path,<span class="hljs-function">(<span class="hljs-params">err,files</span>)=&gt;</span>&#123;<br>        files.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)&#123;<br>            fs.<span class="hljs-title function_">stat</span>(path+item+<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>                <span class="hljs-keyword">if</span>(data.<span class="hljs-title function_">isFile</span>())&#123;<br>                    <span class="hljs-keyword">if</span>(item.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;.md&quot;</span>)&gt;-<span class="hljs-number">1</span>)&#123;<br>                        <span class="hljs-title function_">writeFileTime</span>(path+item,fs);<br>                    &#125;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-title function_">fn</span>(path+item+<span class="hljs-string">&#x27;/&#x27;</span>)<br>                &#125;<br>            &#125;)<br>        &#125;)<br>    &#125;)<br>&#125;<br><span class="hljs-title function_">fn</span>(toppath)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">writeFileTime</span>(<span class="hljs-params">file,fs</span>)&#123;<br>    fs.<span class="hljs-title function_">readFile</span>(file, <span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err, data</span>) &#123; <br>        <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;读取文件内容错误：&quot;</span>,err);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-title function_">test</span>(data))&#123; <br>            fs.<span class="hljs-title function_">stat</span>(file,<span class="hljs-keyword">function</span>(<span class="hljs-params">err, stats</span>) &#123; <br>                <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;读取文件信息错误：&quot;</span>,err);<br>                <span class="hljs-keyword">var</span> updateds=data.<span class="hljs-title function_">match</span>(<span class="hljs-title class_">RegExp</span>);<br>                <span class="hljs-comment">//console.log(&quot;updated数组:&quot;,updateds);</span><br>                <span class="hljs-keyword">if</span>(updateds.<span class="hljs-property">length</span>&gt;<span class="hljs-number">1</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;文件&quot;</span>+file+<span class="hljs-string">&quot;匹配到多处update字段&quot;</span>);<br>                <span class="hljs-keyword">var</span> updated=updateds[<span class="hljs-number">0</span>].<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;updated: &quot;</span>,<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/-/g</span>,<span class="hljs-string">&quot;/&quot;</span>);  <span class="hljs-comment">//时间格式化为2018/01/29 21:33:30</span><br>                <span class="hljs-comment">//console.log(&quot;updated:&quot;,updated);</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(stats.<span class="hljs-property">mtime</span>).<span class="hljs-title function_">getTime</span>()-<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">parse</span>(updated))&gt;<span class="hljs-number">1000</span>*<span class="hljs-number">60</span>*<span class="hljs-number">5</span>)&#123; <span class="hljs-comment">// 只要修改时间和文章内updated时间差大于1000毫秒*60*5=5分钟就触发更新</span><br>                    <span class="hljs-keyword">var</span> result= data.<span class="hljs-title function_">replace</span>(<span class="hljs-title class_">RegExp</span>,<span class="hljs-string">&quot;updated: &quot;</span>+<span class="hljs-title function_">getFormatDate</span>(stats.<span class="hljs-property">mtime</span>)); <span class="hljs-comment">//替换更新时间</span><br>                    fs.<span class="hljs-title function_">writeFile</span>(file, result, <span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123; <span class="hljs-comment">//写入新的文件内容</span><br>                        <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;写文件错误：&quot;</span>,err);<br>                        fs.<span class="hljs-title function_">utimes</span>(file,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(stats.<span class="hljs-property">atime</span>),<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(stats.<span class="hljs-property">mtime</span>),<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)&#123;  <span class="hljs-comment">//还原访问时间和修改时间</span><br>                            <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;修改时间失败：&quot;</span>,err);<br>                            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(file,<span class="hljs-string">&quot;成功更新时间&quot;</span>);<br>                        &#125;);<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> timeStr:时间，格式可为：&quot;September 16,2016 14:15:05、</span><br><span class="hljs-comment"> &quot;September 16,2016&quot;、&quot;2016/09/16 14:15:05&quot;、&quot;2016/09/16&quot;、</span><br><span class="hljs-comment"> &#x27;2014-04-23T18:55:49&#x27;和毫秒</span><br><span class="hljs-comment"> dateSeparator：年、月、日之间的分隔符，默认为&quot;-&quot;，</span><br><span class="hljs-comment"> timeSeparator：时、分、秒之间的分隔符，默认为&quot;:&quot;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getFormatDate</span>(<span class="hljs-params">timeStr, dateSeparator, timeSeparator</span>) &#123;<br>    dateSeparator = dateSeparator ? dateSeparator : <span class="hljs-string">&quot;-&quot;</span>;<br>    timeSeparator = timeSeparator ? timeSeparator : <span class="hljs-string">&quot;:&quot;</span>;<br>    <span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(timeStr),<br>        year = date.<span class="hljs-title function_">getFullYear</span>(),<span class="hljs-comment">// 获取完整的年份(4位,1970)</span><br>        month = date.<span class="hljs-title function_">getMonth</span>(),<span class="hljs-comment">// 获取月份(0-11,0代表1月,用的时候记得加上1)</span><br>        day = date.<span class="hljs-title function_">getDate</span>(),<span class="hljs-comment">// 获取日(1-31)</span><br>        hour = date.<span class="hljs-title function_">getHours</span>(),<span class="hljs-comment">// 获取小时数(0-23)</span><br>        minute = date.<span class="hljs-title function_">getMinutes</span>(),<span class="hljs-comment">// 获取分钟数(0-59)</span><br>        seconds = date.<span class="hljs-title function_">getSeconds</span>(),<span class="hljs-comment">// 获取秒数(0-59)</span><br>        Y = year + dateSeparator,<br>        M = ((month + <span class="hljs-number">1</span>) &gt; <span class="hljs-number">9</span> ? (month + <span class="hljs-number">1</span>) : (<span class="hljs-string">&#x27;0&#x27;</span> + (month + <span class="hljs-number">1</span>))) + dateSeparator,<br>        D = (day &gt; <span class="hljs-number">9</span> ? day : (<span class="hljs-string">&#x27;0&#x27;</span> + day)) + <span class="hljs-string">&#x27; &#x27;</span>,<br>        h = (hour &gt; <span class="hljs-number">9</span> ? hour : (<span class="hljs-string">&#x27;0&#x27;</span> + hour)) + timeSeparator,<br>        m = (minute &gt; <span class="hljs-number">9</span> ? minute : (<span class="hljs-string">&#x27;0&#x27;</span> + minute)) + timeSeparator,<br>        s = (seconds &gt; <span class="hljs-number">9</span> ? seconds : (<span class="hljs-string">&#x27;0&#x27;</span> + seconds)),<br>        formatDate = Y + M + D + h + m + s;<br>    <span class="hljs-keyword">return</span> formatDate;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加更新时间-更改路径命令"><a href="#添加更新时间-更改路径命令" class="headerlink" title="添加更新时间 &amp; 更改路径命令"></a>添加更新时间 &amp; 更改路径命令</h3><p>为了方便，直接添加了一个命令来运行，在package中添加<br><img src="/Assets/Pasted%20image%2020240418162427.png"><br>即可通过<code>npm run my-deploy</code>来执行多个命令</p><h3 id="hexo-d报错"><a href="#hexo-d报错" class="headerlink" title="hexo d报错"></a>hexo d报错</h3><p>github的问题：fatal: detected dubious ownership in repository<br>可以用git config –global –add safe.directory “ * “语句</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
